package.preload['notify.signal'] = (function (...)
      ---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis <tiagokatcipis@gmail.com>
-- Copyright (C) 2010 Paulo Pizarro  <paulo.pizarro@gmail.com>
-- 
-- author Paulo Pizarro  <paulo.pizarro@gmail.com>
-- author Tiago Katcipis <tiagokatcipis@gmail.com>
 
-- This file is part of LuaNotify.
 
-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
 
-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
 
-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------------

---
-- @class module
-- @name signal
-- @description Signal Class.
-- @author <a href="mailto:tiagokatcipis@gmail.com">Tiago Katcipis</a>
-- @author <a href="mailto:paulo.pizarro@gmail.com">Paulo Pizarro</a>
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local require = require
local setmetatable = setmetatable

module(...)

local queue = require "notify.double_queue"

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local Signal = {} 


------------------------------------
-- Metamethods goes on this table --
------------------------------------
local Signal_mt = { __index = Signal }


--------------------------
-- Constructor function --
--------------------------
function new ()
    local object = {}      
    -- set the metatable of the new object as the Signal_mt table (inherits Signal).
    setmetatable(object, Signal_mt)

    -- create all the instance state data.
    object.handlers_block  = {}
    object.handlers        = queue.new()
    object.pre_emit_funcs  = queue.new()
    object.post_emit_funcs = queue.new()
    object.signal_stopped = false
    return object
end


----------------------------------
-- Class definition and methods --
----------------------------------


---
-- Disconnects a handler function from this signal, the function will no longer be called.
-- @param handler_function – The function that will be disconnected.
function Signal:disconnect(handler_function)
    self.handlers:remove(handler_function)
    self.handlers_block[handler_function] = nil
end


---
-- Connects a handler function on this signal, all handlers connected will be called 
-- when the signal is emitted with a FIFO  behaviour (The first connected will be the first called).
-- @param handler_function – The function that will be called when this signal is emitted.
function Signal:connect(handler_function)
    if(not self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = 0
        self.handlers:push_back(handler_function)
    end
end


---
-- Does not execute the given handler function when the signal is emitted until it is unblocked. 
-- It can be called several times for the same handler function.
-- @param handler_function – The handler function that will be blocked.
function Signal:block(handler_function)
    if(self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = self.handlers_block[handler_function] + 1
    end
end


---
-- Unblocks the given handler function, this handler function will be executed on 
-- the order it was previously connected, and it will only be unblocked when 
-- the calls to unblock are equal to the calls to block.
-- @param handler_function – The handler function that will be unblocked.
function Signal:unblock(handler_function)
    if(self.handlers_block[handler_function]) then
        if(self.handlers_block[handler_function] > 0) then
            self.handlers_block[handler_function] = self.handlers_block[handler_function] - 1
        end
    end
end


---
-- Emits a signal calling the handler functions connected to this signal passing the given args.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit(...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            handler(...)
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Typical signal emission discards handler return values completely. 
-- This is most often what you need: just inform the world about something. 
-- However, sometimes you need a way to get feedback. For instance, 
-- you may want to ask: “is this value acceptable, eh?”
-- This is what accumulators are for. Accumulators are specified to signals at emission time. 
-- They can combine, alter or discard handler return values, post-process them or even stop emission. 
-- Since a handler can return multiple values, accumulators can receive multiple args too, following 
-- Lua flexible style we give the user the freedom to do whatever he wants with accumulators.
-- @param accumulator – Function that will accumulate handlers results.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit_with_accumulator(accumulator, ...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            accumulator(handler(...))
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Adds a pre_emit func, pre_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, will not receive any data passed 
-- on the emission and they are always called before ANY handler is called. 
-- This is useful when you want to perform some global task before handling an event, 
-- like opening a socket that the handlers might need to use or a database, pre_emit functions 
-- can make sure everything is ok before handling an event, reducing the need to do this check_ups 
-- inside the handler function. They are called on a queue (FIFO) policy based on the order they added.
-- @param pre_emit_func – The pre_emit function.
function Signal:add_pre_emit(pre_emit_func)
    self.pre_emit_funcs:push_back(pre_emit_func)
end


---
-- Removes the pre_emit function
-- @param pre_emit_func – The pre_emit function.
function Signal:remove_pre_emit(pre_emit_func)
    self.pre_emit_funcs:remove(pre_emit_func)
end


---
-- Adds a post_emit function, post_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, they will not receive any data 
-- passed on the emission and they are always called after ALL handlers where called. 
-- This is useful when you want to perform some global task after handling an event, 
-- like closing a socket that the handlers might need to use or a database or do some cleanup. 
-- post_emit functions can make sure everything is released after handling an event, 
-- reducing the need to do this check_ups inside some handler function, since some resources 
-- can be shared by multiple handlers. They are called on a stack (LIFO) policy based on the order they added.
-- @param post_emit_func – The post_emit function.
function Signal:add_post_emit(post_emit_func)
    self.post_emit_funcs:push_front(post_emit_func)
end

---
-- Removes the post_emit function
-- @param post_emit_func – The post_emit function.
function Signal:remove_post_emit(post_emit_func)
    self.post_emit_funcs:remove(post_emit_func)
end


---
-- Stops the current emission, if there is any handler left to be called by the signal it wont be called.
function Signal:stop()
    self.signal_stopped = true
end

     end)package.preload['notify.double_queue'] = (function (...)
      ---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis <tiagokatcipis@gmail.com>
-- Copyright (C) 2010 Paulo Pizarro  <paulo.pizarro@gmail.com>
-- 
-- author Paulo Pizarro  <paulo.pizarro@gmail.com>
-- author Tiago Katcipis <tiagokatcipis@gmail.com>

-- This file is part of LuaNotify.

-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.

-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------------

---
-- @class module
-- @name ordered_set
-- @description DoubleQueue Class.
-- @author <a href="mailto:tiagokatcipis@gmail.com">Tiago Katcipis</a>
-- @author <a href="mailto:paulo.pizarro@gmail.com">Paulo Pizarro</a>
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local setmetatable = setmetatable

module(...)

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local DoubleQueue = {}

------------------------------------
-- Metamethods goes on this table --
------------------------------------
local DoubleQueue_mt = { __index = DoubleQueue }


--------------------------
-- Constructor function --
--------------------------

function new ()
    local object = {}
    -- set the metatable of the new object as the DoubleQueue_mt table (inherits DoubleQueue).
    setmetatable(object, DoubleQueue_mt)

    -- create all the instance state data.
    object.data          = {}
    object.data_position = {}
    object.first         = 1 
    object.last          = 0
    return object
end

---------------------------
-- Class private methods --
---------------------------
local function refresh_first(self)
    while(self.first <= self.last) do
        if(self.data[self.first]) then
            return true
        end
        self.first = self.first + 1
    end
end


--------------------------
-- Class public methods --
--------------------------
function DoubleQueue:is_empty()
    return self.first > self.last
end

function DoubleQueue:push_front(data)
    if(self.data_position[data]) then
        return
    end
    self.first = self.first - 1
    self.data[self.first]    = data
    self.data_position[data] = self.first
end

function DoubleQueue:push_back(data)
    if(self.data_position[data]) then
        return
    end
    self.last = self.last + 1
    self.data[self.last]     = data
    self.data_position[data] = self.last
end

function DoubleQueue:get_iterator()
    local first = self.first
    local function iterator()
        while(first <= self.last) do
            local data = self.data[first]
            first = first + 1
            if(data) then
                return data
            end
        end    
    end 
    return iterator
end

function DoubleQueue:remove(data)
    if(not self.data_position[data]) then
        return 
    end
    self.data[self.data_position[data]] = nil
    self.data_position[data]            = nil
    refresh_first(self)
end

     end)package.preload['pl.config'] = (function (...)
      --- Reads configuration files into a Lua table.
--  Understands INI files, classic Unix config files, and simple
-- delimited columns of values.
--
--    # test.config
--    # Read timeout in seconds
--    read.timeout=10
--    # Write timeout in seconds
--    write.timeout=5
--    #acceptable ports
--    ports = 1002,1003,1004
--
--    -- readconfig.lua
--    local config = require 'config'
--    local t = config.read 'test.config'
--    print(pretty.write(t))
--
--    ### output #####
--    {
--      ports = {
--        1002,
--        1003,
--        1004
--      },
--      write_timeout = 5,
--      read_timeout = 10
--    }
--
-- @module config

local type,tonumber,ipairs,io, table = _G.type,_G.tonumber,_G.ipairs,_G.io,_G.table

local function split(s,re)
    local res = {}
    local t_insert = table.insert
    re = '[^'..re..']+'
    for k in s:gmatch(re) do t_insert(res,k) end
    return res
end

local function strip(s)
    return s:gsub('^%s+',''):gsub('%s+$','')
end

local function strip_quotes (s)
    return s:gsub("['\"](.*)['\"]",'%1')
end

local config = {}

--- like io.lines(), but allows for lines to be continued with '\'.
-- @param file a file-like object (anything where read() returns the next line) or a filename.
-- Defaults to stardard input.
-- @return an iterator over the lines, or nil
-- @return error 'not a file-like object' or 'file is nil'
function config.lines(file)
    local f,openf,err
    local line = ''
    if type(file) == 'string' then
        f,err = io.open(file,'r')
        if not f then return nil,err end
        openf = true
    else
        f = file or io.stdin
        if not file.read then return nil, 'not a file-like object' end
    end
    if not f then return nil, 'file is nil' end
    return function()
        local l = f:read()
        while l do
            -- only for non-blank lines that don't begin with either ';' or '#'
            if l:match '%S' and not l:match '^%s*[;#]' then
                -- does the line end with '\'?
                local i = l:find '\\%s*$'
                if i then -- if so,
                    line = line..l:sub(1,i-1)
                elseif line == '' then
                    return l
                else
                    l = line..l
                    line = ''
                    return l
                end
            end
            l = f:read()
        end
        if openf then f:close() end
    end
end

--- read a configuration file into a table
-- @param file either a file-like object or a string, which must be a filename
-- @param cnfg a configuration table that may contain these fields:
-- <ul>
-- <li> variablilize make names into valid Lua identifiers (default true)</li>
-- <li> convert_numbers try to convert values into numbers (default true)</li>
-- <li> trim_space ensure that there is no starting or trailing whitespace with values (default true)</li>
-- <li> trim_quotes remove quotes from strings (default false)</li>
-- <li> list_delim delimiter to use when separating columns (default ',')</li>
-- </ul>
-- @return a table containing items, or nil
-- @return error message (same as @{config.lines}
function config.read(file,cnfg)
    local f,openf,err,auto

    local iter,err = config.lines(file)
    if not iter then return nil,err end
    local line = iter()
    cnfg = cnfg or {}
    if cnfg.smart then
        auto = true
        if line:match '^[^=]+=' then
            cnfg.keysep = '='
        elseif line:match '^[^:]+:' then
            cnfg.keysep = ':'
            cnfg.list_delim = ':'
        elseif line:match '^%S+%s+' then
            cnfg.keysep = ' '
            -- more than two columns assume that it's a space-delimited list
            -- cf /etc/fstab with /etc/ssh/ssh_config
            if line:match '^%S+%s+%S+%s+%S+' then
                cnfg.list_delim = ' '
            end
            cnfg.variabilize = false
        end
    end


    local function check_cnfg (var,def)
        local val = cnfg[var]
        if val == nil then return def else return val end
    end

    local initial_digits = '^[%d%+%-]'
    local t = {}
    local top_t = t
    local variablilize = check_cnfg ('variabilize',true)
    local list_delim = check_cnfg('list_delim',',')
    local convert_numbers = check_cnfg('convert_numbers',true)
    local trim_space = check_cnfg('trim_space',true)
    local trim_quotes = check_cnfg('trim_quotes',false)
    local ignore_assign = check_cnfg('ignore_assign',false)
    local keysep = check_cnfg('keysep','=')
    local keypat = keysep == ' ' and '%s+' or '%s*'..keysep..'%s*'
    if list_delim == ' ' then list_delim = '%s+' end

    local function process_name(key)
        if variablilize then
            key = key:gsub('[^%w]','_')
        end
        return key
    end

    local function process_value(value)
        if list_delim and value:find(list_delim) then
            value = split(value,list_delim)
            for i,v in ipairs(value) do
                value[i] = process_value(v)
            end
        elseif convert_numbers and value:find(initial_digits) then
            local val = tonumber(value)
            if not val and value:match ' kB$' then
                value = value:gsub(' kB','')
                val = tonumber(value)
            end
            if val then value = val end
        end
        if type(value) == 'string' then
           if trim_space then value = strip(value) end
           if not trim_quotes and auto and value:match '^"' then
                trim_quotes = true
            end
           if trim_quotes then value = strip_quotes(value) end
        end
        return value
    end

    while line do
        if line:find('^%[') then -- section!
            local section = process_name(line:match('%[([^%]]+)%]'))
            t = top_t
            t[section] = {}
            t = t[section]
        else
            line = line:gsub('^%s*','')
            local i1,i2 = line:find(keypat)
            if i1 and not ignore_assign then -- key,value assignment
                local key = process_name(line:sub(1,i1-1))
                local value = process_value(line:sub(i2+1))
                t[key] = value
            else -- a plain list of values...
                t[#t+1] = process_value(line)
            end
        end
        line = iter()
    end
    return top_t
end

return config

     end)package.preload['pl.dir'] = (function (...)
      --- Getting directory contents and matching them against wildcards.
--
-- Dependencies: `pl.utils`, `pl.path`, `pl.tablex`
--
-- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
-- @module pl.dir

local utils = require 'pl.utils'
local path = require 'pl.path'
local is_windows = path.is_windows
local tablex = require 'pl.tablex'
local ldir = path.dir
local chdir = path.chdir
local mkdir = path.mkdir
local rmdir = path.rmdir
local sub = string.sub
local os,pcall,ipairs,pairs,require,setmetatable,_G = os,pcall,ipairs,pairs,require,setmetatable,_G
local remove = os.remove
local append = table.insert
local wrap = coroutine.wrap
local yield = coroutine.yield
local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise
local List = utils.stdmt.List

local dir = {}

local function assert_dir (n,val)
    assert_arg(n,val,'string',path.isdir,'not a directory',4)
end

local function assert_file (n,val)
    assert_arg(n,val,'string',path.isfile,'not a file',4)
end

local function filemask(mask)
    mask = utils.escape(mask)
    return mask:gsub('%%%*','.+'):gsub('%%%?','.')..'$'
end

--- does the filename match the shell pattern?.
-- (cf. fnmatch.fnmatch in Python, 11.8)
-- @param file A file name
-- @param pattern A shell pattern
-- @return true or false
-- @raise file and pattern must be strings
function dir.fnmatch(file,pattern)
    assert_string(1,file)
    assert_string(2,pattern)
    return path.normcase(file):find(filemask(pattern)) ~= nil
end

--- return a list of all files which match the pattern.
-- (cf. fnmatch.filter in Python, 11.8)
-- @param files A table containing file names
-- @param pattern A shell pattern.
-- @return list of files
-- @raise file and pattern must be strings
function dir.filter(files,pattern)
    assert_arg(1,files,'table')
    assert_string(2,pattern)
    local res = {}
    local mask = filemask(pattern)
    for i,f in ipairs(files) do
        if f:find(mask) then append(res,f) end
    end
    return setmetatable(res,List)
end

local function _listfiles(dir,filemode,match)
    local res = {}
    local check = utils.choose(filemode,path.isfile,path.isdir)
    if not dir then dir = '.' end
    for f in ldir(dir) do
        if f ~= '.' and f ~= '..' then
            local p = path.join(dir,f)
            if check(p) and (not match or match(p)) then
                append(res,p)
            end
        end
    end
    return setmetatable(res,List)
end

--- return a list of all files in a directory which match the a shell pattern.
-- @param dir A directory. If not given, all files in current directory are returned.
-- @param mask  A shell pattern. If not given, all files are returned.
-- @return lsit of files
-- @raise dir and mask must be strings
function dir.getfiles(dir,mask)
    assert_dir(1,dir)
    if mask then assert_string(2,mask) end
    local match
    if mask then
        mask = filemask(mask)
        match = function(f)
            return f:find(mask)
        end
    end
    return _listfiles(dir,true,match)
end

--- return a list of all subdirectories of the directory.
-- @param dir A directory
-- @return a list of directories
-- @raise dir must be a string
function dir.getdirectories(dir)
    assert_dir(1,dir)
    return _listfiles(dir,false)
end

local function quote_argument (f)
    f = path.normcase(f)
    if f:find '%s' then
        return '"'..f..'"'
    else
        return f
    end
end


local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

local function execute_command(cmd,parms)
   if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
   local err = path.is_windows and ' > ' or ' 2> '
    cmd = cmd..' '..parms..err..cmd_tmpfile
    local ret = utils.execute(cmd)
    if not ret then
        return false,(utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
    else
        return true
    end
end

local function find_ffi_copyfile ()
    if not ffi_checked then
        ffi_checked = true
        local res
        res,alien = pcall(require,'alien')
        if not res then
            alien = nil
            res, ffi = pcall(require,'ffi')
        end
        if not res then
            ffi = nil
            return
        end
    else
        return
    end
    if alien then
        -- register the Win32 CopyFile and MoveFile functions
        local kernel = alien.load('kernel32.dll')
        CopyFile = kernel.CopyFileA
        CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
        MoveFile = kernel.MoveFileA
        MoveFile:types{'string','string',ret='int',abi='stdcall'}
        GetLastError = kernel.GetLastError
        GetLastError:types{ret ='int', abi='stdcall'}
    elseif ffi then
        ffi.cdef [[
            int CopyFileA(const char *src, const char *dest, int iovr);
            int MoveFileA(const char *src, const char *dest);
            int GetLastError();
        ]]
        CopyFile = ffi.C.CopyFileA
        MoveFile = ffi.C.MoveFileA
        GetLastError = ffi.C.GetLastError
    end
    win32_errors = {
        ERROR_FILE_NOT_FOUND    =         2,
        ERROR_PATH_NOT_FOUND    =         3,
        ERROR_ACCESS_DENIED    =          5,
        ERROR_WRITE_PROTECT    =          19,
        ERROR_BAD_UNIT         =          20,
        ERROR_NOT_READY        =          21,
        ERROR_WRITE_FAULT      =          29,
        ERROR_READ_FAULT       =          30,
        ERROR_SHARING_VIOLATION =         32,
        ERROR_LOCK_VIOLATION    =         33,
        ERROR_HANDLE_DISK_FULL  =         39,
        ERROR_BAD_NETPATH       =         53,
        ERROR_NETWORK_BUSY      =         54,
        ERROR_DEV_NOT_EXIST     =         55,
        ERROR_FILE_EXISTS       =         80,
        ERROR_OPEN_FAILED       =         110,
        ERROR_INVALID_NAME      =         123,
        ERROR_BAD_PATHNAME      =         161,
        ERROR_ALREADY_EXISTS    =         183,
    }
end

local function two_arguments (f1,f2)
    return quote_argument(f1)..' '..quote_argument(f2)
end

local function file_op (is_copy,src,dest,flag)
    if flag == 1 and path.exists(dest) then
        return false,"cannot overwrite destination"
    end
    if is_windows then
        -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
        find_ffi_copyfile()
        -- fallback if there's no Alien, just use DOS commands *shudder*
        -- 'rename' involves a copy and then deleting the source.
        if not CopyFile then
            src = path.normcase(src)
            dest = path.normcase(dest)
            local cmd = is_copy and 'copy' or 'rename'
            local res, err = execute_command('copy',two_arguments(src,dest))
            if not res then return nil,err end
            if not is_copy then
                return execute_command('del',quote_argument(src))
            end
        else
            if path.isdir(dest) then
                dest = path.join(dest,path.basename(src))
            end
			local ret
            if is_copy then ret = CopyFile(src,dest,flag)
            else ret = MoveFile(src,dest) end
            if ret == 0 then
                local err = GetLastError()
                for name,value in pairs(win32_errors) do
                    if value == err then return false,name end
                end
                return false,"Error #"..err
            else return true
            end
        end
    else -- for Unix, just use cp for now
        return execute_command(is_copy and 'cp' or 'mv',
            two_arguments(src,dest))
    end
end

--- copy a file.
-- @param src source file
-- @param dest destination file or directory
-- @param flag true if you want to force the copy (default)
-- @return true if operation succeeded
-- @raise src and dest must be strings
function dir.copyfile (src,dest,flag)
    assert_string(1,src)
    assert_string(2,dest)
    flag = flag==nil or flag
    return file_op(true,src,dest,flag and 0 or 1)
end

--- move a file.
-- @param src source file
-- @param dest destination file or directory
-- @return true if operation succeeded
-- @raise src and dest must be strings
function dir.movefile (src,dest)
    assert_string(1,src)
    assert_string(2,dest)
    return file_op(false,src,dest,0)
end

local function _dirfiles(dir,attrib)
    local dirs = {}
    local files = {}
    for f in ldir(dir) do
        if f ~= '.' and f ~= '..' then
            local p = path.join(dir,f)
            local mode = attrib(p,'mode')
            if mode=='directory' then
                append(dirs,f)
            else
                append(files,f)
            end
        end
    end
    return setmetatable(dirs,List),setmetatable(files,List)
end


local function _walker(root,bottom_up,attrib)
    local dirs,files = _dirfiles(root,attrib)
    if not bottom_up then yield(root,dirs,files) end
    for i,d in ipairs(dirs) do
        _walker(root..path.sep..d,bottom_up,attrib)
    end
    if bottom_up then yield(root,dirs,files) end
end

--- return an iterator which walks through a directory tree starting at root.
-- The iterator returns (root,dirs,files)
-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
-- to get the actual full path)
-- If bottom_up is false (or not present), then the entries at the current level are returned
-- before we go deeper. This means that you can modify the returned list of directories before
-- continuing.
-- This is a clone of os.walk from the Python libraries.
-- @param root A starting directory
-- @param bottom_up False if we start listing entries immediately.
-- @param follow_links follow symbolic links
-- @return an iterator returning root,dirs,files
-- @raise root must be a string
function dir.walk(root,bottom_up,follow_links)
    assert_dir(1,root)
    local attrib
    if path.is_windows or not follow_links then
        attrib = path.attrib
    else
        attrib = path.link_attrib
    end
    return wrap(function () _walker(root,bottom_up,attrib) end)
end

--- remove a whole directory tree.
-- @param fullpath A directory path
-- @return true or nil
-- @return error if failed
-- @raise fullpath must be a string
function dir.rmtree(fullpath)
    assert_dir(1,fullpath)
    if path.islink(fullpath) then return false,'will not follow symlink' end
    for root,dirs,files in dir.walk(fullpath,true) do
        for i,f in ipairs(files) do
            remove(path.join(root,f))
        end
        rmdir(root)
    end
    return true
end

local dirpat
if path.is_windows then
    dirpat = '(.+)\\[^\\]+$'
else
    dirpat = '(.+)/[^/]+$'
end

local _makepath
function _makepath(p)
    -- windows root drive case
    if p:find '^%a:[\\]*$' then
        return true
    end
   if not path.isdir(p) then
    local subp = p:match(dirpat)
    if not _makepath(subp) then return raise ('cannot create '..subp) end
    return mkdir(p)
   else
    return true
   end
end

--- create a directory path.
-- This will create subdirectories as necessary!
-- @param p A directory path
-- @return a valid created path
-- @raise p must be a string
function dir.makepath (p)
    assert_string(1,p)
    return _makepath(path.normcase(path.abspath(p)))
end


--- clone a directory tree. Will always try to create a new directory structure
-- if necessary.
-- @param path1 the base path of the source tree
-- @param path2 the new base path for the destination
-- @param file_fun an optional function to apply on all files
-- @param verbose an optional boolean to control the verbosity of the output.
--  It can also be a logging function that behaves like print()
-- @return true, or nil
-- @return error message, or list of failed directory creations
-- @return list of failed file operations
-- @raise path1 and path2 must be strings
-- @usage clonetree('.','../backup',copyfile)
function dir.clonetree (path1,path2,file_fun,verbose)
    assert_string(1,path1)
    assert_string(2,path2)
    if verbose == true then verbose = print end
    local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
    local faildirs,failfiles = {},{}
    if not isdir(path1) then return raise 'source is not a valid directory' end
    path1 = abspath(normcase(path1))
    path2 = abspath(normcase(path2))
    if verbose then verbose('normalized:',path1,path2) end
    -- particularly NB that the new path isn't fully contained in the old path
    if path1 == path2 then return raise "paths are the same" end
    local i1,i2 = path2:find(path1,1,true)
    if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
        return raise 'destination is a subdirectory of the source'
    end
    local cp = path.common_prefix (path1,path2)
    local idx = #cp
    if idx == 0 then -- no common path, but watch out for Windows paths!
        if path1:sub(2,2) == ':' then idx = 3 end
    end
    for root,dirs,files in dir.walk(path1) do
        local opath = path2..root:sub(idx)
        if verbose then verbose('paths:',opath,root) end
        if not isdir(opath) then
            local ret = dir.makepath(opath)
            if not ret then append(faildirs,opath) end
            if verbose then verbose('creating:',opath,ret) end
        end
        if file_fun then
            for i,f in ipairs(files) do
                local p1 = join(root,f)
                local p2 = join(opath,f)
                local ret = file_fun(p1,p2)
                if not ret then append(failfiles,p2) end
                if verbose then
                    verbose('files:',p1,p2,ret)
                end
            end
        end
    end
    return true,faildirs,failfiles
end

--- return an iterator over all entries in a directory tree
-- @param d a directory
-- @return an iterator giving pathname and mode (true for dir, false otherwise)
-- @raise d must be a non-empty string
function dir.dirtree( d )
    assert( d and d ~= "", "directory parameter is missing or empty" )
    local exists, isdir = path.exists, path.isdir
    local sep = path.sep

    local last = sub ( d, -1 )
    if last == sep or last == '/' then
        d = sub( d, 1, -2 )
    end

    local function yieldtree( dir )
        for entry in ldir( dir ) do
            if entry ~= "." and entry ~= ".." then
                entry = dir .. sep .. entry
                if exists(entry) then  -- Just in case a symlink is broken.
                    local is_dir = isdir(entry)
                    yield( entry, is_dir )
                    if is_dir then
                        yieldtree( entry )
                    end
                end
            end
        end
    end

    return wrap( function() yieldtree( d ) end )
end


---	Recursively returns all the file starting at <i>path</i>. It can optionally take a shell pattern and
--	only returns files that match <i>pattern</i>. If a pattern is given it will do a case insensitive search.
--	@param start_path {string} A directory. If not given, all files in current directory are returned.
--	@param pattern {string} A shell pattern. If not given, all files are returned.
--	@return Table containing all the files found recursively starting at <i>path</i> and filtered by <i>pattern</i>.
--  @raise start_path must be a string
function dir.getallfiles( start_path, pattern )
    assert_dir(1,start_path)
    pattern = pattern or ""

    local files = {}
    local normcase = path.normcase
    for filename, mode in dir.dirtree( start_path ) do
        if not mode then
            local mask = filemask( pattern )
            if normcase(filename):find( mask ) then
                files[#files + 1] = filename
            end
        end
    end

    return files
end

return dir
     end)package.preload['pl.pretty'] = (function (...)
      --- Pretty-printing Lua tables.
-- Also provides a sandboxed Lua table reader and
-- a function to present large numbers in human-friendly format.
--
-- Dependencies: `pl.utils`, `pl.lexer`
-- @module pl.pretty

local append = table.insert
local concat = table.concat
local utils = require 'pl.utils'
local lexer = require 'pl.lexer'
local assert_arg = utils.assert_arg

local pretty = {}

local function save_string_index ()
    local SMT = getmetatable ''
    if SMT then
        SMT.old__index = SMT.__index
        SMT.__index = nil
    end
    return SMT
end

local function restore_string_index (SMT)
    if SMT then
        SMT.__index = SMT.old__index
    end
end

--- read a string representation of a Lua table.
-- Uses load(), but tries to be cautious about loading arbitrary code!
-- It is expecting a string of the form '{...}', with perhaps some whitespace
-- before or after the curly braces. A comment may occur beforehand.
-- An empty environment is used, and
-- any occurance of the keyword 'function' will be considered a problem.
-- in the given environment - the return value may be `nil`.
-- @param s {string} string of the form '{...}', with perhaps some whitespace
-- before or after the curly braces.
-- @return a table
function pretty.read(s)
    assert_arg(1,s,'string')
    if s:find '^%s*%-%-' then -- may start with a comment..
        s = s:gsub('%-%-.-\n','')
    end
    if not s:find '^%s*%b{}%s*$' then return nil,"not a Lua table" end
    if s:find '[^\'"%w_]function[^\'"%w_]' then
        local tok = lexer.lua(s)
        for t,v in tok do
            if t == 'keyword' then
                return nil,"cannot have functions in table definition"
            end
        end
    end
    s = 'return '..s
    local chunk,err = utils.load(s,'tbl','t',{})
    if not chunk then return nil,err end
    local SMT = save_string_index()
    local ok,ret = pcall(chunk)
    restore_string_index(SMT)
    if ok then return ret
    else
        return nil,ret
    end
end

--- read a Lua chunk.
-- @param s Lua code
-- @param env optional environment
-- @param paranoid prevent any looping constructs and disable string methods
-- @return the environment
function pretty.load (s, env, paranoid)
    env = env or {}
    if paranoid then
        local tok = lexer.lua(s)
        for t,v in tok do
            if t == 'keyword'
                and (v == 'for' or v == 'repeat' or v == 'function' or v == 'goto')
            then
                return nil,"looping not allowed"
            end
        end
    end
    local chunk,err = utils.load(s,'tbl','t',env)
    if not chunk then return nil,err end
    local SMT = paranoid and save_string_index()
    local ok,err = pcall(chunk)
    restore_string_index(SMT)
    if not ok then return nil,err end
    return env
end

local function quote_if_necessary (v)
    if not v then return ''
    else
        if v:find ' ' then v = '"'..v..'"' end
    end
    return v
end

local keywords

local function is_identifier (s)
    return type(s) == 'string' and s:find('^[%a_][%w_]*$') and not keywords[s]
end

local function quote (s)
    if type(s) == 'table' then
        return pretty.write(s,'')
    else
        return ('%q'):format(tostring(s))
    end
end

local function index (numkey,key)
    if not numkey then key = quote(key) end
    return '['..key..']'
end


---	Create a string representation of a Lua table.
--  This function never fails, but may complain by returning an
--  extra value. Normally puts out one item per line, using
--  the provided indent; set the second parameter to '' if
--  you want output on one line.
--	@param tbl {table} Table to serialize to a string.
--	@param space {string} (optional) The indent to use.
--	Defaults to two spaces; make it the empty string for no indentation
--	@param not_clever {bool} (optional) Use for plain output, e.g {['key']=1}.
--	Defaults to false.
--  @return a string
--  @return a possible error message
function pretty.write (tbl,space,not_clever)
    if type(tbl) ~= 'table' then
        local res = tostring(tbl)
        if type(tbl) == 'string' then return quote(tbl) end
        return res, 'not a table'
    end
    if not keywords then
        keywords = lexer.get_keywords()
    end
    local set = ' = '
    if space == '' then set = '=' end
    space = space or '  '
    local lines = {}
    local line = ''
    local tables = {}


    local function put(s)
        if #s > 0 then
            line = line..s
        end
    end

    local function putln (s)
        if #line > 0 then
            line = line..s
            append(lines,line)
            line = ''
        else
            append(lines,s)
        end
    end

    local function eat_last_comma ()
        local n,lastch = #lines
        local lastch = lines[n]:sub(-1,-1)
        if lastch == ',' then
            lines[n] = lines[n]:sub(1,-2)
        end
    end


    local writeit
    writeit = function (t,oldindent,indent)
        local tp = type(t)
        if tp ~= 'string' and  tp ~= 'table' then
            putln(quote_if_necessary(tostring(t))..',')
        elseif tp == 'string' then
            if t:find('\n') then
                putln('[[\n'..t..']],')
            else
                putln(quote(t)..',')
            end
        elseif tp == 'table' then
            if tables[t] then
                putln('<cycle>,')
                return
            end
            tables[t] = true
            local newindent = indent..space
            putln('{')
            local used = {}
            if not not_clever then
                for i,val in ipairs(t) do
                    put(indent)
                    writeit(val,indent,newindent)
                    used[i] = true
                end
            end
            for key,val in pairs(t) do
                local numkey = type(key) == 'number'
                if not_clever then
                    key = tostring(key)
                    put(indent..index(numkey,key)..set)
                    writeit(val,indent,newindent)
                else
                    if not numkey or not used[key] then -- non-array indices
                        if numkey or not is_identifier(key) then
                            key = index(numkey,key)
                        end
                        put(indent..key..set)
                        writeit(val,indent,newindent)
                    end
                end
            end
            tables[t] = nil
            eat_last_comma()
            putln(oldindent..'},')
        else
            putln(tostring(t)..',')
        end
    end
    writeit(tbl,'',space)
    eat_last_comma()
    return concat(lines,#space > 0 and '\n' or '')
end

---	Dump a Lua table out to a file or stdout.
--	@param t {table} The table to write to a file or stdout.
--	@param ... {string} (optional) File name to write too. Defaults to writing
--	to stdout.
function pretty.dump (t,...)
    if select('#',...)==0 then
        print(pretty.write(t))
        return true
    else
        return utils.writefile(...,pretty.write(t))
    end
end

local memp,nump = {'B','KiB','MiB','GiB'},{'','K','M','B'}

local comma
function comma (val)
    local thou = math.floor(val/1000)
    if thou > 0 then return comma(thou)..','..(val % 1000)
    else return tostring(val) end
end

--- format large numbers nicely for human consumption.
-- @param num a number
-- @param kind one of 'M' (memory in KiB etc), 'N' (postfixes are 'K','M' and 'B')
-- and 'T' (use commas as thousands separator)
-- @param prec number of digits to use for 'M' and 'N' (default 1)
function pretty.number (num,kind,prec)
    local fmt = '%.'..(prec or 1)..'f%s'
    if kind == 'T' then
        return comma(num)
    else
        local postfixes, fact
        if kind == 'M' then
            fact = 1024
            postfixes = memp
        else
            fact = 1000
            postfixes = nump
        end
        local div = fact
        local k = 1
        while num >= div and k <= #postfixes do
            div = div * fact
            k = k + 1
        end
        div = div / fact
        if k > #postfixes then k = k - 1; div = div/fact end
        if k > 1 then
            return fmt:format(num/div,postfixes[k] or 'duh')
        else
            return num..postfixes[1]
        end
    end
end

return pretty
     end)package.preload['pl.stringx'] = (function (...)
      --- Python-style extended string library.
--
-- see 3.6.1 of the Python reference.
-- If you want to make these available as string methods, then say
-- `stringx.import()` to bring them into the standard `string` table.
--
-- See @{03-strings.md|the Guide}
--
-- Dependencies: `pl.utils`
-- @module pl.stringx
local utils = require 'pl.utils'
local string = string
local find = string.find
local type,setmetatable,getmetatable,ipairs,unpack = type,setmetatable,getmetatable,ipairs,unpack
local error,tostring = error,tostring
local gsub = string.gsub
local rep = string.rep
local sub = string.sub
local concat = table.concat
local escape = utils.escape
local ceil = math.ceil
local _G = _G
local assert_arg,usplit,list_MT = utils.assert_arg,utils.split,utils.stdmt.List
local lstrip

local function assert_string (n,s)
    assert_arg(n,s,'string')
end

local function non_empty(s)
    return #s > 0
end

local function assert_nonempty_string(n,s)
    assert_arg(n,s,'string',non_empty,'must be a non-empty string')
end

local stringx = {}

--- does s only contain alphabetic characters?.
-- @param s a string
function stringx.isalpha(s)
    assert_string(1,s)
    return find(s,'^%a+$') == 1
end

--- does s only contain digits?.
-- @param s a string
function stringx.isdigit(s)
    assert_string(1,s)
    return find(s,'^%d+$') == 1
end

--- does s only contain alphanumeric characters?.
-- @param s a string
function stringx.isalnum(s)
    assert_string(1,s)
    return find(s,'^%w+$') == 1
end

--- does s only contain spaces?.
-- @param s a string
function stringx.isspace(s)
    assert_string(1,s)
    return find(s,'^%s+$') == 1
end

--- does s only contain lower case characters?.
-- @param s a string
function stringx.islower(s)
    assert_string(1,s)
    return find(s,'^[%l%s]+$') == 1
end

--- does s only contain upper case characters?.
-- @param s a string
function stringx.isupper(s)
    assert_string(1,s)
    return find(s,'^[%u%s]+$') == 1
end

--- concatenate the strings using this string as a delimiter.
-- @param self the string
-- @param seq a table of strings or numbers
-- @usage (' '):join {1,2,3} == '1 2 3'
function stringx.join (self,seq)
    assert_string(1,self)
    return concat(seq,self)
end

--- does string start with the substring?.
-- @param self the string
-- @param s2 a string
function stringx.startswith(self,s2)
    assert_string(1,self)
    assert_string(2,s2)
    return find(self,s2,1,true) == 1
end

local function _find_all(s,sub,first,last)
    if sub == '' then return #s+1,#s end
    local i1,i2 = find(s,sub,first,true)
    local res
    local k = 0
    while i1 do
        res = i1
        k = k + 1
        i1,i2 = find(s,sub,i2+1,true)
        if last and i1 > last then break end
    end
    return res,k
end

--- does string end with the given substring?.
-- @param s a string
-- @param send a substring or a table of suffixes
function stringx.endswith(s,send)
    assert_string(1,s)
    if type(send) == 'string' then
        return #s >= #send and s:find(send, #s-#send+1, true) and true or false
    elseif type(send) == 'table' then
        local endswith = stringx.endswith
        for _,suffix in ipairs(send) do
            if endswith(s,suffix) then return true end
        end
        return false
    else
        error('argument #2: either a substring or a table of suffixes expected')
    end
end

-- break string into a list of lines
-- @param self the string
-- @param keepends (currently not used)
function stringx.splitlines (self,keepends)
    assert_string(1,self)
    local res = usplit(self,'[\r\n]')
    -- we are currently hacking around a problem with utils.split (see stringx.split)
    if #res == 0 then res = {''} end
    return setmetatable(res,list_MT)
end

local function tab_expand (self,n)
    return (gsub(self,'([^\t]*)\t', function(s)
            return s..(' '):rep(n - #s % n)
    end))
end

--- replace all tabs in s with n spaces. If not specified, n defaults to 8.
-- with 0.9.5 this now correctly expands to the next tab stop (if you really
-- want to just replace tabs, use :gsub('\t','  ') etc)
-- @param self the string
-- @param n number of spaces to expand each tab, (default 8)
function stringx.expandtabs(self,n)
    assert_string(1,self)
    n = n or 8
    if not self:find '\n' then return tab_expand(self,n) end
    local res,i = {},1
    for line in stringx.lines(self) do
        res[i] = tab_expand(line,n)
        i = i + 1
    end
    return table.concat(res,'\n')
end

--- find index of first instance of sub in s from the left.
-- @param self the string
-- @param sub substring
-- @param  i1 start index
function stringx.lfind(self,sub,i1)
    assert_string(1,self)
    assert_string(2,sub)
    local idx = find(self,sub,i1,true)
    if idx then return idx else return nil end
end

--- find index of first instance of sub in s from the right.
-- @param self the string
-- @param sub substring
-- @param first first index
-- @param last last index
function stringx.rfind(self,sub,first,last)
    assert_string(1,self)
    assert_string(2,sub)
    local idx = _find_all(self,sub,first,last)
    if idx then return idx else return nil end
end

--- replace up to n instances of old by new in the string s.
-- if n is not present, replace all instances.
-- @param s the string
-- @param old the target substring
-- @param new the substitution
-- @param n optional maximum number of substitutions
-- @return result string
-- @return the number of substitutions
function stringx.replace(s,old,new,n)
    assert_string(1,s)
    assert_string(1,old)
    return (gsub(s,escape(old),new:gsub('%%','%%%%'),n))
end

--- split a string into a list of strings using a delimiter.
-- @class function
-- @name split
-- @param self the string
-- @param re a delimiter (defaults to whitespace)
-- @param n maximum number of results
-- @usage #(('one two'):split()) == 2
-- @usage ('one,two,three'):split(',') == List{'one','two','three'}
-- @usage ('one,two,three'):split(',',2) == List{'one','two,three'}
function stringx.split(self,re,n)
    local s = self
    local plain = true
    if not re then -- default spaces
        s = lstrip(s)
        plain = false
    end
    local res = usplit(s,re,plain,n)
    if re and re ~= '' and find(s,re,-#re,true) then
        res[#res+1] = ""
    end
	return setmetatable(res,list_MT)
end

--- split a string using a pattern. Note that at least one value will be returned!
-- @param self the string
-- @param re a Lua string pattern (defaults to whitespace)
-- @return the parts of the string
-- @usage  a,b = line:splitv('=')
function stringx.splitv (self,re)
    assert_string(1,self)
    return utils.splitv(self,re)
end

local function copy(self)
    return self..''
end

--- count all instances of substring in string.
-- @param self the string
-- @param sub substring
function stringx.count(self,sub)
    assert_string(1,self)
    local i,k = _find_all(self,sub,1)
    return k
end

local function _just(s,w,ch,left,right)
    local n = #s
    if w > n then
        if not ch then ch = ' ' end
        local f1,f2
        if left and right then
            local ln = ceil((w-n)/2)
            local rn = w - n - ln
            f1 = rep(ch,ln)
            f2 = rep(ch,rn)
        elseif right then
            f1 = rep(ch,w-n)
            f2 = ''
        else
            f2 = rep(ch,w-n)
            f1 = ''
        end
        return f1..s..f2
    else
        return copy(s)
    end
end

--- left-justify s with width w.
-- @param self the string
-- @param w width of justification
-- @param ch padding character, default ' '
function stringx.ljust(self,w,ch)
    assert_string(1,self)
    assert_arg(2,w,'number')
    return _just(self,w,ch,true,false)
end

--- right-justify s with width w.
-- @param s the string
-- @param w width of justification
-- @param ch padding character, default ' '
function stringx.rjust(s,w,ch)
    assert_string(1,s)
    assert_arg(2,w,'number')
    return _just(s,w,ch,false,true)
end

--- center-justify s with width w.
-- @param s the string
-- @param w width of justification
-- @param ch padding character, default ' '
function stringx.center(s,w,ch)
    assert_string(1,s)
    assert_arg(2,w,'number')
    return _just(s,w,ch,true,true)
end

local function _strip(s,left,right,chrs)
    if not chrs then
        chrs = '%s'
    else
        chrs = '['..escape(chrs)..']'
    end
    if left then
        local i1,i2 = find(s,'^'..chrs..'*')
        if i2 >= i1 then
            s = sub(s,i2+1)
        end
    end
    if right then
        local i1,i2 = find(s,chrs..'*$')
        if i2 >= i1 then
            s = sub(s,1,i1-1)
        end
    end
    return s
end

--- trim any whitespace on the left of s.
-- @param self the string
-- @param chrs default space, can be a string of characters to be trimmed
function stringx.lstrip(self,chrs)
    assert_string(1,self)
    return _strip(self,true,false,chrs)
end
lstrip = stringx.lstrip

--- trim any whitespace on the right of s.
-- @param s the string
-- @param chrs default space, can be a string of characters to be trimmed
function stringx.rstrip(s,chrs)
    assert_string(1,s)
    return _strip(s,false,true,chrs)
end

--- trim any whitespace on both left and right of s.
-- @param self the string
-- @param chrs default space, can be a string of characters to be trimmed
function stringx.strip(self,chrs)
    assert_string(1,self)
    return _strip(self,true,true,chrs)
end

-- The partition functions split a string  using a delimiter into three parts:
-- the part before, the delimiter itself, and the part afterwards
local function _partition(p,delim,fn)
    local i1,i2 = fn(p,delim)
    if not i1 or i1 == -1 then
        return p,'',''
    else
        if not i2 then i2 = i1 end
        return sub(p,1,i1-1),sub(p,i1,i2),sub(p,i2+1)
    end
end

--- partition the string using first occurance of a delimiter
-- @param self the string
-- @param ch delimiter
-- @return part before ch
-- @return ch
-- @return part after ch
function stringx.partition(self,ch)
    assert_string(1,self)
    assert_nonempty_string(2,ch)
    return _partition(self,ch,stringx.lfind)
end

--- partition the string p using last occurance of a delimiter
-- @param self the string
-- @param ch delimiter
-- @return part before ch
-- @return ch
-- @return part after ch
function stringx.rpartition(self,ch)
    assert_string(1,self)
    assert_nonempty_string(2,ch)
    return _partition(self,ch,stringx.rfind)
end

--- return the 'character' at the index.
-- @param self the string
-- @param idx an index (can be negative)
-- @return a substring of length 1 if successful, empty string otherwise.
function stringx.at(self,idx)
    assert_string(1,self)
    assert_arg(2,idx,'number')
    return sub(self,idx,idx)
end

--- return an interator over all lines in a string
-- @param self the string
-- @return an iterator
function stringx.lines (self)
    assert_string(1,self)
    local s = self
    if not s:find '\n$' then s = s..'\n' end
    return s:gmatch('([^\n]*)\n')
end

--- iniital word letters uppercase ('title case').
-- Here 'words' mean chunks of non-space characters.
-- @param self the string
-- @return a string with each word's first letter uppercase
function stringx.title(self)
    return (self:gsub('(%S)(%S*)',function(f,r)
        return f:upper()..r:lower()
    end))
end

stringx.capitalize = stringx.title

local elipsis = '...'
local n_elipsis = #elipsis

--- return a shorted version of a string.
-- @param self the string
-- @param sz the maxinum size allowed
-- @param tail true if we want to show the end of the string (head otherwise)
function stringx.shorten(self,sz,tail)
    if #self > sz then
        if sz < n_elipsis then return elipsis:sub(1,sz) end
        if tail then
            local i = #self - sz + 1 + n_elipsis
            return elipsis .. self:sub(i)
        else
            return self:sub(1,sz-n_elipsis) .. elipsis
        end
    end
    return self
end

function stringx.import(dont_overload)
    utils.import(stringx,string)
end

return stringx
     end)package.preload['pl.utils'] = (function (...)
      --- Generally useful routines.
-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
-- @module pl.utils
local format,gsub,byte = string.format,string.gsub,string.byte
local clock = os.clock
local stdout = io.stdout
local append = table.insert

local collisions = {}

local utils = {}

utils._VERSION = "1.1.0"

local lua51 = rawget(_G,'setfenv')

utils.lua51 = lua51
if not lua51 then -- Lua 5.2 compatibility
    unpack = table.unpack
    loadstring = load
end

utils.dir_separator = _G.package.config:sub(1,1)

--- end this program gracefully.
-- @param code The exit code or a message to be printed
-- @param ... extra arguments for message's format'
-- @see utils.fprintf
function utils.quit(code,...)
    if type(code) == 'string' then
        utils.fprintf(io.stderr,code,...)
        code = -1
    else
        utils.fprintf(io.stderr,...)
    end
    io.stderr:write('\n')
    os.exit(code)
end

--- print an arbitrary number of arguments using a format.
-- @param fmt The format (see string.format)
-- @param ... Extra arguments for format
function utils.printf(fmt,...)
    utils.assert_string(1,fmt)
    utils.fprintf(stdout,fmt,...)
end

--- write an arbitrary number of arguments to a file using a format.
-- @param f File handle to write to.
-- @param fmt The format (see string.format).
-- @param ... Extra arguments for format
function utils.fprintf(f,fmt,...)
    utils.assert_string(2,fmt)
    f:write(format(fmt,...))
end

local function import_symbol(T,k,v,libname)
    local key = rawget(T,k)
    -- warn about collisions!
    if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
        utils.printf("warning: '%s.%s' overrides existing symbol\n",libname,k)
    end
    rawset(T,k,v)
end

local function lookup_lib(T,t)
    for k,v in pairs(T) do
        if v == t then return k end
    end
    return '?'
end

local already_imported = {}

--- take a table and 'inject' it into the local namespace.
-- @param t The Table
-- @param T An optional destination table (defaults to callers environment)
function utils.import(t,T)
    T = T or _G
    t = t or utils
    if type(t) == 'string' then
        t = require (t)
    end
    local libname = lookup_lib(T,t)
    if already_imported[t] then return end
    already_imported[t] = libname
    for k,v in pairs(t) do
        import_symbol(T,k,v,libname)
    end
end

utils.patterns = {
    FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*',
    INTEGER = '[+%-%d]%d*',
    IDEN = '[%a_][%w_]*',
    FILE = '[%a%.\\][:%][%w%._%-\\]*'
}

--- escape any 'magic' characters in a string
-- @param s The input string
function utils.escape(s)
    utils.assert_string(1,s)
    return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
end

--- return either of two values, depending on a condition.
-- @param cond A condition
-- @param value1 Value returned if cond is true
-- @param value2 Value returned if cond is false (can be optional)
function utils.choose(cond,value1,value2)
    if cond then return value1
    else return value2
    end
end

local raise

--- return the contents of a file as a string
-- @param filename The file path
-- @param is_bin open in binary mode
-- @return file contents
function utils.readfile(filename,is_bin)
    local mode = is_bin and 'b' or ''
    utils.assert_string(1,filename)
    local f,err = io.open(filename,'r'..mode)
    if not f then return utils.raise (err) end
    local res,err = f:read('*a')
    f:close()
    if not res then return raise (err) end
    return res
end

--- write a string to a file
-- @param filename The file path
-- @param str The string
-- @return true or nil
-- @return error message
-- @raise error if filename or str aren't strings
function utils.writefile(filename,str)
    utils.assert_string(1,filename)
    utils.assert_string(2,str)
    local f,err = io.open(filename,'w')
    if not f then return raise(err) end
    f:write(str)
    f:close()
    return true
end

--- return the contents of a file as a list of lines
-- @param filename The file path
-- @return file contents as a table
-- @raise errror if filename is not a string
function utils.readlines(filename)
    utils.assert_string(1,filename)
    local f,err = io.open(filename,'r')
    if not f then return raise(err) end
    local res = {}
    for line in f:lines() do
        append(res,line)
    end
    f:close()
    return res
end

--- split a string into a list of strings separated by a delimiter.
-- @param s The input string
-- @param re A Lua string pattern; defaults to '%s+'
-- @param plain don't use Lua patterns
-- @param n optional maximum number of splits
-- @return a list-like table
-- @raise error if s is not a string
function utils.split(s,re,plain,n)
    utils.assert_string(1,s)
    local find,sub,append = string.find, string.sub, table.insert
    local i1,ls = 1,{}
    if not re then re = '%s+' end
    if re == '' then return {s} end
    while true do
        local i2,i3 = find(s,re,i1,plain)
        if not i2 then
            local last = sub(s,i1)
            if last ~= '' then append(ls,last) end
            if #ls == 1 and ls[1] == '' then
                return {}
            else
                return ls
            end
        end
        append(ls,sub(s,i1,i2-1))
        if n and #ls == n then
            ls[#ls] = sub(s,i1)
            return ls
        end
        i1 = i3+1
    end
end

--- split a string into a number of values.
-- @param s the string
-- @param re the delimiter, default space
-- @return n values
-- @usage first,next = splitv('jane:doe',':')
-- @see split
function utils.splitv (s,re)
    return unpack(utils.split(s,re))
end

--- convert an array of values to strings.
-- @param t a list-like table
-- @param temp buffer to use, otherwise allocate
-- @param tostr custom tostring function, called with (value,index).
-- Otherwise use `tostring`
-- @return the converted buffer
function utils.array_tostring (t,temp,tostr)
    temp, tostr = temp or {}, tostr or tostring
    for i = 1,#t do
        temp[i] = tostr(t[i],i)
    end
    return temp
end

local lua51_load = load

if utils.lua51 then -- define Lua 5.2 style load()
    function utils.load(str,src,mode,env)
        local chunk,err
        if type(str) == 'string' then
            chunk,err = loadstring(str,src)
        else
            chunk,err = lua51_load(str,src)
        end
        if chunk and env then setfenv(chunk,env) end
        return chunk,err
    end
else
    utils.load = load
    -- setfenv/getfenv replacements for Lua 5.2
    -- by Sergey Rozhenko
    -- http://lua-users.org/lists/lua-l/2010-06/msg00313.html
    -- Roberto Ierusalimschy notes that it is possible for getfenv to return nil
    -- in the case of a function with no globals:
    -- http://lua-users.org/lists/lua-l/2010-06/msg00315.html
    function setfenv(f, t)
        f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
        local name
        local up = 0
        repeat
            up = up + 1
            name = debug.getupvalue(f, up)
        until name == '_ENV' or name == nil
        if name then
            debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue
            debug.setupvalue(f, up, t)
        end
        if f ~= 0 then return f end
    end

    function getfenv(f)
        local f = f or 0
        f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
        local name, val
        local up = 0
        repeat
            up = up + 1
            name, val = debug.getupvalue(f, up)
        until name == '_ENV' or name == nil
        return val
    end
end


--- execute a shell command.
-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2
-- @param cmd a shell command
-- @return true if successful
-- @return actual return code
function utils.execute (cmd)
    local res1,res2,res2 = os.execute(cmd)
    if lua51 then
        return res1==0,res1
    else
        return res1,res2
    end
end

if lua51 then
    function table.pack (...)
        local n = select('#',...)
        return {n=n; ...}
    end
    local sep = package.config:sub(1,1)
    function package.searchpath (mod,path)
        mod = mod:gsub('%.',sep)
        for m in path:gmatch('[^;]+') do
            local nm = m:gsub('?',mod)
            local f = io.open(nm,'r')
            if f then f:close(); return nm end
        end
    end
end

if not table.pack then table.pack = _G.pack end
if not rawget(_G,"pack") then _G.pack = table.pack end

--- take an arbitrary set of arguments and make into a table.
-- This returns the table and the size; works fine for nil arguments
-- @param ... arguments
-- @return table
-- @return table size
-- @usage local t,n = utils.args(...)

--- 'memoize' a function (cache returned value for next call).
-- This is useful if you have a function which is relatively expensive,
-- but you don't know in advance what values will be required, so
-- building a table upfront is wasteful/impossible.
-- @param func a function of at least one argument
-- @return a function with at least one argument, which is used as the key.
function utils.memoize(func)
    return setmetatable({}, {
        __index = function(self, k, ...)
            local v = func(k,...)
            self[k] = v
            return v
        end,
        __call = function(self, k) return self[k] end
    })
end

--- is the object either a function or a callable object?.
-- @param obj Object to check.
function utils.is_callable (obj)
    return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call
end

--- is the object of the specified type?.
-- If the type is a string, then use type, otherwise compare with metatable
-- @param obj An object to check
-- @param tp String of what type it should be
function utils.is_type (obj,tp)
    if type(tp) == 'string' then return type(obj) == tp end
    local mt = getmetatable(obj)
    return tp == mt
end

local fileMT = getmetatable(io.stdout)

--- a string representation of a type.
-- For tables with metatables, we assume that the metatable has a `_name`
-- field. Knows about Lua file objects.
-- @param obj an object
-- @return a string like 'number', 'table' or 'List'
function utils.type (obj)
    local t = type(obj)
    if t == 'table' or t == 'userdata' then
        local mt = getmetatable(obj)
        if mt == fileMT then
            return 'file'
        else
            return mt._name or "unknown "..t
        end
    else
        return t
    end
end

--- is this number an integer?
-- @param x a number
-- @raise error if x is not a number
function utils.is_integer (x)
    return math.ceil(x)==x
end

utils.stdmt = {
    List = {_name='List'}, Map = {_name='Map'},
    Set = {_name='Set'}, MultiMap = {_name='MultiMap'}
}

local _function_factories = {}

--- associate a function factory with a type.
-- A function factory takes an object of the given type and
-- returns a function for evaluating it
-- @param mt metatable
-- @param fun a callable that returns a function
function utils.add_function_factory (mt,fun)
    _function_factories[mt] = fun
end

local function _string_lambda(f)
    local raise = utils.raise
    if f:find '^|' or f:find '_' then
        local args,body = f:match '|([^|]*)|(.+)'
        if f:find '_' then
            args = '_'
            body = f
        else
            if not args then return raise 'bad string lambda' end
        end
        local fstr = 'return function('..args..') return '..body..' end'
        local fn,err = loadstring(fstr)
        if not fn then return raise(err) end
        fn = fn()
        return fn
    else return raise 'not a string lambda'
    end
end

--- an anonymous function as a string. This string is either of the form
-- '|args| expression' or is a function of one argument, '_'
-- @param lf function as a string
-- @return a function
-- @usage string_lambda '|x|x+1' (2) == 3
-- @usage string_lambda '_+1 (2) == 3
-- @function utils.string_lambda
utils.string_lambda = utils.memoize(_string_lambda)

local ops

--- process a function argument.
-- This is used throughout Penlight and defines what is meant by a function:
-- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
-- such as '>' or '#'. If a function factory has been registered for the type, it will
-- be called to get the function.
-- @param idx argument index
-- @param f a function, operator string, or callable object
-- @param msg optional error message
-- @return a callable
-- @raise if idx is not a number or if f is not callable
-- @see utils.is_callable
function utils.function_arg (idx,f,msg)
    utils.assert_arg(1,idx,'number')
    local tp = type(f)
    if tp == 'function' then return f end  -- no worries!
    -- ok, a string can correspond to an operator (like '==')
    if tp == 'string' then
        if not ops then ops = require 'pl.operator'.optable end
        local fn = ops[f]
        if fn then return fn end
        local fn, err = utils.string_lambda(f)
        if not fn then error(err..': '..f) end
        return fn
    elseif tp == 'table' or tp == 'userdata' then
        local mt = getmetatable(f)
        if not mt then error('not a callable object',2) end
        local ff = _function_factories[mt]
        if not ff then
            if not mt.__call then error('not a callable object',2) end
            return f
        else
            return ff(f) -- we have a function factory for this type!
        end
    end
    if not msg then msg = " must be callable" end
    if idx > 0 then
        error("argument "..idx..": "..msg,2)
    else
        error(msg,2)
    end
end

--- bind the first argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(p,x)
-- @raise same as @{function_arg}
-- @see pl.func.curry
function utils.bind1 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(...) return fn(p,...) end
end

--- bind the second argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(x,p)
-- @raise same as @{function_arg}
function utils.bind2 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(x,...) return fn(x,p,...) end
end


--- assert that the given argument is in fact of the correct type.
-- @param n argument index
-- @param val the value
-- @param tp the type
-- @param verify an optional verfication function
-- @param msg an optional custom message
-- @param lev optional stack position for trace, default 2
-- @raise if the argument n is not the correct type
-- @usage assert_arg(1,t,'table')
-- @usage assert_arg(n,val,'string',path.isdir,'not a directory')
function utils.assert_arg (n,val,tp,verify,msg,lev)
    if type(val) ~= tp then
        error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
    end
    if verify and not verify(val) then
        error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
    end
end

--- assert the common case that the argument is a string.
-- @param n argument index
-- @param val a value that must be a string
-- @raise val must be a string
function utils.assert_string (n,val)
    utils.assert_arg(n,val,'string',nil,nil,3)
end

local err_mode = 'default'

--- control the error strategy used by Penlight.
-- Controls how <code>utils.raise</code> works; the default is for it
-- to return nil and the error string, but if the mode is 'error' then
-- it will throw an error. If mode is 'quit' it will immediately terminate
-- the program.
-- @param mode - either 'default', 'quit'  or 'error'
-- @see utils.raise
function utils.on_error (mode)
    if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
      err_mode = mode
    else
      -- fail loudly
      if err_mode == 'default' then err_mode = 'error' end
      utils.raise("Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'")
    end
end

--- used by Penlight functions to return errors.  Its global behaviour is controlled
-- by <code>utils.on_error</code>
-- @param err the error string.
-- @see utils.on_error
function utils.raise (err)
    if err_mode == 'default' then return nil,err
    elseif err_mode == 'quit' then utils.quit(err)
    else error(err,2)
    end
end

raise = utils.raise

--- load a code string or bytecode chunk.
-- @param code Lua code as a string or bytecode
-- @param name for source errors
-- @param mode kind of chunk, 't' for text, 'b' for bytecode, 'bt' for all (default)
-- @param env  the environment for the new chunk (default nil)
-- @return compiled chunk
-- @return error message (chunk is nil)
-- @function utils.load


--- Lua 5.2 Compatible Functions
-- @section lua52

--- pack an argument list into a table.
-- @param ... any arguments
-- @return a table with field n set to the length
-- @return the length
-- @function table.pack

------
-- return the full path where a Lua module name would be matched.
-- @param mod module name, possibly dotted
-- @param path a path in the same form as package.path or package.cpath
-- @see path.package_path
-- @function package.searchpath

return utils


     end)package.preload['pl.lexer'] = (function (...)
      --- Lexical scanner for creating a sequence of tokens from text.
-- `lexer.scan(s)` returns an iterator over all tokens found in the
-- string `s`. This iterator returns two values, a token type string
-- (such as 'string' for quoted string, 'iden' for identifier) and the value of the
-- token.
--
-- Versions specialized for Lua and C are available; these also handle block comments
-- and classify keywords as 'keyword' tokens. For example:
--
--    > s = 'for i=1,n do'
--    > for t,v in lexer.lua(s)  do print(t,v) end
--    keyword for
--    iden    i
--    =       =
--    number  1
--    ,       ,
--    iden    n
--    keyword do
--
-- See the Guide for further @{06-data.md.Lexical_Scanning|discussion}
-- @module pl.lexer

local yield,wrap = coroutine.yield,coroutine.wrap
local strfind = string.find
local strsub = string.sub
local append = table.insert

local function assert_arg(idx,val,tp)
    if type(val) ~= tp then
        error("argument "..idx.." must be "..tp, 2)
    end
end

local lexer = {}

local NUMBER1 = '^[%+%-]?%d+%.?%d*[eE][%+%-]?%d+'
local NUMBER2 = '^[%+%-]?%d+%.?%d*'
local NUMBER3 = '^0x[%da-fA-F]+'
local NUMBER4 = '^%d+%.?%d*[eE][%+%-]?%d+'
local NUMBER5 = '^%d+%.?%d*'
local IDEN = '^[%a_][%w_]*'
local WSPACE = '^%s+'
local STRING0 = [[^(['\"]).-\\%1]]
local STRING1 = [[^(['\"]).-[^\]%1]]
local STRING3 = "^((['\"])%2)" -- empty string
local PREPRO = '^#.-[^\\]\n'

local plain_matches,lua_matches,cpp_matches,lua_keyword,cpp_keyword

local function tdump(tok)
    return yield(tok,tok)
end

local function ndump(tok,options)
    if options and options.number then
        tok = tonumber(tok)
    end
    return yield("number",tok)
end

-- regular strings, single or double quotes; usually we want them
-- without the quotes
local function sdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield("string",tok)
end

-- long Lua strings need extra work to get rid of the quotes
local function sdump_l(tok,options)
    if options and options.string then
        tok = tok:sub(3,-3)
    end
    return yield("string",tok)
end

local function chdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield("char",tok)
end

local function cdump(tok)
    return yield('comment',tok)
end

local function wsdump (tok)
    return yield("space",tok)
end

local function pdump (tok)
    return yield('prepro',tok)
end

local function plain_vdump(tok)
    return yield("iden",tok)
end

local function lua_vdump(tok)
    if lua_keyword[tok] then
        return yield("keyword",tok)
    else
        return yield("iden",tok)
    end
end

local function cpp_vdump(tok)
    if cpp_keyword[tok] then
        return yield("keyword",tok)
    else
        return yield("iden",tok)
    end
end

--- create a plain token iterator from a string or file-like object.
-- @param s the string
-- @param matches an optional match table (set of pattern-action pairs)
-- @param filter a table of token types to exclude, by default {space=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.scan (s,matches,filter,options)
    --assert_arg(1,s,'string')
    local file = type(s) ~= 'string' and s
    filter = filter or {space=true}
    options = options or {number=true,string=true}
    if filter then
        if filter.space then filter[wsdump] = true end
        if filter.comments then
            filter[cdump] = true
        end
    end
    if not matches then
        if not plain_matches then
            plain_matches = {
                {WSPACE,wsdump},
                {NUMBER3,ndump},
                {IDEN,plain_vdump},
                {NUMBER1,ndump},
                {NUMBER2,ndump},
                {STRING3,sdump},
                {STRING0,sdump},
                {STRING1,sdump},
                {'^.',tdump}
            }
        end
        matches = plain_matches
    end
    local function lex ()
        local i1,i2,idx,res1,res2,tok,pat,fun,capt
        local line = 1
        if file then s = file:read()..'\n' end
        local sz = #s
        local idx = 1
        --print('sz',sz)
        while true do
            for _,m in ipairs(matches) do
                pat = m[1]
                fun = m[2]
                i1,i2 = strfind(s,pat,idx)
                if i1 then
                    tok = strsub(s,i1,i2)
                    idx = i2 + 1
                    if not (filter and filter[fun]) then
                        lexer.finished = idx > sz
                        res1,res2 = fun(tok,options)
                    end
                    if res1 then
                        local tp = type(res1)
                        -- insert a token list
                        if tp=='table' then
                            yield('','')
                            for _,t in ipairs(res1) do
                                yield(t[1],t[2])
                            end
                        elseif tp == 'string' then -- or search up to some special pattern
                            i1,i2 = strfind(s,res1,idx)
                            if i1 then
                                tok = strsub(s,i1,i2)
                                idx = i2 + 1
                                yield('',tok)
                            else
                                yield('','')
                                idx = sz + 1
                            end
                            --if idx > sz then return end
                        else
                            yield(line,idx)
                        end
                    end
                    if idx > sz then
                        if file then
                            --repeat -- next non-empty line
                                line = line + 1
                                s = file:read()
                                if not s then return end
                            --until not s:match '^%s*$'
                            s = s .. '\n'
                            idx ,sz = 1,#s
                            break
                        else
                            return
                        end
                    else break end
                end
            end
        end
    end
    return wrap(lex)
end

local function isstring (s)
    return type(s) == 'string'
end

--- insert tokens into a stream.
-- @param tok a token stream
-- @param a1 a string is the type, a table is a token list and
-- a function is assumed to be a token-like iterator (returns type & value)
-- @param a2 a string is the value
function lexer.insert (tok,a1,a2)
    if not a1 then return end
    local ts
    if isstring(a1) and isstring(a2) then
        ts = {{a1,a2}}
    elseif type(a1) == 'function' then
        ts = {}
        for t,v in a1() do
            append(ts,{t,v})
        end
    else
        ts = a1
    end
    tok(ts)
end

--- get everything in a stream upto a newline.
-- @param tok a token stream
-- @return a string
function lexer.getline (tok)
    local t,v = tok('.-\n')
    return v
end

--- get current line number. <br>
-- Only available if the input source is a file-like object.
-- @param tok a token stream
-- @return the line number and current column
function lexer.lineno (tok)
    return tok(0)
end

--- get the rest of the stream.
-- @param tok a token stream
-- @return a string
function lexer.getrest (tok)
    local t,v = tok('.+')
    return v
end

--- get the Lua keywords as a set-like table.
-- So <code>res["and"]</code> etc would be <code>true</code>.
-- @return a table
function lexer.get_keywords ()
    if not lua_keyword then
        lua_keyword = {
            ["and"] = true, ["break"] = true,  ["do"] = true,
            ["else"] = true, ["elseif"] = true, ["end"] = true,
            ["false"] = true, ["for"] = true, ["function"] = true,
            ["if"] = true, ["in"] = true,  ["local"] = true, ["nil"] = true,
            ["not"] = true, ["or"] = true, ["repeat"] = true,
            ["return"] = true, ["then"] = true, ["true"] = true,
            ["until"] = true,  ["while"] = true
        }
    end
    return lua_keyword
end


--- create a Lua token iterator from a string or file-like object.
-- Will return the token type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.lua(s,filter,options)
    filter = filter or {space=true,comments=true}
    lexer.get_keywords()
    if not lua_matches then
        lua_matches = {
            {WSPACE,wsdump},
            {NUMBER3,ndump},
            {IDEN,lua_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING0,sdump},
            {STRING1,sdump},
            {'^%-%-%[%[.-%]%]',cdump},
            {'^%-%-.-\n',cdump},
            {'^%[%[.-%]%]',sdump_l},
            {'^==',tdump},
            {'^~=',tdump},
            {'^<=',tdump},
            {'^>=',tdump},
            {'^%.%.%.',tdump},
            {'^%.%.',tdump},
            {'^.',tdump}
        }
    end
    return lexer.scan(s,lua_matches,filter,options)
end

--- create a C/C++ token iterator from a string or file-like object.
-- Will return the token type type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.cpp(s,filter,options)
    filter = filter or {comments=true}
    if not cpp_keyword then
        cpp_keyword = {
            ["class"] = true, ["break"] = true,  ["do"] = true, ["sizeof"] = true,
            ["else"] = true, ["continue"] = true, ["struct"] = true,
            ["false"] = true, ["for"] = true, ["public"] = true, ["void"] = true,
            ["private"] = true, ["protected"] = true, ["goto"] = true,
            ["if"] = true, ["static"] = true,  ["const"] = true, ["typedef"] = true,
            ["enum"] = true, ["char"] = true, ["int"] = true, ["bool"] = true,
            ["long"] = true, ["float"] = true, ["true"] = true, ["delete"] = true,
            ["double"] = true,  ["while"] = true, ["new"] = true,
            ["namespace"] = true, ["try"] = true, ["catch"] = true,
            ["switch"] = true, ["case"] = true, ["extern"] = true,
            ["return"] = true,["default"] = true,['unsigned']  = true,['signed'] = true,
            ["union"] =  true, ["volatile"] = true, ["register"] = true,["short"] = true,
        }
    end
    if not cpp_matches then
        cpp_matches = {
            {WSPACE,wsdump},
            {PREPRO,pdump},
            {NUMBER3,ndump},
            {IDEN,cpp_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING1,chdump},
            {'^//.-\n',cdump},
            {'^/%*.-%*/',cdump},
            {'^==',tdump},
            {'^!=',tdump},
            {'^<=',tdump},
            {'^>=',tdump},
            {'^->',tdump},
            {'^&&',tdump},
            {'^||',tdump},
            {'^%+%+',tdump},
            {'^%-%-',tdump},
            {'^%+=',tdump},
            {'^%-=',tdump},
            {'^%*=',tdump},
            {'^/=',tdump},
            {'^|=',tdump},
            {'^%^=',tdump},
            {'^::',tdump},
            {'^.',tdump}
        }
    end
    return lexer.scan(s,cpp_matches,filter,options)
end

--- get a list of parameters separated by a delimiter from a stream.
-- @param tok the token stream
-- @param endtoken end of list (default ')'). Can be '\n'
-- @param delim separator (default ',')
-- @return a list of token lists.
function lexer.get_separated_list(tok,endtoken,delim)
    endtoken = endtoken or ')'
    delim = delim or ','
    local parm_values = {}
    local level = 1 -- used to count ( and )
    local tl = {}
    local function tappend (tl,t,val)
        val = val or t
        append(tl,{t,val})
    end
    local is_end
    if endtoken == '\n' then
        is_end = function(t,val)
            return t == 'space' and val:find '\n'
        end
    else
        is_end = function (t)
            return t == endtoken
        end
    end
    local token,value
    while true do
        token,value=tok()
        if not token then return nil,'EOS' end -- end of stream is an error!
        if is_end(token,value) and level == 1 then
            append(parm_values,tl)
            break
        elseif token == '(' then
            level = level + 1
            tappend(tl,'(')
        elseif token == ')' then
            level = level - 1
            if level == 0 then -- finished with parm list
                append(parm_values,tl)
                break
            else
                tappend(tl,')')
            end
        elseif token == delim and level == 1 then
            append(parm_values,tl) -- a new parm
            tl = {}
        else
            tappend(tl,token,value)
        end
    end
    return parm_values,{token,value}
end

--- get the next non-space token from the stream.
-- @param tok the token stream.
function lexer.skipws (tok)
    local t,v = tok()
    while t == 'space' do
        t,v = tok()
    end
    return t,v
end

local skipws = lexer.skipws

--- get the next token, which must be of the expected type.
-- Throws an error if this type does not match!
-- @param tok the token stream
-- @param expected_type the token type
-- @param no_skip_ws whether we should skip whitespace
function lexer.expecting (tok,expected_type,no_skip_ws)
    assert_arg(1,tok,'function')
    assert_arg(2,expected_type,'string')
    local t,v
    if no_skip_ws then
        t,v = tok()
    else
        t,v = skipws(tok)
    end
    if t ~= expected_type then error ("expecting "..expected_type,2) end
    return v
end

return lexer
     end)package.preload['pl.path'] = (function (...)
      --- Path manipulation and file queries.
--
-- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
--
-- Dependencies: `pl.utils`, `lfs`
-- @module pl.path

-- imports and locals
local _G = _G
local sub = string.sub
local getenv = os.getenv
local tmpnam = os.tmpname
local attributes, currentdir, link_attrib
local package = package
local io = io
local append = table.insert
local ipairs = ipairs
local utils = require 'pl.utils'
local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

local attrib
local path = {}

local res,lfs = _G.pcall(_G.require,'lfs')
if res then
    attributes = lfs.attributes
    currentdir = lfs.currentdir
    link_attrib = lfs.symlinkattributes
else
    error("pl.path requires LuaFileSystem")
end

attrib = attributes
path.attrib = attrib
path.link_attrib = link_attrib
path.dir = lfs.dir
path.mkdir = lfs.mkdir
path.rmdir = lfs.rmdir
path.chdir = lfs.chdir

--- is this a directory?
-- @param P A file path
function path.isdir(P)
	assert_string(1,P)
    if P:match("\\$") then
        P = P:sub(1,-2)
    end
    return attrib(P,'mode') == 'directory'
end

--- is this a file?.
-- @param P A file path
function path.isfile(P)
	assert_string(1,P)
    return attrib(P,'mode') == 'file'
end

-- is this a symbolic link?
-- @param P A file path
function path.islink(P)
	assert_string(1,P)
    if link_attrib then
        return link_attrib(P,'mode')=='link'
    else
        return false
    end
end

--- return size of a file.
-- @param P A file path
function path.getsize(P)
	assert_string(1,P)
    return attrib(P,'size')
end

--- does a path exist?.
-- @param P A file path
-- @return the file path if it exists, nil otherwise
function path.exists(P)
	assert_string(1,P)
    return attrib(P,'mode') ~= nil and P
end

--- Return the time of last access as the number of seconds since the epoch.
-- @param P A file path
function path.getatime(P)
	assert_string(1,P)
    return attrib(P,'access')
end

--- Return the time of last modification
-- @param P A file path
function path.getmtime(P)
    return attrib(P,'modification')
end

---Return the system's ctime.
-- @param P A file path
function path.getctime(P)
	assert_string(1,P)
    return path.attrib(P,'change')
end


local function at(s,i)
    return sub(s,i,i)
end

path.is_windows = utils.dir_separator == '\\'

local other_sep
-- !constant sep is the directory separator for this platform.
if path.is_windows then
    path.sep = '\\'; other_sep = '/'
    path.dirsep = ';'
else
    path.sep = '/'
    path.dirsep = ':'
end
local sep,dirsep = path.sep,path.dirsep

--- are we running Windows?
-- @class field
-- @name path.is_windows

--- path separator for this platform.
-- @class field
-- @name path.sep

--- separator for PATH for this platform
-- @class field
-- @name path.dirsep

--- given a path, return the directory part and a file part.
-- if there's no directory part, the first value will be empty
-- @param P A file path
function path.splitpath(P)
    assert_string(1,P)
    local i = #P
    local ch = at(P,i)
    while i > 0 and ch ~= sep and ch ~= other_sep do
        i = i - 1
        ch = at(P,i)
    end
    if i == 0 then
        return '',P
    else
        return sub(P,1,i-1), sub(P,i+1)
    end
end

--- return an absolute path.
-- @param P A file path
-- @param pwd optional start path to use (default is current dir)
function path.abspath(P,pwd)
    assert_string(1,P)
	if pwd then assert_string(2,pwd) end
    local use_pwd = pwd ~= nil
    if not use_pwd and not currentdir then return P end
    P = P:gsub('[\\/]$','')
    pwd = pwd or currentdir()
    if not path.isabs(P) then
        P = path.join(pwd,P)
    elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
        P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
    end
    return path.normpath(P)
end

--- given a path, return the root part and the extension part.
-- if there's no extension part, the second value will be empty
-- @param P A file path
function path.splitext(P)
    assert_string(1,P)
    local i = #P
    local ch = at(P,i)
    while i > 0 and ch ~= '.' do
        if ch == sep or ch == other_sep then
            return P,''
        end
        i = i - 1
        ch = at(P,i)
    end
    if i == 0 then
        return P,''
    else
        return sub(P,1,i-1),sub(P,i)
    end
end

--- return the directory part of a path
-- @param P A file path
function path.dirname(P)
    assert_string(1,P)
    local p1,p2 = path.splitpath(P)
    return p1
end

--- return the file part of a path
-- @param P A file path
function path.basename(P)
    assert_string(1,P)
    local p1,p2 = path.splitpath(P)
    return p2
end

--- get the extension part of a path.
-- @param P A file path
function path.extension(P)
    assert_string(1,P)
    local p1,p2 = path.splitext(P)
    return p2
end

--- is this an absolute path?.
-- @param P A file path
function path.isabs(P)
    assert_string(1,P)
    if path.is_windows then
        return at(P,1) == '/' or at(P,1)=='\\' or at(P,2)==':'
    else
        return at(P,1) == '/'
    end
end

--- return the path resulting from combining the individual paths.
-- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
-- empty elements (except the last) will be ignored.
-- @param p1 A file path
-- @param p2 A file path
-- @param ... more file paths
function path.join(p1,p2,...)
    assert_string(1,p1)
    assert_string(2,p2)
    if select('#',...) > 0 then
        local p = path.join(p1,p2)
        local args = {...}
        for i = 1,#args do
            assert_string(i,args[i])
            p = path.join(p,args[i])
        end
        return p
    end
    if path.isabs(p2) then return p2 end
    local endc = at(p1,#p1)
    if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
        p1 = p1..path.sep
    end
    return p1..p2
end

--- normalize the case of a pathname. On Unix, this returns the path unchanged;
--  for Windows, it converts the path to lowercase, and it also converts forward slashes
-- to backward slashes.
-- @param P A file path
function path.normcase(P)
    assert_string(1,P)
    if path.is_windows then
        return (P:lower():gsub('/','\\'))
    else
        return P
    end
end

local np_gen1,np_gen2 = '[^SEP]+SEP%.%.SEP?','SEP+%.?SEP'
local np_pat1, np_pat2

--- normalize a path name.
--  A//B, A/./B and A/foo/../B all become A/B.
-- @param P a file path
function path.normpath(P)
    assert_string(1,P)
    if path.is_windows then
        if P:match '^\\\\' then -- UNC
            return '\\\\'..path.normpath(P:sub(3))
        end
        P = P:gsub('/','\\')
    end
    if not np_pat1 then
        np_pat1 = np_gen1:gsub('SEP',sep)
        np_pat2 = np_gen2:gsub('SEP',sep)
    end
    local k
    repeat -- /./ -> /
        P,k = P:gsub(np_pat2,sep)
    until k == 0
    repeat -- A/../ -> (empty)
        P,k = P:gsub(np_pat1,'')
    until k == 0
    if P == '' then P = '.' end
    return P
end

local function ATS (P)
    if at(P,#P) ~= path.sep then
        P = P..path.sep
    end
    return path.normcase(P)
end

--- relative path from current directory or optional start point
-- @param P a path
-- @param start optional start point (default current directory)
function path.relpath (P,start)
    assert_string(1,P)
	if start then assert_string(2,start) end
    local split,normcase,min,append = utils.split, path.normcase, math.min, table.insert
    P = normcase(path.abspath(P,start))
    start = start or currentdir()
    start = normcase(start)
    local startl, Pl = split(start,sep), split(P,sep)
    local n = min(#startl,#Pl)
    local k = n+1 -- default value if this loop doesn't bail out!
    for i = 1,n do
        if startl[i] ~= Pl[i] then
            k = i
            break
        end
    end
    local rell = {}
    for i = 1, #startl-k+1 do rell[i] = '..' end
    if k <= #Pl then
        for i = k,#Pl do append(rell,Pl[i]) end
    end
    return table.concat(rell,sep)
end


--- Replace a starting '~' with the user's home directory.
-- In windows, if HOME isn't set, then USERPROFILE is used in preference to
-- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
-- @param P A file path
function path.expanduser(P)
    assert_string(1,P)
    if at(P,1) == '~' then
        local home = getenv('HOME')
        if not home then -- has to be Windows
            home = getenv 'USERPROFILE' or (getenv 'HOMEDRIVE' .. getenv 'HOMEPATH')
        end
        return home..sub(P,2)
    else
        return P
    end
end


---Return a suitable full path to a new temporary file name.
-- unlike os.tmpnam(), it always gives you a writeable path (uses %TMP% on Windows)
function path.tmpname ()
    local res = tmpnam()
    if path.is_windows then res = getenv('TMP')..res end
    return res
end

--- return the largest common prefix path of two paths.
-- @param path1 a file path
-- @param path2 a file path
function path.common_prefix (path1,path2)
    assert_string(1,path1)
    assert_string(2,path2)
    path1, path2 = path.normcase(path1), path.normcase(path2)
    -- get them in order!
    if #path1 > #path2 then path2,path1 = path1,path2 end
    for i = 1,#path1 do
        local c1 = at(path1,i)
        if c1 ~= at(path2,i) then
            local cp = path1:sub(1,i-1)
            if at(path1,i-1) ~= sep then
                cp = path.dirname(cp)
            end
            return cp
        end
    end
    if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
    return path1
    --return ''
end


--- return the full path where a particular Lua module would be found.
-- Both package.path and package.cpath is searched, so the result may
-- either be a Lua file or a shared libarary.
-- @param mod name of the module
-- @return on success: path of module, lua or binary
-- @return on error: nil,error string
function path.package_path(mod)
    assert_string(1,mod)
    local res
    mod = mod:gsub('%.',sep)
    res = package.searchpath(mod,package.path)
    if res then return res,true end
    res = package.searchpath(mod,package.cpath)
    if res then return res,false end
    return raise 'cannot find module on path'
end


---- finis -----
return path
     end)package.preload['pl.class'] = (function (...)
      --- Provides a reuseable and convenient framework for creating classes in Lua.
-- Two possible notations:
--
--    B = class(A)
--    class.B(A)
--
-- The latter form creates a named class.
--
-- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}
-- @module pl.class

local error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =
    _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type
-- this trickery is necessary to prevent the inheritance of 'super' and
-- the resulting recursive call problems.
local function call_ctor (c,obj,...)
    -- nice alias for the base class ctor
    local base = rawget(c,'_base')
    if base then
        local parent_ctor = rawget(base,'_init')
        if parent_ctor then
            obj.super = function(obj,...)
                call_ctor(base,obj,...)
            end
        end
    end
    local res = c._init(obj,...)
    obj.super = nil
    return res
end

local function is_a(self,klass)
    local m = getmetatable(self)
    if not m then return false end --*can't be an object!
    while m do
        if m == klass then return true end
        m = rawget(m,'_base')
    end
    return false
end

local function class_of(klass,obj)
    if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end
    return klass.is_a(obj,klass)
end

local function _class_tostring (obj)
    local mt = obj._class
    local name = rawget(mt,'_name')
    setmetatable(obj,nil)
    local str = tostring(obj)
    setmetatable(obj,mt)
    if name then str = name ..str:gsub('table','') end
    return str
end

local function tupdate(td,ts)
    for k,v in pairs(ts) do
        td[k] = v
    end
end

local function _class(base,c_arg,c)
    c = c or {}     -- a new class instance, which is the metatable for all objects of this type
    -- the class will be the metatable for all its objects,
    -- and they will look up their methods in it.
    local mt = {}   -- a metatable for the class instance

    if type(base) == 'table' then
        -- our new class is a shallow copy of the base class!
        tupdate(c,base)
        c._base = base
        -- inherit the 'not found' handler, if present
        if rawget(c,'_handler') then mt.__index = c._handler end
    elseif base ~= nil then
        error("must derive from a table type",3)
    end

    c.__index = c
    setmetatable(c,mt)
    c._init = nil

    if base and rawget(base,'_class_init') then
        base._class_init(c,c_arg)
    end

    -- expose a ctor which can be called by <classname>(<args>)
    mt.__call = function(class_tbl,...)
        local obj = {}
        setmetatable(obj,c)

        if rawget(c,'_init') then -- explicit constructor
            local res = call_ctor(c,obj,...)
            if res then -- _if_ a ctor returns a value, it becomes the object...
                obj = res
                setmetatable(obj,c)
            end
        elseif base and rawget(base,'_init') then -- default constructor
            -- make sure that any stuff from the base class is initialized!
            call_ctor(base,obj,...)
        end

        if base and rawget(base,'_post_init') then
            base._post_init(obj)
        end

        if not rawget(c,'__tostring') then
            c.__tostring = _class_tostring
        end
        return obj
    end
    -- Call Class.catch to set a handler for methods/properties not found in the class!
    c.catch = function(handler)
        c._handler = handler
        mt.__index = handler
    end
    c.is_a = is_a
    c.class_of = class_of
    c._class = c

    return c
end

--- create a new class, derived from a given base class.
-- Supporting two class creation syntaxes:
-- either `Name = class(base)` or `class.Name(base)`
-- @function class
-- @param base optional base class
-- @param c_arg optional parameter to class ctor
-- @param c optional table to be used as class
local class
class = setmetatable({},{
    __call = function(fun,...)
        return _class(...)
    end,
    __index = function(tbl,key)
        if key == 'class' then
            io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')
            return class
        end
        local env = _G
        return function(...)
            local c = _class(...)
            c._name = key
            rawset(env,key,c)
            return c
        end
    end
})

class.properties = class()

function class.properties._class_init(klass)
    klass.__index = function(t,key)
        -- normal class lookup!
        local v = klass[key]
        if v then return v end
        -- is it a getter?
        v = rawget(klass,'get_'..key)
        if v then
            return v(t)
        end
        -- is it a field?
        return rawget(t,'_'..key)
    end
    klass.__newindex = function (t,key,value)
        -- if there's a setter, use that, otherwise directly set table
        local p = 'set_'..key
        local setter = klass[p]
        if setter then
            setter(t,value)
        else
            rawset(t,key,value)
        end
    end
end


return class

     end)package.preload['pl.tablex'] = (function (...)
      --- Extended operations on Lua tables.
--
-- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
--
-- Dependencies: `pl.utils`
-- @module pl.tablex
local utils = require ('pl.utils')
local getmetatable,setmetatable,require = getmetatable,setmetatable,require
local append,remove = table.insert,table.remove
local min,max = math.min,math.max
local pairs,type,unpack,next,select,tostring = pairs,type,unpack,next,select,tostring
local function_arg = utils.function_arg
local Set = utils.stdmt.Set
local List = utils.stdmt.List
local Map = utils.stdmt.Map
local assert_arg = utils.assert_arg

local tablex = {}

-- generally, functions that make copies of tables try to preserve the metatable.
-- However, when the source has no obvious type, then we attach appropriate metatables
-- like List, Map, etc to the result.
local function setmeta (res,tbl,def)
    local mt = getmetatable(tbl) or def
    return setmetatable(res, mt)
end

local function makelist (res)
    return setmetatable(res,List)
end

local function check_meta (val)
    if type(val) == 'table' then return true end
    return getmetatable(val)
end

local function complain (idx,msg)
    error(('argument %d is not %s'):format(idx,msg),3)
end

local function assert_arg_indexable (idx,val)
    local mt = check_meta(val)
    if mt == true then return end
    if not(mt and mt.__len and mt.__index) then
        complain(idx,"indexable")
    end
end

local function assert_arg_iterable (idx,val)
    local mt = check_meta(val)
    if mt == true then return end
    if not(mt and mt.__pairs) then
        complain(idx,"iterable")
    end
end

local function assert_arg_writeable (idx,val)
    local mt = check_meta(val)
    if mt == true then return end
    if not(mt and mt.__newindex) then
        complain(idx,"writeable")
    end
end


--- copy a table into another, in-place.
-- @param t1 destination table
-- @param t2 source (any iterable object)
-- @return first table
function tablex.update (t1,t2)
    assert_arg_writeable(1,t1)
    assert_arg_iterable(2,t2)
    for k,v in pairs(t2) do
        t1[k] = v
    end
    return t1
end

--- total number of elements in this table.
-- Note that this is distinct from `#t`, which is the number
-- of values in the array part; this value will always
-- be greater or equal. The difference gives the size of
-- the hash part, for practical purposes. Works for any
-- object with a __pairs metamethod.
-- @param t a table
-- @return the size
function tablex.size (t)
    assert_arg_iterable(1,t)
    local i = 0
    for k in pairs(t) do i = i + 1 end
    return i
end

--- make a shallow copy of a table
-- @param t an iterable source
-- @return new table
function tablex.copy (t)
    assert_arg_iterable(1,t)
    local res = {}
    for k,v in pairs(t) do
        res[k] = v
    end
    return res
end

--- make a deep copy of a table, recursively copying all the keys and fields.
-- This will also set the copied table's metatable to that of the original.
--  @param t A table
-- @return new table
function tablex.deepcopy(t)
    if type(t) ~= 'table' then return t end
    assert_arg_iterable(1,t)
    local mt = getmetatable(t)
    local res = {}
    for k,v in pairs(t) do
        if type(v) == 'table' then
            v = tablex.deepcopy(v)
        end
        res[k] = v
    end
    setmetatable(res,mt)
    return res
end

local abs, deepcompare = math.abs

--- compare two values.
-- if they are tables, then compare their keys and fields recursively.
-- @param t1 A value
-- @param t2 A value
-- @param ignore_mt if true, ignore __eq metamethod (default false)
-- @param eps if defined, then used for any number comparisons
-- @return true or false
function tablex.deepcompare(t1,t2,ignore_mt,eps)
    local ty1 = type(t1)
    local ty2 = type(t2)
    if ty1 ~= ty2 then return false end
    -- non-table types can be directly compared
    if ty1 ~= 'table' then
        if ty1 == 'number' and eps then return abs(t1-t2) < eps end
        return t1 == t2
    end
    -- as well as tables which have the metamethod __eq
    local mt = getmetatable(t1)
    if not ignore_mt and mt and mt.__eq then return t1 == t2 end
    for k1 in pairs(t1) do
        if t2[k1]==nil then return false end
    end
    for k2 in pairs(t2) do
        if t1[k2]==nil then return false end
    end
    for k1,v1 in pairs(t1) do
        local v2 = t2[k1]
        if not deepcompare(v1,v2,ignore_mt,eps) then return false end
    end

    return true
end

deepcompare = tablex.deepcompare

--- compare two arrays using a predicate.
-- @param t1 an array
-- @param t2 an array
-- @param cmp A comparison function
function tablex.compare (t1,t2,cmp)
    assert_arg_indexable(1,t1)
    assert_arg_indexable(2,t2)
    if #t1 ~= #t2 then return false end
    cmp = function_arg(3,cmp)
    for k = 1,#t1 do
        if not cmp(t1[k],t2[k]) then return false end
    end
    return true
end

--- compare two list-like tables using an optional predicate, without regard for element order.
-- @param t1 a list-like table
-- @param t2 a list-like table
-- @param cmp A comparison function (may be nil)
function tablex.compare_no_order (t1,t2,cmp)
    assert_arg_indexable(1,t1)
    assert_arg_indexable(2,t2)
    if cmp then cmp = function_arg(3,cmp) end
    if #t1 ~= #t2 then return false end
    local visited = {}
    for i = 1,#t1 do
        local val = t1[i]
        local gotcha
        for j = 1,#t2 do if not visited[j] then
            local match
            if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
            if match then
                gotcha = j
                break
            end
        end end
        if not gotcha then return false end
        visited[gotcha] = true
    end
    return true
end


--- return the index of a value in a list.
-- Like string.find, there is an optional index to start searching,
-- which can be negative.
-- @param t A list-like table (i.e. with numerical indices)
-- @param val A value
-- @param idx index to start; -1 means last element,etc (default 1)
-- @return index of value or nil if not found
-- @usage find({10,20,30},20) == 2
-- @usage find({'a','b','a','c'},'a',2) == 3
function tablex.find(t,val,idx)
    assert_arg_indexable(1,t)
    idx = idx or 1
    if idx < 0 then idx = #t + idx + 1 end
    for i = idx,#t do
        if t[i] == val then return i end
    end
    return nil
end

--- return the index of a value in a list, searching from the end.
-- Like string.find, there is an optional index to start searching,
-- which can be negative.
-- @param t A list-like table (i.e. with numerical indices)
-- @param val A value
-- @param idx index to start; -1 means last element,etc (default 1)
-- @return index of value or nil if not found
-- @usage rfind({10,10,10},10) == 3
function tablex.rfind(t,val,idx)
    assert_arg_indexable(1,t)
    idx = idx or #t
    if idx < 0 then idx = #t + idx + 1 end
    for i = idx,1,-1 do
        if t[i] == val then return i end
    end
    return nil
end


--- return the index (or key) of a value in a table using a comparison function.
-- @param t A table
-- @param cmp A comparison function
-- @param arg an optional second argument to the function
-- @return index of value, or nil if not found
-- @return value returned by comparison function
function tablex.find_if(t,cmp,arg)
    assert_arg_iterable(1,t)
    cmp = function_arg(2,cmp)
    for k,v in pairs(t) do
        local c = cmp(v,arg)
        if c then return k,c end
    end
    return nil
end

--- return a list of all values in a table indexed by another list.
-- @param tbl a table
-- @param idx an index table (a list of keys)
-- @return a list-like table
-- @usage index_by({10,20,30,40},{2,4}) == {20,40}
-- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
function tablex.index_by(tbl,idx)
    assert_arg_indexable(1,tbl)
    assert_arg_indexable(2,idx)
    local res = {}
    for i = 1,#idx do
        res[i] = tbl[idx[i]]
    end
    return setmeta(res,tbl,List)
end

--- apply a function to all values of a table.
-- This returns a table of the results.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param t A table
-- @param ... optional arguments
-- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
function tablex.map(fun,t,...)
    assert_arg_iterable(1,t)
    fun = function_arg(1,fun)
    local res = {}
    for k,v in pairs(t) do
        res[k] = fun(v,...)
    end
    return setmeta(res,t)
end

--- apply a function to all values of a list.
-- This returns a table of the results.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param t a table (applies to array part)
-- @param ... optional arguments
-- @return a list-like table
-- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
function tablex.imap(fun,t,...)
    assert_arg_indexable(1,t)
    fun = function_arg(1,fun)
    local res = {}
    for i = 1,#t do
        res[i] = fun(t[i],...) or false
    end
    return setmeta(res,t,List)
end

--- apply a named method to values from a table.
-- @param name the method name
-- @param t a list-like table
-- @param ... any extra arguments to the method
function tablex.map_named_method (name,t,...)
    utils.assert_string(1,name)
    assert_arg_indexable(2,t)
    local res = {}
    for i = 1,#t do
        local val = t[i]
        local fun = val[name]
        res[i] = fun(val,...)
    end
    return setmeta(res,t,List)
end


--- apply a function to all values of a table, in-place.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param t a table
-- @param ... extra arguments
function tablex.transform (fun,t,...)
    assert_arg_iterable(1,t)
    fun = function_arg(1,fun)
    for k,v in pairs(t) do
        t[v] = fun(v,...)
    end
end

--- generate a table of all numbers in a range
-- @param start  number
-- @param finish number
-- @param step optional increment (default 1 for increasing, -1 for decreasing)
function tablex.range (start,finish,step)
    if start == finish then return {start}
    elseif start > finish then return {}
    end
    local res = {}
    local k = 1
    if not step then
        if finish > start then step = finish > start and 1 or -1 end
    end
    for i=start,finish,step do res[k]=i; k=k+1 end
    return res
end

--- apply a function to values from two tables.
-- @param fun a function of at least two arguments
-- @param t1 a table
-- @param t2 a table
-- @param ... extra arguments
-- @return a table
-- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
function tablex.map2 (fun,t1,t2,...)
    assert_arg_iterable(1,t1)
    assert_arg_iterable(2,t2)
    fun = function_arg(1,fun)
    local res = {}
    for k,v in pairs(t1) do
        res[k] = fun(v,t2[k],...)
    end
    return setmeta(res,t1,List)
end

--- apply a function to values from two arrays.
-- The result will be the length of the shortest array.
-- @param fun a function of at least two arguments
-- @param t1 a list-like table
-- @param t2 a list-like table
-- @param ... extra arguments
-- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
function tablex.imap2 (fun,t1,t2,...)
    assert_arg_indexable(2,t1)
    assert_arg_indexable(3,t2)
    fun = function_arg(1,fun)
    local res,n = {},math.min(#t1,#t2)
    for i = 1,n do
        res[i] = fun(t1[i],t2[i],...)
    end
    return res
end

--- 'reduce' a list using a binary function.
-- @param fun a function of two arguments
-- @param t a list-like table
-- @return the result of the function
-- @usage reduce('+',{1,2,3,4}) == 10
function tablex.reduce (fun,t)
    assert_arg_indexable(2,t)
    fun = function_arg(1,fun)
    local n = #t
    local res = t[1]
    for i = 2,n do
        res = fun(res,t[i])
    end
    return res
end

--- apply a function to all elements of a table.
-- The arguments to the function will be the value,
-- the key and <i>finally</i> any extra arguments passed to this function.
-- Note that the Lua 5.0 function table.foreach passed the <i>key</i> first.
-- @param t a table
-- @param fun a function with at least one argument
-- @param ... extra arguments
function tablex.foreach(t,fun,...)
    assert_arg_iterable(1,t)
    fun = function_arg(2,fun)
    for k,v in pairs(t) do
        fun(v,k,...)
    end
end

--- apply a function to all elements of a list-like table in order.
-- The arguments to the function will be the value,
-- the index and <i>finally</i> any extra arguments passed to this function
-- @param t a table
-- @param fun a function with at least one argument
-- @param ... optional arguments
function tablex.foreachi(t,fun,...)
    assert_arg_indexable(1,t)
    fun = function_arg(2,fun)
    for i = 1,#t do
        fun(t[i],i,...)
    end
end


--- Apply a function to a number of tables.
-- A more general version of map
-- The result is a table containing the result of applying that function to the
-- ith value of each table. Length of output list is the minimum length of all the lists
-- @param fun a function of n arguments
-- @param ... n tables
-- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
-- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is	{100,200,300}
-- @param fun A function that takes as many arguments as there are tables
function tablex.mapn(fun,...)
    fun = function_arg(1,fun)
    local res = {}
    local lists = {...}
    local minn = 1e40
    for i = 1,#lists do
        minn = min(minn,#(lists[i]))
    end
    for i = 1,minn do
        local args,k = {},1
        for j = 1,#lists do
            args[k] = lists[j][i]
            k = k + 1
        end
        res[#res+1] = fun(unpack(args))
    end
    return res
end

--- call the function with the key and value pairs from a table.
-- The function can return a value and a key (note the order!). If both
-- are not nil, then this pair is inserted into the result. If only value is not nil, then
-- it is appended to the result.
-- @param fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
-- @param t A table
-- @param ... optional arguments
-- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
-- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
function tablex.pairmap(fun,t,...)
    assert_arg_iterable(1,t)
    fun = function_arg(1,fun)
    local res = {}
    for k,v in pairs(t) do
        local rv,rk = fun(k,v,...)
        if rk then
            res[rk] = rv
        else
            res[#res+1] = rv
        end
    end
    return res
end

local function keys_op(i,v) return i end

--- return all the keys of a table in arbitrary order.
--  @param t A table
function tablex.keys(t)
    assert_arg_iterable(1,t)
    return makelist(tablex.pairmap(keys_op,t))
end

local function values_op(i,v) return v end

--- return all the values of the table in arbitrary order
--  @param t A table
function tablex.values(t)
    assert_arg_iterable(1,t)
    return makelist(tablex.pairmap(values_op,t))
end

local function index_map_op (i,v) return i,v end

--- create an index map from a list-like table. The original values become keys,
-- and the associated values are the indices into the original list.
-- @param t a list-like table
-- @return a map-like table
function tablex.index_map (t)
    assert_arg_indexable(1,t)
    return setmetatable(tablex.pairmap(index_map_op,t),Map)
end

local function set_op(i,v) return true,v end

--- create a set from a list-like table. A set is a table where the original values
-- become keys, and the associated values are all true.
-- @param t a list-like table
-- @return a set (a map-like table)
function tablex.makeset (t)
    assert_arg_indexable(1,t)
    return setmetatable(tablex.pairmap(set_op,t),Set)
end


--- combine two tables, either as union or intersection. Corresponds to
-- set operations for sets () but more general. Not particularly
-- useful for list-like tables.
-- @param t1 a table
-- @param t2 a table
-- @param dup true for a union, false for an intersection.
-- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
-- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
-- @see tablex.index_map
function tablex.merge (t1,t2,dup)
    assert_arg_iterable(1,t1)
    assert_arg_iterable(2,t2)
    local res = {}
    for k,v in pairs(t1) do
        if dup or t2[k] then res[k] = v end
    end
    if dup then
      for k,v in pairs(t2) do
        res[k] = v
      end
    end
    return setmeta(res,t1,Map)
end

--- a new table which is the difference of two tables.
-- With sets (where the values are all true) this is set difference and
-- symmetric difference depending on the third parameter.
-- @param s1 a map-like table or set
-- @param s2 a map-like table or set
-- @param symm symmetric difference (default false)
-- @return a map-like table or set
function tablex.difference (s1,s2,symm)
    assert_arg_iterable(1,s1)
    assert_arg_iterable(2,s2)
    local res = {}
    for k,v in pairs(s1) do
        if not s2[k] then res[k] = v end
    end
    if symm then
        for k,v in pairs(s2) do
            if not s1[k] then res[k] = v end
        end
    end
    return setmeta(res,s1,Map)
end

--- A table where the key/values are the values and value counts of the table.
-- @param t a list-like table
-- @param cmp a function that defines equality (otherwise uses ==)
-- @return a map-like table
-- @see seq.count_map
function tablex.count_map (t,cmp)
    assert_arg_indexable(1,t)
    local res,mask = {},{}
    cmp = function_arg(2,cmp)
    local n = #t
    for i = 1,#t do
        local v = t[i]
        if not mask[v] then
            mask[v] = true
            -- check this value against all other values
            res[v] = 1  -- there's at least one instance
            for j = i+1,n do
                local w = t[j]
                if cmp and cmp(v,w) or v == w then
                    res[v] = res[v] + 1
                    mask[w] = true
                end
            end
        end
    end
    return setmetatable(res,Map)
end

--- filter a table's values using a predicate function
-- @param t a list-like table
-- @param pred a boolean function
-- @param arg optional argument to be passed as second argument of the predicate
function tablex.filter (t,pred,arg)
    assert_arg_indexable(1,t)
    pred = function_arg(2,pred)
    local res,k = {},1
    for i = 1,#t do
        local v = t[i]
        if pred(v,arg) then
            res[k] = v
            k = k + 1
        end
    end
    return setmeta(res,t,List)
end

--- return a table where each element is a table of the ith values of an arbitrary
-- number of tables. It is equivalent to a matrix transpose.
-- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
function tablex.zip(...)
    return tablex.mapn(function(...) return {...} end,...)
end

local _copy
function _copy (dest,src,idest,isrc,nsrc,clean_tail)
    idest = idest or 1
    isrc = isrc or 1
    local iend
    if not nsrc then
        nsrc = #src
        iend = #src
    else
        iend = isrc + min(nsrc-1,#src-isrc)
    end
    if dest == src then -- special case
        if idest > isrc and iend >= idest then -- overlapping ranges
            src = tablex.sub(src,isrc,nsrc)
            isrc = 1; iend = #src
        end
    end
    for i = isrc,iend do
        dest[idest] = src[i]
        idest = idest + 1
    end
    if clean_tail then
        tablex.clear(dest,idest)
    end
    return dest
end

--- copy an array into another one, resizing the destination if necessary. <br>
-- @param dest a list-like table
-- @param src a list-like table
-- @param idest where to start copying values from source (default 1)
-- @param isrc where to start copying values into destination (default 1)
-- @param nsrc number of elements to copy from source (default source size)
function tablex.icopy (dest,src,idest,isrc,nsrc)
    assert_arg_indexable(1,dest)
    assert_arg_indexable(2,src)
    return _copy(dest,src,idest,isrc,nsrc,true)
end

--- copy an array into another one. <br>
-- @param dest a list-like table
-- @param src a list-like table
-- @param idest where to start copying values from source (default 1)
-- @param isrc where to start copying values into destination (default 1)
-- @param nsrc number of elements to copy from source (default source size)
function tablex.move (dest,src,idest,isrc,nsrc)
    assert_arg_indexable(1,dest)
    assert_arg_indexable(2,src)
    return _copy(dest,src,idest,isrc,nsrc,false)
end

function tablex._normalize_slice(self,first,last)
  local sz = #self
  if not first then first=1 end
  if first<0 then first=sz+first+1 end
  -- make the range _inclusive_!
  if not last then last=sz end
  if last < 0 then last=sz+1+last end
  return first,last
end

--- Extract a range from a table, like  'string.sub'.
-- If first or last are negative then they are relative to the end of the list
-- eg. sub(t,-2) gives last 2 entries in a list, and
-- sub(t,-4,-2) gives from -4th to -2nd
-- @param t a list-like table
-- @param first An index
-- @param last An index
-- @return a new List
function tablex.sub(t,first,last)
    assert_arg_indexable(1,t)
    first,last = tablex._normalize_slice(t,first,last)
    local res={}
    for i=first,last do append(res,t[i]) end
    return setmeta(res,t,List)
end

--- set an array range to a value. If it's a function we use the result
-- of applying it to the indices.
-- @param t a list-like table
-- @param val a value
-- @param i1 start range (default 1)
-- @param i2 end range (default table size)
function tablex.set (t,val,i1,i2)
    assert_arg_indexable(1,t)
    i1,i2 = i1 or 1,i2 or #t
    if utils.is_callable(val) then
        for i = i1,i2 do
            t[i] = val(i)
        end
    else
        for i = i1,i2 do
            t[i] = val
        end
    end
end

--- create a new array of specified size with initial value.
-- @param n size
-- @param val initial value (can be nil, but don't expect # to work!)
-- @return the table
function tablex.new (n,val)
    local res = {}
    tablex.set(res,val,1,n)
    return res
end

--- clear out the contents of a table.
-- @param t a table
-- @param istart optional start position
function tablex.clear(t,istart)
    istart = istart or 1
    for i = istart,#t do remove(t) end
end

--- insert values into a table. <br>
-- insertvalues(t, [pos,] values) <br>
-- similar to table.insert but inserts values from given table "values",
-- not the object itself, into table "t" at position "pos".
function tablex.insertvalues(t, ...)
    assert_arg(1,t,'table')
    local pos, values
    if select('#', ...) == 1 then
        pos,values = #t+1, ...
    else
        pos,values = ...
    end
    if #values > 0 then
        for i=#t,pos,-1 do
            t[i+#values] = t[i]
        end
        local offset = 1 - pos
        for i=pos,pos+#values-1 do
            t[i] = values[i + offset]
        end
    end
    return t
end

--- remove a range of values from a table.
-- @param t a list-like table
-- @param i1 start index
-- @param i2 end index
-- @return the table
function tablex.removevalues (t,i1,i2)
    assert_arg(1,t,'table')
    i1,i2 = tablex._normalize_slice(t,i1,i2)
    for i = i1,i2 do
        remove(t,i1)
    end
    return t
end

local _find
_find = function (t,value,tables)
    for k,v in pairs(t) do
        if v == value then return k end
    end
    for k,v in pairs(t) do
        if not tables[v] and type(v) == 'table' then
            tables[v] = true
            local res = _find(v,value,tables)
            if res then
                res = tostring(res)
                if type(k) ~= 'string' then
                    return '['..k..']'..res
                else
                    return k..'.'..res
                end
            end
        end
    end
end

--- find a value in a table by recursive search.
-- @param t the table
-- @param value the value
-- @param exclude any tables to avoid searching
-- @usage search(_G,math.sin,{package.path}) == 'math.sin'
-- @return a fieldspec, e.g. 'a.b' or 'math.sin'
function tablex.search (t,value,exclude)
    assert_arg_iterable(1,t)
    local tables = {[t]=true}
    if exclude then
        for _,v in pairs(exclude) do tables[v] = true end
    end
    return _find(t,value,tables)
end

return tablex
     end)package.preload['pl.List'] = (function (...)
      --- Python-style list class.
--
-- **Please Note**: methods that change the list will return the list.
-- This is to allow for method chaining, but please note that `ls = ls:sort()`
-- does not mean that a new copy of the list is made. In-place (mutable) methods
-- are marked as returning 'the list' in this documentation.
--
-- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}
--
-- See <a href="http://www.python.org/doc/current/tut/tut.html">http://www.python.org/doc/current/tut/tut.html</a>, section 5.1
--
-- **Note**: The comments before some of the functions are from the Python docs
-- and contain Python code.
--
-- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
--
-- Dependencies: `pl.utils`, `pl.tablex`
-- @module pl.List
-- @pragma nostrip

local tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort
local setmetatable, getmetatable,type,tostring,assert,string,next = setmetatable,getmetatable,type,tostring,assert,string,next
local write = io.write
local tablex = require 'pl.tablex'
local filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
local tablex = tablex
local tsub = tablex.sub
local utils = require 'pl.utils'
local array_tostring,split,is_type,assert_arg,function_arg = utils.array_tostring,utils.split,utils.is_type,utils.assert_arg,utils.function_arg
local normalize_slice = tablex._normalize_slice

--[[
module ('pl.List',utils._module)
]]

local Multimap = utils.stdmt.MultiMap
-- metatable for our list objects
local List = utils.stdmt.List
List.__index = List
List._class = List

local iter

-- we give the metatable its own metatable so that we can call it like a function!
setmetatable(List,{
    __call = function (tbl,arg)
        return List.new(arg)
    end,
})

local function makelist (t,obj)
    local klass = List
    if obj then
        klass = getmetatable(obj)
    end
    return setmetatable(t,klass)
end

local function is_list(t)
    return getmetatable(t) == List
end

local function simple_table(t)
  return type(t) == 'table' and not is_list(t) and #t > 0
end

function List:_init (src)
    if src then
        for v in iter(src) do
            tinsert(self,v)
        end
    end
end

--- Create a new list. Can optionally pass a table;
-- passing another instance of List will cause a copy to be created
-- we pass anything which isn't a simple table to iterate() to work out
-- an appropriate iterator  @see List.iterate
-- @param t An optional list-like table
-- @return a new List
-- @usage ls = List();  ls = List {1,2,3,4}
function List.new(t)
    local ls
    if not simple_table(t) then
        ls = {}
        List._init(ls,t)
    else
        ls = t
    end
    makelist(ls)
    return ls
end

function List:clone()
    local ls = makelist({},self)
    List._init(ls,self)
    return ls
end

function List.default_map_with(T)
    return function(self,name)
       local f = T[name]
       if f then
          return function(self,...)
             return self:map(f,...)
          end
       else
          error("method not found: "..name,2)
       end
    end
end


---Add an item to the end of the list.
-- @param i An item
-- @return the list
function List:append(i)
  tinsert(self,i)
  return self
end

List.push = tinsert

--- Extend the list by appending all the items in the given list.
-- equivalent to 'a[len(a):] = L'.
-- @param L Another List
-- @return the list
function List:extend(L)
  assert_arg(1,L,'table')
  for i = 1,#L do tinsert(self,L[i]) end
  return self
end

--- Insert an item at a given position. i is the index of the
-- element before which to insert.
-- @param i index of element before whichh to insert
-- @param x A data item
-- @return the list
function List:insert(i, x)
  assert_arg(1,i,'number')
  tinsert(self,i,x)
  return self
end

--- Insert an item at the begining of the list.
-- @param x a data item
-- @return the list
function List:put (x)
    return self:insert(1,x)
end

--- Remove an element given its index.
-- (equivalent of Python's del s[i])
-- @param i the index
-- @return the list
function List:remove (i)
    assert_arg(1,i,'number')
    tremove(self,i)
    return self
end

--- Remove the first item from the list whose value is given.
-- (This is called 'remove' in Python; renamed to avoid confusion
-- with table.remove)
-- Return nil if there is no such item.
-- @param x A data value
-- @return the list
function List:remove_value(x)
    for i=1,#self do
        if self[i]==x then tremove(self,i) return self end
    end
    return self
 end

--- Remove the item at the given position in the list, and return it.
-- If no index is specified, a:pop() returns the last item in the list.
-- The item is also removed from the list.
-- @param i An index
-- @return the item
function List:pop(i)
    if not i then i = #self end
    assert_arg(1,i,'number')
    return tremove(self,i)
end

List.get = List.pop

--- Return the index in the list of the first item whose value is given.
-- Return nil if there is no such item.
-- @class function
-- @name List:index
-- @param x A data value
-- @param idx where to start search (default 1)
-- @return the index, or nil if not found.

local tfind = tablex.find
List.index = tfind

--- does this list contain the value?.
-- @param x A data value
-- @return true or false
function List:contains(x)
    return tfind(self,x) and true or false
end

--- Return the number of times value appears in the list.
-- @param x A data value
-- @return number of times x appears
function List:count(x)
    local cnt=0
    for i=1,#self do
        if self[i]==x then cnt=cnt+1 end
    end
    return cnt
end

--- Sort the items of the list, in place.
-- @param cmp an optional comparison function, default '<'
-- @return the list
function List:sort(cmp)
    if cmp then cmp = function_arg(1,cmp) end
    tsort(self,cmp)
    return self
end

--- return a sorted copy of this list.
-- @param cmp an optional comparison function, default '<'
-- @return a new list
function List:sorted(cmp)
    return List(self):sort(cmp)
end

--- Reverse the elements of the list, in place.
-- @return the list
function List:reverse()
    local t = self
    local n = #t
    local n2 = n/2
    for i = 1,n2 do
        local k = n-i+1
        t[i],t[k] = t[k],t[i]
    end
    return self
end

--- return the minimum and the maximum value of the list.
-- @return minimum value
-- @return maximum value
function List:minmax()
    local vmin,vmax = 1e70,-1e70
    for i = 1,#self do
        local v = self[i]
        if v < vmin then vmin = v end
        if v > vmax then vmax = v end
    end
    return vmin,vmax
end

--- Emulate list slicing.  like  'list[first:last]' in Python.
-- If first or last are negative then they are relative to the end of the list
-- eg. slice(-2) gives last 2 entries in a list, and
-- slice(-4,-2) gives from -4th to -2nd
-- @param first An index
-- @param last An index
-- @return a new List
function List:slice(first,last)
    return tsub(self,first,last)
end

--- empty the list.
-- @return the list
function List:clear()
    for i=1,#self do tremove(self) end
    return self
end

local eps = 1.0e-10

--- Emulate Python's range(x) function.
-- Include it in List table for tidiness
-- @param start A number
-- @param finish A number greater than start; if absent,
-- then start is 1 and finish is start
-- @param incr an optional increment (may be less than 1)
-- @return a List from start .. finish
-- @usage List.range(0,3) == List{0,1,2,3}
-- @usage List.range(4) = List{1,2,3,4}
-- @usage List.range(5,1,-1) == List{5,4,3,2,1}
function List.range(start,finish,incr)
  if not finish then
    finish = start
    start = 1
  end
  if incr then
    assert_arg(3,incr,'number')
    if not utils.is_integer(incr) then finish = finish + eps end
  else
    incr = 1
  end
  assert_arg(1,start,'number')
  assert_arg(2,finish,'number')
  local t = List.new()
  for i=start,finish,incr do tinsert(t,i) end
  return t
end

--- list:len() is the same as #list.
function List:len()
  return #self
end

-- Extended operations --

--- Remove a subrange of elements.
-- equivalent to 'del s[i1:i2]' in Python.
-- @param i1 start of range
-- @param i2 end of range
-- @return the list
function List:chop(i1,i2)
    return tremovevalues(self,i1,i2)
end

--- Insert a sublist into a list
-- equivalent to 's[idx:idx] = list' in Python
-- @param idx index
-- @param list list to insert
-- @return the list
-- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
function List:splice(idx,list)
    assert_arg(1,idx,'number')
    idx = idx - 1
    local i = 1
    for v in iter(list) do
        tinsert(self,i+idx,v)
        i = i + 1
    end
    return self
end

--- general slice assignment s[i1:i2] = seq.
-- @param i1  start index
-- @param i2  end index
-- @param seq a list
-- @return the list
function List:slice_assign(i1,i2,seq)
    assert_arg(1,i1,'number')
    assert_arg(1,i2,'number')
    i1,i2 = normalize_slice(self,i1,i2)
    if i2 >= i1 then self:chop(i1,i2) end
    self:splice(i1,seq)
    return self
end

--- concatenation operator.
-- @param L another List
-- @return a new list consisting of the list with the elements of the new list appended
function List:__concat(L)
    assert_arg(1,L,'table')
    local ls = self:clone()
    ls:extend(L)
    return ls
end

--- equality operator ==.  True iff all elements of two lists are equal.
-- @param L another List
-- @return true or false
function List:__eq(L)
    if #self ~= #L then return false end
    for i = 1,#self do
        if self[i] ~= L[i] then return false end
    end
    return true
end

--- join the elements of a list using a delimiter. <br>
-- This method uses tostring on all elements.
-- @param delim a delimiter string, can be empty.
-- @return a string
function List:join (delim)
    delim = delim or ''
    assert_arg(1,delim,'string')
    return concat(array_tostring(self),delim)
end

--- join a list of strings. <br>
-- Uses table.concat directly.
-- @class function
-- @name List:concat
-- @param delim a delimiter
-- @return a string
List.concat = concat

local function tostring_q(val)
    local s = tostring(val)
    if type(val) == 'string' then
        s = '"'..s..'"'
    end
    return s
end

--- how our list should be rendered as a string. Uses join().
-- @see List:join
function List:__tostring()
    return '{'..self:join(',',tostring_q)..'}'
end

--[[
-- NOTE: this works, but is unreliable. If you leave the loop before finishing,
-- then the iterator is not reset.
--- can iterate over a list directly.
-- @usage for v in ls do print(v) end
function List:__call()
    if not self.key then self.key = 1 end
    local value = self[self.key]
    self.key = self.key + 1
    if not value then self.key = nil end
    return value
end
--]]

--[[
function List.__call(t,v,i)
    i = (i or 0) + 1
    v = t[i]
    if v then return i, v end
end
--]]

local MethodIter = {}

function MethodIter:__index (name)
    return function(mm,...)
        return self.list:foreachm(name,...)
    end
end

--- call the function for each element of the list.
-- @param fun a function or callable object
-- @param ... optional values to pass to function
function List:foreach (fun,...)
    if fun==nil then
        return setmetatable({list=self},MethodIter)
    end
    fun = function_arg(1,fun)
    for i = 1,#self do
        fun(self[i],...)
    end
end

function List:foreachm (name,...)
    for i = 1,#self do
        local obj = self[i]
        local f = assert(obj[name],"method not found on object")
        f(obj,...)
    end
end

--- create a list of all elements which match a function.
-- @param fun a boolean function
-- @param arg optional argument to be passed as second argument of the predicate
-- @return a new filtered list.
function List:filter (fun,arg)
    return makelist(filter(self,fun,arg),self)
end

--- split a string using a delimiter.
-- @param s the string
-- @param delim the delimiter (default spaces)
-- @return a List of strings
-- @see pl.utils.split
function List.split (s,delim)
    assert_arg(1,s,'string')
    return makelist(split(s,delim))
end

local MethodMapper = {}

function MethodMapper:__index (name)
    return function(mm,...)
        return self.list:mapm(name,...)
    end
end

--- apply a function to all elements.
-- Any extra arguments will be passed to the function; if the function
-- is `nil` then `map` returns a mapper object that maps over a method
-- of the items
-- @param fun a function of at least one argument
-- @param ... arbitrary extra arguments.
-- @return a new list: {f(x) for x in self}
-- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
-- @usage List{'one','two'}:map():sub(1,2) == {'on','tw'}
-- @see pl.tablex.imap
function List:map (fun,...)
    if fun==nil then
        return setmetatable({list=self},MethodMapper)
    end
    return makelist(imap(fun,self,...),self)
end

--- apply a function to all elements, in-place.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param ... arbitrary extra arguments.
-- @return the list.
function List:transform (fun,...)
    transform(fun,self,...)
	return self
end

--- apply a function to elements of two lists.
-- Any extra arguments will be passed to the function
-- @param fun a function of at least two arguments
-- @param ls another list
-- @param ... arbitrary extra arguments.
-- @return a new list: {f(x,y) for x in self, for x in arg1}
-- @see pl.tablex.imap2
function List:map2 (fun,ls,...)
    return makelist(imap2(fun,self,ls,...),self)
end

--- apply a named method to all elements.
-- Any extra arguments will be passed to the method.
-- @param name name of method
-- @param ... extra arguments
-- @return a new list of the results
-- @see pl.seq.mapmethod
function List:mapm (name,...)
    local res = {}
    local t = self
    for i = 1,#t do
      local val = t[i]
      local fn = val[name]
      if not fn then error(type(val).." does not have method "..name,2) end
      res[i] = fn(val,...)
    end
    return makelist(res,self)
end

--- 'reduce' a list using a binary function.
-- @param fun a function of two arguments
-- @return result of the function
-- @see pl.tablex.reduce
function List:reduce (fun)
    return reduce(fun,self)
end

--- partition a list using a classifier function.
-- The function may return nil, but this will be converted to the string key '<nil>'.
-- @param fun a function of at least one argument
-- @param ... will also be passed to the function
-- @return a table where the keys are the returned values, and the values are Lists
-- of values where the function returned that key. It is given the type of Multimap.
-- @see pl.MultiMap
function List:partition (fun,...)
    fun = function_arg(1,fun)
    local res = {}
    for i = 1,#self do
        local val = self[i]
        local klass = fun(val,...)
        if klass == nil then klass = '<nil>' end
        if not res[klass] then res[klass] = List() end
        res[klass]:append(val)
    end
    return setmetatable(res,Multimap)
end

--- return an iterator over all values.
function List:iter ()
    return iter(self)
end

--- Create an iterator over a seqence.
-- This captures the Python concept of 'sequence'.
-- For tables, iterates over all values with integer indices.
-- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
-- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==> 1,10,22,55
-- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==> h e l p
function List.iterate(seq)
    if type(seq) == 'string' then
        local idx = 0
        local n = #seq
        local sub = string.sub
        return function ()
            idx = idx + 1
            if idx > n then return nil
            else
                return sub(seq,idx,idx)
            end
        end
    elseif type(seq) == 'table' then
        local idx = 0
        local n = #seq
        return function()
            idx = idx + 1
            if idx > n then return nil
            else
                return seq[idx]
            end
        end
    elseif type(seq) == 'function' then
        return seq
    elseif type(seq) == 'userdata' and io.type(seq) == 'file' then
        return seq:lines()
    end
end
iter = List.iterate

return List

     end)package.preload['pl.Map'] = (function (...)
      --- A Map class.
--
--    > Map = require 'pl.Map'
--    > m = Map{one=1,two=2}
--    > m:update {three=3,four=4,two=20}
--    > = m == M{one=1,two=20,three=3,four=4}
--    true
--
-- Dependencies: `pl.utils`, `pl.class`, `pl.tablex`, `pl.pretty`
-- @module pl.Map

local tablex = require 'pl.tablex'
local utils = require 'pl.utils'
local stdmt = utils.stdmt
local is_callable = utils.is_callable
local tmakeset,deepcompare,merge,keys,difference,tupdate = tablex.makeset,tablex.deepcompare,tablex.merge,tablex.keys,tablex.difference,tablex.update

local pretty_write = require 'pl.pretty' . write
local Map = stdmt.Map
local Set = stdmt.Set
local List = stdmt.List

local class = require 'pl.class'

-- the Map class ---------------------
class(nil,nil,Map)

local function makemap (m)
    return setmetatable(m,Map)
end

function Map:_init (t)
    local mt = getmetatable(t)
    if mt == Set or mt == Map then
        self:update(t)
    else
        return t -- otherwise assumed to be a map-like table
    end
end


local function makelist(t)
    return setmetatable(t,List)
end

--- list of keys.
Map.keys = tablex.keys

--- list of values.
Map.values = tablex.values

--- return an iterator over all key-value pairs.
function Map:iter ()
    return pairs(self)
end

--- return a List of all key-value pairs, sorted by the keys.
function Map:items()
    local ls = makelist(tablex.pairmap (function (k,v) return makelist {k,v} end, self))
	ls:sort(function(t1,t2) return t1[1] < t2[1] end)
	return ls
end

-- Will return the existing value, or if it doesn't exist it will set
-- a default value and return it.
function Map:setdefault(key, defaultval)
   return self[key] or self:set(key,defaultval) or defaultval
end

--- size of map.
-- note: this is a relatively expensive operation!
-- @class function
-- @name Map:len
Map.len = tablex.size

--- put a value into the map.
-- @param key the key
-- @param val the value
function Map:set (key,val)
    self[key] = val
end

--- get a value from the map.
-- @param key the key
-- @return the value, or nil if not found.
function Map:get (key)
    return rawget(self,key)
end

local index_by = tablex.index_by

--- get a list of values indexed by a list of keys.
-- @param keys a list-like table of keys
-- @return a new list
function Map:getvalues (keys)
    return makelist(index_by(self,keys))
end

--- update the map using key/value pairs from another table.
-- @param table
-- @function Map:update
Map.update = tablex.update

function Map:__eq (m)
    -- note we explicitly ask deepcompare _not_ to use __eq!
    return deepcompare(self,m,true)
end

function Map:__tostring ()
    return pretty_write(self,'')
end

return Map
     end)package.preload['pl.OrderedMap'] = (function (...)
      --- OrderedMap, a map which preserves ordering.
--
-- Derived from `pl.Map`.
--
-- Dependencies: `pl.utils`, `pl.tablex`, `pl.List`
-- @module pl.OrderedMap

local tablex = require 'pl.tablex'
local utils = require 'pl.utils'
local List = require 'pl.List'
local index_by,tsort,concat = tablex.index_by,table.sort,table.concat

local class = require 'pl.class'
local Map = require 'pl.Map'

local OrderedMap = class(Map)
OrderedMap._name = 'OrderedMap'

--- construct an OrderedMap.
-- Will throw an error if the argument is bad.
-- @param t optional initialization table, same as for @{OrderedMap:update}
function OrderedMap:_init (t)
    self._keys = List()
    if t then
        local map,err = self:update(t)
        if not map then error(err,2) end
    end
end

local assert_arg,raise = utils.assert_arg,utils.raise

--- update an OrderedMap using a table.
-- If the table is itself an OrderedMap, then its entries will be appended. <br>
-- if it s a table of the form <code>{{key1=val1},{key2=val2},...}</code> these will be appended. <br>
-- Otherwise, it is assumed to be a map-like table, and order of extra entries is arbitrary.
-- @param t a table.
-- @return the map, or nil in case of error
-- @return the error message
function OrderedMap:update (t)
    assert_arg(1,t,'table')
    if OrderedMap:class_of(t) then
       for k,v in t:iter() do
           self:set(k,v)
       end
    elseif #t > 0 then -- an array must contain {key=val} tables
       if type(t[1]) == 'table' then
           for _,pair in ipairs(t) do
               local key,value = next(pair)
               if not key then return raise 'empty pair initialization table' end
               self:set(key,value)
           end
       else
           return raise 'cannot use an array to initialize an OrderedMap'
       end
    else
       for k,v in pairs(t) do
           self:set(k,v)
       end
    end
   return self
end

--- set the key's value.   This key will be appended at the end of the map. <br>
-- If the value is nil, then the key is removed.
-- @param key the key
-- @param val the value
-- @return the map
function OrderedMap:set (key,val)
    if not self[key] and val ~= nil then -- ensure that keys are unique
       self._keys:append(key)
    elseif val == nil then -- removing a key-value pair
       self._keys:remove_value(key)
    end
    self[key] = val
    return self
end

--- insert a key/value pair before a given position.
-- Note: if the map already contains the key, then this effectively
-- moves the item to the new position by first removing at the old position.
-- Has no effect if the key does not exist and val is nil
-- @param pos a position starting at 1
-- @param key the key
-- @param val the value; if nil use the old value
function OrderedMap:insert (pos,key,val)
    local oldval = self[key]
    val = val or oldval
    if oldval then
        self._keys:remove_value(key)
    end
    if val then
        self._keys:insert(pos,key)
        self[key] = val
    end
    return self
end

--- return the keys in order.
-- (Not a copy!)
-- @return List
function OrderedMap:keys ()
    return self._keys
end

--- return the values in order.
-- this is relatively expensive.
-- @return List
function OrderedMap:values ()
    return List(index_by(self,self._keys))
end

--- sort the keys.
-- @param cmp a comparison function as for @{table.sort}
-- @return the map
function OrderedMap:sort (cmp)
    tsort(self._keys,cmp)
    return self
end

--- iterate over key-value pairs in order.
function OrderedMap:iter ()
    local i = 0
    local keys = self._keys
    local n,idx = #keys
    return function()
        i = i + 1
        if i > #keys then return nil end
        idx = keys[i]
        return idx,self[idx]
    end
end

OrderedMap.__pairs = OrderedMap.iter

function OrderedMap:__tostring ()
    local res = {}
    for i,v in ipairs(self._keys) do
        local val = self[v]
        local vs = tostring(val)
        if type(val) ~= 'number' then
            vs = '"'..vs..'"'
        end
        res[i] = tostring(v)..'='..vs
    end
    return '{'..concat(res,',')..'}'
end

return OrderedMap



     end)module("svo", package.seeall)
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

version = "4"


local luanotify = {}
luanotify.signal = require("notify.signal")

local lfs = require "lfs"

local debug = require "debug"

openURL = openURL or openUrl
-- !!
local pl = {}
pl.pretty     = require "pl.pretty"
pl.config     = require "pl.config"
pl.dir        = require "pl.dir"
pl.string     = require "pl.stringx"
pl.OrderedMap = require "pl.OrderedMap"
pl.tablex     = require "pl.tablex"

local phpTable
phpTable = function (...) -- abuse to: http://richard.warburton.it
  local newTable,keys,values={},{},{}
  newTable.pairs=function(self) -- pairs iterator
    local count=0
    return function()
      count=count+1
      return keys[count],values[keys[count]]
    end
  end
  setmetatable(newTable,{
    __newindex=function(self,key,value)
      if not self[key] then table.insert(keys,key)
      elseif value==nil then -- Handle item delete
        local count=1
        while keys[count]~=key do count = count + 1 end
        table.remove(keys,count)
      end
      values[key]=value -- replace/create
    end,
    __index=function(self,key) return values[key] end
  })
  local arg = {...}
  for x=1,#arg do
    for k,v in pairs(arg[x]) do newTable[k]=v end
  end
  return newTable
end

function ripairs(t)
  local function ripairs_it(t,i)
    i=i-1
    local v=t[i]
    if v==nil then return v end
    return i,v
  end
  return ripairs_it, t, #t+1
end

local affs        = {}
local balanceless = {}
local cp          = {}
local lifevision  = {}
local signals     = {}
local sps         = {}
local sys         = {}

conf             = {}
config           = {}
defc             = {} -- current defences
defs             = {}
dragonheal       = {} -- stores dragonheal curing strats
lifep            = {}
lifevision.l     = pl.OrderedMap()
paragraph_length = 0
restore          = {}
shrugging        = {} -- stores shrugging curing strats
sp               = {} -- parry
sp_config        = {}
stats            = {}
tree             = {}
rage             = {}
fitness          = {}
valid            = {}
watch            = {}

local actions, sk, vm, cn, cnrl = false, {}, {}, {}, {}

reset = {}
prio = {}
local affmt = {
  __tostring = function (self)
      local result = {}
      for i,k in pairs(self) do
        if k.p.count then
          result[#result+1] = i .. ": " ..getStopWatchTime(k.sw).."s (" .. k.p.count .. ")"
        else
          result[#result+1] = i .. ": " ..getStopWatchTime(k.sw).."s"
        end
      end

      return table.concat(result, ", ")
  end
}
setmetatable(affs, affmt)

affl = affl or {}


serverignore = {}
ignore = {}

-- has to be here, before the first dict reference in code, so it counts it as a local and uses this one properly
local dict

local oldecho = conf.commandecho
signals.aeony = luanotify.signal.new()
signals.sync = luanotify.signal.new()

signals.dragonform = luanotify.signal.new()

local haddragonform = false
signals.dragonform:add_post_emit(function()
  if defc.dragonform and not haddragonform then
    raiseEvent"svo got dragonform"
    haddragonform = true
  elseif not defc.dragonform and haddragonform then
    raiseEvent"svo lost dragonform"
    haddragonform = false
  end
end)

signals.canoutr = luanotify.signal.new()
signals.canoutr:connect(function()
  if (affs.webbed or affs.bound or affs.transfixed or affs.roped or affs.impale or ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))) then
    sys.canoutr = false
    me.canoutr = false
  else
    sys.canoutr = true
    me.canoutr = true
  end
end)


signals.removed_from_rift = luanotify.signal.new()
signals.moved = luanotify.signal.new()

signals.systemstart = luanotify.signal.new()

signals.systemstart:connect(function() signals.canoutr:emit() end) -- setup the variables


signals.quit = luanotify.signal.new()
signals.connected = luanotify.signal.new()
signals.quit:add_pre_emit(function () signals.saveconfig:emit() end)
signals.quit:add_pre_emit(function () raiseEvent "svo quit" end)
signals.systemend = luanotify.signal.new()

signals.donedefup = luanotify.signal.new()

-- gmcp ones
signals.gmcpcharname = luanotify.signal.new()
signals.gmcpcharname:connect(function ()
  signals.enablegmcp:emit()
end)
signals.gmcproominfo        = luanotify.signal.new()
signals.gmcpcharstatus      = luanotify.signal.new()
signals.gmcpcharitemslist   = luanotify.signal.new()
signals.gmcpcharitemsadd    = luanotify.signal.new()
signals.gmcpcharskillsinfo  = luanotify.signal.new()
signals.gmcpcharskillslist  = luanotify.signal.new()
signals.gmcpcharitemsupdate = luanotify.signal.new()
signals.gmcpcharitemsremove = luanotify.signal.new()
signals.gmcpcharvitals      = luanotify.signal.new()

-- make a 'signals bank' that remembers all gmcp events that happend before the prompt. reset on prompt. check it for stuff when necessary.
-- have the herb out signal be remembers on it's own & verified by the syste

do
  local oldnum, oldarea
  signals.gmcproominfo:connect(function (...)
    if oldnum ~= gmcp.Room.Info.num then
      signals.newroom:emit(_G.gmcp.Room.Info.name)
      oldnum = gmcp.Room.Info.num
    end

    signals.anyroom:emit(_G.gmcp.Room.Info.name)

    if oldarea ~= gmcp.Room.Info.area then
      signals.newarea:emit(_G.gmcp.Room.Info.area)
      oldarea = gmcp.Room.Info.area
    end
  end)
end

-- atcp ones
signals.charname = luanotify.signal.new()
signals.roombrief = luanotify.signal.new()

do
  local oldnum
  signals.roombrief:connect(function (...)
    if oldnum ~= atcp.RoomNum then
      signals.newroom:emit(({...})[1])
      oldnum = atcp.RoomNum
    end

    signals.anyroom:emit(({...})[1])
  end)
end

-- general ones
signals.relogin = luanotify.signal.new()
signals.enablegmcp = luanotify.signal.new()
signals.enablegmcp:add_post_emit(function ()
  logging_in = false
  if not sys.enabledgmcp then
    sys.enabledgmcp = true
  else
    signals.relogin:emit()
    echof("Welcome back!")
    -- defs.quietswitch("basic")
  end
  -- app("off", true) -- this triggers a dict() run too early before login
  if dont_unpause_login then dont_unpause_login = nil
  else conf.paused = false end

  innews = false
end)
tempBeginOfLineTrigger("Rapture Runtime Environment", [[svo.logging_in = true]])

signals.newroom = luanotify.signal.new()
signals.newarea = luanotify.signal.new()
signals.anyroom = luanotify.signal.new()
signals.changed_maxhealth = luanotify.signal.new()
signals.changed_maxhealth:connect(function (old, new) -- can't use add_post_emit, as that doesn't pass arguments down
  if not string.find(debug.traceback(), "Alias", 1, true) then
    if not (old and new) or (old and old == 1) then
      echof("Your max health changed to %dh.", stats.maxhealth)
    elseif old > new then
      echof("Your max health decreased by %dh/%d%% to %d.", (old-new), 100-math.floor((100/old)*new), new)
    else
      echof("Your max health increased by %dh/%d%% to %d.", (new-old), (math.floor((100/old)*new)-100), new)

      -- track stain
      sk.gotmaxhealth = true
      prompttrigger("check stain expiring", function()
        if paragraph_length == 0 and sk.gotmaxhealth and sk.gotmaxmana and affs.stain then
          removeaff("stain")
          echof("I think stain faded.")
        end
        sk.gotmaxhealth, sk.gotmaxmana = nil, nil
      end)
    end
  end
end)
signals.changed_maxmana = luanotify.signal.new()
signals.changed_maxmana:connect(function (old, new)
  if not string.find(debug.traceback(), "Alias", 1, true) then
    if not (old and new) or (old and old == 1) then
      echof("Your max mana changed to %dm.", stats.maxmana)
    elseif old > new then
      echof("Your max mana decreased by %dm/%d%% to %d.", (old-new), 100-math.floor((100/old)*new), new)
    else
      echof("Your max mana increased by %dm/%d%% to %d.", (new-old), (math.floor((100/old)*new)-100), new)

      sk.gotmaxmana = true
      prompttrigger("check stain expiring", function()
        if paragraph_length == 0 and sk.gotmaxhealth and sk.gotmaxmana and affs.stain then
          removeaff("stain")
          echof("I think stain faded.")
        end
        sk.gotmaxhealth, sk.gotmaxmana = nil, nil
      end)
    end
  end
end)

signals.before_prompt_processing    = luanotify.signal.new()
signals.after_prompt_processing     = luanotify.signal.new()
signals.after_lifevision_processing = luanotify.signal.new()

signals.curedwith_focus             = luanotify.signal.new()
signals.curemethodchanged           = luanotify.signal.new()
signals.limbhit                     = luanotify.signal.new()
signals.loadconfig                  = luanotify.signal.new()
signals.orgchanged                  = luanotify.signal.new()
signals.saveconfig                  = luanotify.signal.new()
signals.sysdatasendrequest          = luanotify.signal.new()

signals.saveconfig:add_post_emit(function ()
  echo"\n"
  echof("Saved system settings.")
end)

signals.loadedconfig                 = luanotify.signal.new()
signals.svogotaff                    = luanotify.signal.new()
signals.svolostaff                   = luanotify.signal.new()
signals.sysexitevent                 = luanotify.signal.new()
signals["mmapper updated pdb"]       = luanotify.signal.new()
signals["svo config changed"]        = luanotify.signal.new()
signals["svo defup changed"]         = luanotify.signal.new()
signals["svo got balance"]           = luanotify.signal.new()
signals["svo ignore changed"]        = luanotify.signal.new()
signals["svo keepup changed"]        = luanotify.signal.new()
signals["svo lost balance"]          = luanotify.signal.new()
signals["svo prio changed"]          = luanotify.signal.new()
signals["svo serverignore changed"]  = luanotify.signal.new()
signals["svo switched defence mode"] = luanotify.signal.new()
signals["svo system loaded"]         = luanotify.signal.new()
signals["svo done defup"]            = luanotify.signal.new()



conf.siphealth            = 80
conf.sipmana              = 70
conf.mosshealth           = 60
conf.mossmana             = 60
conf.assumestats          = 15

conf.ai_resetfocusbal     = 5
conf.ai_resetsipbal       = 7 -- was 5 before, but started overrunning
conf.ai_resetherbbal      = 2.5 -- normally at 1.6
conf.ai_resetsalvebal     = 5
conf.ai_resetmossbal      = 10  -- resets at 6
conf.ai_resetpurgativebal = 10 -- it's 7s for voyria
conf.ai_resetdragonhealbal = 20 -- 20s for dragonheal
conf.ai_resetsmokebal = 2 -- ~1.5s for smoking bal

conf.ai_minherbbal        = 1.0
conf.ai_restoreckless     = 0.4
conf.ai_minrestorecure    = 3.5
conf.tekura_delay         = 0.050

conf.classattacksamount   = 3
conf.classattackswithin   = 15
conf.enableclassesfor     = 2

conf.singlepromptsize     = 11

conf.gagotherbreath       = true
conf.gagbreath            = true

conf.burrowpause          = true

conf.changestype          = "shortpercent"

conf.paused               = false
conf.lag                  = 0
sys.wait                  = 0.7 -- for lag
conf.aillusion            = true -- on by deafult, disable it if necessary
conf.keepup               = true

conf.burstmode            = "empty"
conf.slowcurecolour       = "blue"
conf.hinderpausecolour    = "orange"

conf.sacdelay             = 0.5 -- delay after which the systems curing should resume in sync mode

conf.bleedamount          = 60
conf.manableedamount      = 60
conf.corruptedhealthmin   = 70
conf.manause              = 35

conf.fluiddelay           = 0.3
conf.smallbleedremove     = 8

conf.eventaffs            = true
conf.autoarena            = true

-- have skills?
conf.commandecho          = true
conf.blockcommands        = true
conf.commandechotype      = "fancy"
conf.warningtype          = "right"

conf.autoreject           = "white"
conf.doubledo             = false

conf.ridingskill          = "mount"
conf.ridingsteed          = "pony"

conf.screenwidth          = 100
conf.refillat             = 1
conf.waitherbai           = true
conf.noeqtimeout          = 5

conf.autoslick            = true
conf.showbaltimes         = true
conf.showafftimes         = true

conf.steedfollow          = true
conf.autoclasses          = true

conf.ccto                 = "pt"
conf.repeatcmd            = 0




conf.gagclot              = true
conf.gagrelight           = false
conf.relight              = true

conf.passive_eqloss       = 10

conf.highlightparryfg     = "white"
conf.highlightparrybg     = "blue"

conf.autotsc              = true
conf.ignoresinglebites    = false

conf.medprone             = false
conf.unmed                = false

conf.pagelength           = 20
conf.treebalance          = 0

conf.healthaffsabove      = 70

conf.batch                = true

conf.curemethod = "conconly"
signals.systemstart:add_post_emit(function()
  if not conf.curemethod or conf.curemethod == "auto" then
    conf.curemethod = "conconly"
  end
end)

conf.ninkharsag = true

sys.sync = false
sys.deffing = false
sys.balanceid = 0
sys.balancetick = 1
sys.lagcount, sys.lagcountmax = 0, 3
sys.actiontimeout = 3
sys.actiontimeoutid = false
sys.manause = 0
sys.sipmana, sys.siphealth, sys.mosshealth, sys.mossmana = 0, 0, 0, 0
sys.transmuteamount = 0

sys.sp_satisfied, sys.blockparry = false, false
sys.canoutr = true

-- the in-game custom prompt needs to show the game target and game target hp, since that isn't available in GMCP at the moment, as well as any class-specific balances and values
sys.ingamecustomprompt ="CONFIG PROMPT CUSTOM *hh, *mm, *ee, *ww *t*T *b*d*c-*r-s*s-"
-- used in lyre actions to prevent doubledo from activating - since that'd destroy the lyre right away
sys.sendonceonly = false

-- a map that has possible commands linked to dict.action.balance entries
sys.input_to_actions = {}
-- a map that stores dict.action.balance.name
sys.last_used = {}

sys.downloadurl = {
}

---

danaeusaffs = {"agoraphobia", "claustrophobia", "dizziness", "epilepsy", "hypersomnia", "vertigo"}
nemesisaffs = {"agoraphobia", "recklessness", "confusion", "masochism", "loneliness"}
scragaffs   = {"clumsiness", "healthleech", "lethargy", "sensitivity", "haemophilia", "darkshade"}

---

stats.nextlevel,
stats.currenthealth, stats.maxhealth,
stats.currentmana, stats.maxmana,
stats.currentendurance, stats.maxendurance,
stats.currentwillpower, stats.maxwillpower = 1,1,1,1,1,1,1,1,1


---
me = {}
me.skills = {}
me.wielded = {}
me.oldhealth = 0

me.class = "apostate"
me.skills = {
  necromancy = true,
  evileye = true,
  apostasy = true
}

me.doqueue = {repeating = false}
me.dofreequeue = {}
me.dopaused = false
me.lustlist = {} -- list if names not to add lovers aff for
me.lasthitlimb = "head" -- last hit limb
me.disableddragonhealfunc = {}
me.disabledrestorefunc    = {}
me.disabledtreefunc       = {}
me.disabledragefunc       = {}
me.disabledfitnessfunc       = {}
me.unparryables = {}
me.focusedknights = {}
me.locks = {}
me.curelist = {
  ash         = "ash",
  bayberry    = "bayberry",
  bellwort    = "bellwort",
  bloodroot   = "bloodroot",
  caloric     = "caloric",
  cohosh      = "cohosh",
  echinacea   = "echinacea",
  elm         = "elm",
  epidermal   = "epidermal",
  frost       = "frost",
  ginger      = "ginger",
  ginseng     = "ginseng",
  goldenseal  = "goldenseal",
  hawthorn    = "hawthorn",
  health      = "health",
  immunity    = "immunity",
  irid        = "irid",
  kelp        = "kelp",
  kola        = "kola",
  levitation  = "levitation",
  lobelia     = "lobelia",
  mana        = "mana",
  mass        = "mass",
  mending     = "mending",
  myrrh       = "myrrh",
  pear        = "pear",
  restoration = "restoration",
  sileris     = "sileris",
  skullcap    = "skullcap",
  speed       = "speed",
  valerian    = "valerian",
  venom       = "venom",
}


me.cadmusaffs = me.cadmusaffs or {
  ["agoraphobia"]    = false,
  ["anorexia"]       = true,
  ["claustrophobia"] = false,
  ["confusion"]      = false,
  ["dizziness"]      = false,
  ["epilepsy"]       = false,
  ["fear"]           = false,
  ["generosity"]     = false,
  ["loneliness"]     = false,
  ["masochism"]      = false,
  ["pacifism"]       = false,
  ["recklessness"]   = true,
  ["shyness"]        = false,
  ["stupidity"]      = true,
  ["unknownmental"]  = false,
  ["vertigo"]        = false,
  ["weakness"]       = false,
}
---

disableTrigger("Shindo defences")

disableTrigger("Kaido defences")

disableTrigger("Tekura balances")

disableTrigger("Hydra balance")

disableTrigger("Voice balance")

disableTrigger("Fitness balance")

disableTrigger("Rage balance")

disableTrigger("Two-hander recover footing")

disableTrigger("Domination entities balance")

disableTrigger("Shrugging balance")

disableTrigger("Healing + Elementalism channels")

disableAlias("Elementalism aliases")

disableTrigger("Spirituality defences")
disableAlias("Spirituality aliases")

disableTrigger("Propagation defences")

enableTrigger("Necromancy defences")

disableTrigger("Occultism defences")

disableTrigger("Alchemy defences")

disableTrigger("Groves defences")

disableTrigger("Harmonics defences")

disableTrigger("Healing balance")

disableTrigger("Humour balance")

local prompt_stats

local defences = {}
local defs_data
local oldsend
local defupfinish, process_defs
local doingaction, checkaction, checkany, killaction, actions_performed, bals_in_use, usingbal, doaction, actionfinished
local wait_tbl

local index_map = pl.tablex.index_map

local addaff, removeaff, checkanyaffs, updateaffcount

local lostbal_focus, lostbal_herb, lostbal_salve, lostbal_purgative, lostbal_sip
sk.salvetick, sk.herbtick, sk.focustick, sk.teatick, sk.purgativetick, sk.siptick, sk.mosstick, sk.dragonhealtick, sk.smoketick, sk.voicetick = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

sk.diag_list = {}
sk.priosbeforechange = {}
 -- caches prio changes, so none need to happen on holes in svo's prios
sk.priochangecache = { special = {} }
-- queue of commands to batch into a serverside alias for curing
sk.sendqueue = {}
-- keep track of the length of the command - max command length in Achaea is 2048
sk.sendqueuel = 18 -- 'setalias multicmd ' is 24 characters
sk.achaea_command_max_length = 2048

-- a buffer to keep track of the commands the system has sent
sk.systemscommands = {}

local clear_balance_prios, clear_sync_prios

local herb_cure, smoke_cure, focus_cure, sip_cure
local promptcount, lastpromptnumber = 0, 0

local config_dict, vecho

local make_prio_table, make_sync_prio_table

local findbybal, findbybals, will_take_balance


local make_gnomes_work, send_in_the_gnomes, make_gnomes_work_async, make_gnomes_work_sync

local apply_cure, sacid, eat, sip, apply

local send = _G.send

local update

-- possible afflictions that need to go through a check first
local affsp = {}

local rift, pipes = {}, {}

local check_focus, check_salve, check_sip, check_purgative, check_herb, check_moss, check_misc, check_balanceless_acts, check_balanceful_acts, check_smoke

local generics_enabled, generics_enabled_for_blackout, generics_enabled_for_passive, enable_generic_trigs, disable_generic_trigs, check_generics

local passive_cure_paragraph

local sp_checksp, sp_limbs

local install = {}

local life = {}
echos, echosd = {}, {}

sk.ignored_defences, sk.ignored_defences_map = {}, {}
sk.zeromana = false

pflags = {}


local function assert(condition, msg, extra)
  if not condition then
    if extra then
      extra(msg)
    else
      error(msg)
    end
  end
end

sk.checkaeony = function()
  if (affs.aeon or affs.retardation) and not sys.sync then
    oldecho = conf.commandecho
    conf.commandecho = true
    sys.sync = true
    signals.sync:emit()
    signals.sysdatasendrequest:unblock(cnrl.processcommand)

    -- kill actions prior to this, so we can do aeon
    local to_kill = {}
    for k,v in actions:iter() do
      if v.p.balance ~= "waitingfor" and v.p.balance ~= "aff" and v.p.balance ~= "gone" and v.p.name ~= "aeon_smoke" and v.p.name ~= "checkslows_misc" and v.p.name ~= "touchtree_misc" then -- don't kill aeon_smoke: if we do, we double-smoke. instead, since smoke is started before sync is set: add a customwait delay. Don't kill tree touching either, could help for asthma
        to_kill[#to_kill+1] = dict[v.p.action_name][v.p.balance]
      end
    end

    for _, action in ipairs(to_kill) do
      killaction(action)
    end

    echo("\n")
    echof("%s mode enabled.", (math.random(1, 20) == 20 and "Matrix" or "Slow curing"))

    if conf.autotsc then
      if affs.retardation then
        conf.blockcommands = false -- bypass config.set, because that calls gnomes for us
        echo"\n" echof(" (autotsc) - command overrides enabled.")
      elseif affs.aeon then
        conf.blockcommands = true
        echo"\n" echof(" (autotsc) - command denies enabled.")
      end
    end
  elseif sys.sync and not (affs.aeon or affs.retardation) then
    conf.commandecho = oldecho
    sys.sync = false
    signals.sync:emit()
    signals.sysdatasendrequest:block(cnrl.processcommand)
    echo("\n")
    echof("Slow curing mode disabled.")
  end
end

signals.systemstart:connect(function ()
  (tempExactMatchTrigger or tempTrigger)("You open your mouth but say nothing.",
    [[svo.valid.saidnothing()]]);

  (tempExactMatchTrigger or tempTrigger)("You are not fallen or kneeling.",
    [[svo.valid.nothingtowield()]]);

  (tempExactMatchTrigger or tempTrigger)("You stand up and stretch your arms out wide.",
    [[svo.valid.nothingtowield()]]);

  (tempExactMatchTrigger or tempTrigger)("What do you want to eat?",
    [[svo.valid.nothingtoeat()]]);

  (tempExactMatchTrigger or tempTrigger)("You inhale deeply and begin holding your breath.",
    [[svo.valid.lungsokay()]]);

  (tempExactMatchTrigger or tempTrigger)("Sticky strands of webbing cling to you, making that impossible.",
    [[svo.valid.symp_webbed()]]);

  (tempExactMatchTrigger or tempTrigger)("You are too tangled up to do that.",
    [[svo.valid.symp_roped()]]);
  (tempExactMatchTrigger or tempTrigger)("Your legs are tangled in a mass of rope and you cannot move.",
    [[svo.valid.symp_roped()]]);

  (tempExactMatchTrigger or tempTrigger)("Your lungs are too weak to hold your breath.",
    [[svo.valid.weakbreath()]]);

  (tempExactMatchTrigger or tempTrigger)("You are impaled and must writhe off before you may do that.",
    [[svo.valid.symp_impaled()]]);
  (tempExactMatchTrigger or tempTrigger)("The weapon that transfixes your gut makes leaving impossible.",
    [[svo.valid.symp_impaled()]]);

  (tempExactMatchTrigger or tempTrigger)("You move sluggishly into action.",
    [[svo.valid.webeslow()]]);

  (tempExactMatchTrigger or tempTrigger)("You are transfixed and cannot do that. You must writhe to escape.",
    [[svo.valid.symp_transfixed()]]);
end);


color_table.a_darkred     = {128, 0, 0}
color_table.a_darkgreen   = {0, 179, 0}
color_table.a_brown       = {128, 128, 0}
color_table.a_darkblue    = {0, 0, 128}
color_table.a_darkmagenta = {128, 0, 128}
color_table.a_darkcyan    = {0, 128, 128}
color_table.a_grey        = {192, 192, 192}
color_table.a_darkgrey    = {128, 128, 128}
color_table.a_red         = {255, 0, 0}
color_table.a_green       = {0, 255, 0}
color_table.a_yellow      = {255, 255, 0}
color_table.a_blue        = {0, 85, 255}
color_table.a_magenta     = {255, 0, 255}
color_table.a_cyan        = {0, 255, 255}
color_table.a_white       = {255, 255, 255}
color_table.a_darkwhite   = {192, 192, 192}
color_table.a_darkyellow  = {0, 179, 0}
-- 2D2E2E, 676562, 433020, 28BA28, 398C39, 0D790D
color_table.a_onelevel    = {45, 46, 46}
color_table.a_twolevel    = {103, 101, 98}
color_table.a_threelevel  = {67, 48, 32}
color_table.a_fourlevel   = {40, 186, 40}
color_table.a_fivelevel   = {57, 140, 57}
color_table.a_sixlevel    = {13, 121, 13}
color_table.blaze_orange  = {255, 102, 0}


-- check if the person imported the xml many times by accident
signals.systemstart:connect(function ()
  local toomany, types = {}, {"alias", "trigger"} -- add scripts when exists() function supports it

  for _, type in ipairs(types) do
    if exists("svo", type) > 1 then
      toomany[#toomany+1] = type
    end
  end

  if #toomany == 0 then return end

  tempTimer(10, function () echof("Warning! You have multiple %s svo folders while you only should have one per aliases, triggers, etc. Delete the extra ones.", table.concat(toomany, ", ")) end)
end)

-- fix iffy table.save
function table.save( sfile, t )
	local tables = {}
	table.insert( tables, t )
	local lookup = { [t] = 1 }
	local file, msg = io.open( sfile, "w" )
	if not file then return nil, msg end

	file:write( "return {" )
	for i,v in ipairs( tables ) do
		table.pickle( v, file, tables, lookup )
	end
	file:write( "}" )
	file:close()

	return true
end

-- load the lust list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/lustlist"

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    update(me.lustlist, t)
  end
end)

signals.saveconfig:connect(function () table.save(getMudletHomeDir() .. "/svo/config/lustlist", me.lustlist) end)

-- load the ignore list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/ignore"

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    update(ignore, t)
  end

  ignore.checkparalysis = true
end)

signals.saveconfig:connect(function () table.save(getMudletHomeDir() .. "/svo/config/ignore", ignore) end)

-- load the locatelist
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/locatelist"

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    me.locatelist = me.locatelist or {} -- make sure it's initialized
    update(me.locatelist, t)
  end
end)
signals.saveconfig:connect(function () me.locatelist = me.locatelist or {}; table.save(getMudletHomeDir() .. "/svo/config/locatelist", me.locatelist) end)

-- load the watchfor list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/watchfor"

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    me.watchfor = me.watchfor or {} -- make sure it's initialized
    update(me.watchfor, t)
  end
end)
signals.saveconfig:connect(function () me.watchfor = me.watchfor or {}; table.save(getMudletHomeDir() .. "/svo/config/watchfor", me.watchfor) end)

-- load the tree list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/tree"

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledtreefunc)
  end

  if not conf.disabledtreedefaults then
    conf.disabledtreedefaults = true

    me.disabledtreefunc.any2affs = true
    me.disabledtreefunc.any3affs = true
  end
end)
-- save the tree func list
signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/config/tree", me.disabledtreefunc)
end)

-- load the fitness list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/fitness"

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledfitnessfunc)
  end

  if not conf.disabledfitnessdefaults then
    conf.disabledfitnessdefaults = true
  end
end)
-- save the fitness func list
signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/config/fitness", me.disabledfitnessfunc)
end)

-- load the rage list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/rage"

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledragefunc)
  end

  if not conf.disabledragedefaults then
    conf.disabledragedefaults = true
  end
end)
-- save the rage func list
signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/config/rage", me.disabledragefunc)
end)

-- load the restore func list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/restore"

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledrestorefunc)
  else
    tempTimer(0, function () me.disabledrestorefunc.anylimb = true; me.disabledrestorefunc.anyoneortwolimbs = true; end)
  end
end)
-- save the restore func list
signals.saveconfig:connect(function ()

  table.save(getMudletHomeDir() .. "/svo/config/restore", me.disabledrestorefunc)
end)

-- load the dragonheal func list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/dragonheal"

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disableddragonhealfunc)
  else
    tempTimer(0, function () me.disableddragonhealfunc.anylimb = true end)
  end
end)
-- save the dragonheal func list
signals.saveconfig:connect(function ()

  table.save(getMudletHomeDir() .. "/svo/config/dragonheal", me.disableddragonhealfunc)
end)

-- load the serverignore list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/serverignore"

  if lfs.attributes(conf_path) then
    local ok, msg = pcall(table.load, conf_path, serverignore)
    if not ok then
      os.remove(conf_path)
      tempTimer(10, function()
        echof("Your serverignore serverignore file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-set all of the shrugging strats, though. (%q)", msg)
      end)
    end
  end
end)
-- save the serverignore list
signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/config/serverignore", serverignore)
end)

-- load the cadmusaffs list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/cadmusaffs"

  if lfs.attributes(conf_path) then
    local ok, msg = pcall(table.load, conf_path, me.cadmusaffs)
    if not ok then
      os.remove(conf_path)
      tempTimer(10, function()
        echof("Your cadmusaffs serverignore file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-set all of the cadmus affs, though. (%q)", msg)
      end)
    end
  end
end)
-- save the cadmusaffs list
signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/config/cadmusaffs", me.cadmusaffs)
end)

-- load the prefercustom list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/prefercustom"

  if lfs.attributes(conf_path) then
    local ok, msg = pcall(table.load, conf_path, me.curelist)
    if not ok then
      os.remove(conf_path)
      tempTimer(10, function()
        echof("Your prefercustom serverignore file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-set all of the custom curelist, though. (%q)", msg)
      end)
    end
  end
end)
-- save the prefercustom list
signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/config/prefercustom", me.curelist)
end)




-- data for normal/trans sipping
es_categories = {
  ["a caloric salve"]         = "salve",
  ["a salve of mass"]         = "salve",
  ["a salve of mending"]      = "salve",
  ["a salve of restoration"]  = "salve",
  ["an elixir of frost"]      = "elixir",
  ["an elixir of health"]     = "elixir",
  ["an elixir of immunity"]   = "elixir",
  ["an elixir of levitation"] = "elixir",
  ["an elixir of mana"]       = "elixir",
  ["an elixir of speed"]      = "elixir",
  ["an elixir of venom"]      = "elixir",
  ["an epidermal salve"]      = "salve",
  ["empty"]                   = "empty",
  ["the venom aconite"]       = "venom",
  ["the venom camus"]         = "venom",
  ["the venom colocasia"]     = "venom",
  ["the venom curare"]        = "venom",
  ["the venom darkshade"]     = "venom",
  ["the venom delphinium"]    = "venom",
  ["the venom digitalis"]     = "venom",
  ["the venom epseth"]        = "venom",
  ["the venom epteth"]        = "venom",
  ["the venom euphorbia"]     = "venom",
  ["the venom eurypteria"]    = "venom",
  ["the venom gecko"]         = "venom",
  ["the venom kalmia"]        = "venom",
  ["the venom larkspur"]      = "venom",
  ["the venom loki"]          = "venom",
  ["the venom monkshood"]     = "venom",
  ["the venom nechamandra"]   = "venom",
  ["the venom notechis"]      = "venom",
  ["the venom oculus"]        = "venom",
  ["the venom oleander"]      = "venom",
  ["the venom prefarar"]      = "venom",
  ["the venom scytherus"]     = "venom",
  ["the venom selarnia"]      = "venom",
  ["the venom slike"]         = "venom",
  ["the venom sumac"]         = "venom",
  ["the venom sumac"]         = "venom",
  ["the venom vardrax"]       = "venom",
  ["the venom vernalius"]     = "venom",
  ["the venom voyria"]        = "venom",
  ["the venom xentio"]        = "venom",
}
es_shortnames = {
  aconite        = "the venom aconite",
  caloric        = "a caloric salve",
  camus          = "the venom camus",
  colocasia      = "the venom colocasia",
  curare         = "the venom curare",
  darkshade      = "the venom darkshade",
  delphinium     = "the venom delphinium",
  digitalis      = "the venom digitalis",
  epidermal      = "an epidermal salve",
  epseth         = "the venom epseth",
  epteth         = "the venom epteth",
  euphorbia      = "the venom euphorbia",
  eurypteria     = "the venom eurypteria",
  frost          = "an elixir of frost",
  gecko          = "the venom gecko",
  health         = "an elixir of health",
  immunity       = "an elixir of immunity",
  kalmia         = "the venom kalmia",
  larkspur       = "the venom larkspur",
  levitation     = "an elixir of levitation",
  loki           = "the venom loki",
  mana           = "an elixir of mana",
  mass           = "a salve of mass",
  mending        = "a salve of mending",
  monkshood      = "the venom monkshood",
  nechamandra    = "the venom nechamandra",
  notechis       = "the venom notechis",
  oculus         = "the venom oculus",
  oleander       = "the venom oleander",
  prefarar       = "the venom prefarar",
  restoration    = "a salve of restoration",
  scytherus      = "the venom scytherus",
  selarnia       = "the venom selarnia",
  slike          = "the venom slike",
  speed          = "an elixir of speed",
  sumac          = "the venom sumac",
  sumac          = "the venom sumac",
  vardrax        = "the venom vardrax",
  venom          = "an elixir of venom",
  vernalius      = "the venom vernalius",
  voyria         = "the venom voyria",
  xentio         = "the venom xentio",
  empty          = "empty", -- so changing desired amounts knows what to use
}
es_shortnamesr = {}
for k,v in pairs(es_shortnames) do es_shortnamesr[v] = k end

-- initialize this for the sipping tracking (the thing that decides what to fallback to)
es_potions = es_potions or {}

-- load defaults
for thing, category in pairs(es_categories) do
  es_potions[category] = es_potions[category] or {}
  -- consider 1 so we don't drink the aternative on prefer* right away
  if category == "venom" then
    es_potions[category][thing] = es_potions[category][thing] or {sips = 0, vials = 0, decays = 0}
  else
    es_potions[category][thing] = es_potions[category][thing] or {sips = 2, vials = 2, decays = 0}
  end
end

sk.arena_areas = {
  -- mhaldor
  ["the Desolate Towers"]              = true,
  ["the Skeletal Forest"]              = true,
  ["the Abandoned Catacombs"]          = true,
  ["the Volcanic Warrens"]             = true,
  -- shallam
  ["the Shallam Caverns"]              = true,
  ["the Hunter's Path"]                = true,
  ["the Hunting Grounds"]              = true,
  ["an Old Shack"]                     = true,
  ["the Catacombs"]                    = true,
  ["the Tower of Light"]               = true,
  -- cyrene
  ["the Forest of Solitude"]           = true,
  ["Muurn Falls"]                      = true,
  ["the Pantheon"]                     = true,
  ["some Dank Caverns"]                = true,
  ["the Matsuhama Arena"]              = true,
  ["the Caves in the Matsuhama Arena"] = true,
  -- hashan
  ["Damballah Lake"]                   = true,
  ["the Lisigia Village"]              = true,
  ["the Wealds of Lisigia"]            = true,
  ["the Lisigia Palace"]               = true,
  ["the Darkshade River"]              = true,
  ["the Lisigian Wastelands"]          = true,
  -- ashtan
  ["the Tomb Grounds"]                 = true,
  ["an underground river"]             = true,
  ["the Tomb of Glanos"]               = true,
  ["the Tomb Catacombs"]               = true,
  -- eleusis
  ["an unspoiled forest"]              = true,
  ["the endless wastelands"]           = true,
  ["a forgotten jungle"]               = true,
  ["the uncharted mountains"]          = true,
  -- delos
  ["the Central Arena"]                = true,
  ["the Modi River"]                   = true,
  ["the Gaian Forest"]                 = true,
  ["the Caverns of the Beasts"]        = true,
  ["the Gladiator Pit"]                = true,
  -- targ
  ["The Stadium"]                      = true,
  ["The Stands"]                       = true,
  ["The Pits"]                         = true,
}

-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.


vecho = function(newline, what)
  decho("<206,222,215>(<214,206,221>svof<206,222,215>)<252,251,254>: <249,244,254>" .. what)
  if newline then echo"\n" end
end

function echos.Eleusis(newline, what)
  decho("<157,60,60>(<55,145,55>svof<157,60,60>)<212,245,112>: <62,245,62>" .. what)
  if newline then echo"\n" end
end

function echosd.Eleusis()
  return "<62,245,62>"
end

function echos.LightGreen(newline, what)
  decho("<255,231,179>(<170,154,118>svof<255,231,179>)<255,241,210>: <255,219,140>" .. what)
  if newline then echo"\n" end
end

function echosd.LightGreen()
  return "<255,219,140>"
end

function echos.Mhaldor(newline, what)
  decho("<157,60,60>(<255,0,0>svof<157,60,60>)<255,65,65>: <255,117,117>" .. what)
  if newline then echo"\n" end
end

function echosd.Mhaldor()
  return "<255,117,117>"
end

function echos.Ashtan(newline, what)
  decho("<80,66,80>(<107,79,125>svof<80,66,80>)<87,85,89>: <159,128,180>" .. what)
  if newline then echo"\n" end
end

function echosd.Ashtan()
  return "<159,128,180>"
end

function echos.Shallam(newline, what)
  decho("<32,128,94>(<53,213,157>svof<32,128,94>)<53,213,157>: <0,171,111>" .. what)
  if newline then echo"\n" end
end

function echosd.Shallam()
  return "<0,171,111>"
end

function echos.Targossas(newline, what)
  decho("<32,128,94>(<53,213,157>svof<32,128,94>)<53,213,157>: <0,171,111>" .. what)
  if newline then echo"\n" end
end

function echosd.Targossas()
  return "<0,171,111>"
end

function echos.Hashan(newline, what)
  decho("<206,222,215>(<170,175,175>svof<206,222,215>)<252,251,254>: <237,244,244>" .. what)
  if newline then echo"\n" end
end

function echosd.Hashan()
  return "<237,244,244>"
end

function echos.Cyrene(newline, what)
  decho("<253,63,73>(<251,0,13>svof<253,63,73>): <253,114,121>" .. what)
  if newline then echo"\n" end
end

function echosd.Cyrene()
  return "<253,114,121>"
end

function echos.default(newline, what)
  decho("<206,222,215>(<214,206,221>svof<206,222,215>)<252,251,254>: <249,244,254>" .. what)
  if newline then echo"\n" end
end

function echosd.default()
  return "<249,244,254>"
end

signals.systemstart:connect(function ()
  vecho = echos[conf.echotype] or echos[conf.org] or echos.default
  getDefaultColor = echosd[conf.echotype] or echosd[conf.org] or echosd.default

  -- create an r,g,b table that we can setFgColor(unpack(getDefaultColorNums)) later
  getDefaultColorNums = {
    ((echosd[conf.echotype] and echosd[conf.echotype]())
      or (echosd[conf.org] and echosd[conf.org]()) or
      echosd.default()
    ):match("<(%d+),(%d+),(%d+)>")}
end)

signals.orgchanged:connect(function ()
  vecho = echos[conf.echotype] or echos[conf.org] or echos.default
  getDefaultColor = echosd[conf.echotype] or echosd[conf.org] or echosd.default

  -- create an r,g,b table that we can setFgColor(unpack(getDefaultColorNums)) later
  getDefaultColorNums = {
    ((echosd[conf.echotype] and echosd[conf.echotype]())
      or (echosd[conf.org] and echosd[conf.org]()) or
      echosd.default()
    ):match("<(%d+),(%d+),(%d+)>")}
end)

function debugf(...)
end
log = debugf

function showprompt()
  if conf.singleprompt then clearWindow"bottomprompt" end

  -- https://bugs.launchpad.net/mudlet/+bug/982720 disallows (conf.singleprompt and 'bottomprompt' or 'main')
  -- if conf.paused then
  --   if conf.singleprompt then
  --     decho('bottomprompt', "<255,0,0>(<128,128,128>p<255,0,0>)<0,0,0> ")
  --   else
  --     decho("<255,0,0>(<128,128,128>p<255,0,0>)<0,0,0> ")
  --   end
  -- end

  if not conf.customprompt or affs.blackout or innews then
    moveCursor("svo_prompt",0,getLastLineNumber("svo_prompt")-1)
    selectCurrentLine("svo_prompt")
    copy("svo_prompt")

    if conf.singleprompt then
      clearWindow("bottomprompt")

      if conf.paused then
        cecho("bottomprompt", "<a_red>(<a_darkgrey>p<a_red>)<black> ")
      end
      appendBuffer('bottomprompt')
    else
      if conf.paused then
        local currentline = getLineCount()
        deselect()
        moveCursor("main", 0, currentline)
        setFgColor(255, 0, 0)
        insertText("(")
        moveCursor("main", 1, currentline)
        setFgColor(128, 128, 128)
        insertText("p")
        moveCursor("main", 2, currentline)
        setFgColor(255, 0, 0)
        insertText(")")
        moveCursor("main", 3, currentline)
        setFgColor(0,0,0)
        insertText(" ")
        moveCursorEnd()
        resetFormat()
      end

      appendBuffer()
    end
  else
    if conf.singleprompt then
      cecho('bottomprompt', cp.display() or "")
    else
      cecho(cp.display() or "")
    end
  end
end

local ofs = {} -- original functions
ofs.origdecho = decho
function ofs.windowdecho(text)
  if sk.echofwindow == 'main' then -- workaround for https://github.com/vadi2/mudlet-lua/issues/1
    ofs.origdecho(text)
  else ofs.origdecho(sk.echofwindow, text) end
end

ofs.origecho = echo
function ofs.windowecho(text)
  if sk.echofwindow == 'main' then -- workaround for https://github.com/vadi2/mudlet-lua/issues/1
    ofs.origecho(text)
  else ofs.origecho(sk.echofwindow, text) end
end

function echof(...)
  local t = {...}
  -- see if we want this to go to a window!
  local sfind = string.find
  if t[1] and t[2] and sfind(t[1], "^%w+$") and not sfind(t[1], "%", 1, true) then
    sk.echofwindow = t[1]
    local olddecho, oldecho = decho, echo
    decho, echo = ofs.windowdecho, ofs.windowecho

    moveCursorEnd(t[1])
    vecho(true, string.format(select(2, ...)))

    decho, echo = olddecho, oldecho
  else
    moveCursorEnd("main")
    local successful, s = pcall(string.format, ...)
    if successful then
      vecho(true, s)
    else
      error(s, 2)
      -- echoLink("(e!)", [[echo("The problem was: svo.echof couldn't build the text, because: ]]..tostring(s)..[[")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
    end
  end
end

function echofn(...)
  moveCursorEnd("main")
  vecho(false, string.format(...) or "")
end

function echon(...)
  echo(string.format(...))
end

function itf(...)
  dinsertText(((echosd[conf.echotype] and echosd[conf.echotype]()) or (echosd[conf.org] and echosd[conf.org]()) or echosd.default()) .. string.format(...) or "")
  -- debugf((echosd[conf.echotype] and echosd[conf.echotype]() or echosd.default()) .. string.format(...) or "")
end

local function errorf(...)
   error(string.format(...))
end

-- used in public API to allow $'s
function snd(what, show)
  for _,w in ipairs(string.split(what, "%$")) do
    _G.send(w, show or false)
    if (affs.seriousconcussion or (conf.doubledo and affs.stupidity)) and not sys.sync then _G.send(w, show or false) end
  end
end

-- given a table of keys and values as integers, return the key with highest value
local function getHighestKey(tbl)
  local result
  local highest = -1
  for i,j in pairs(tbl) do
    if j > highest then
      highest = j
      result = i
    end
  end

  return result
end

local function getLowestKey(tbl)
  local result = select(1, next(tbl))
  local lowest = select(2, next(tbl))
  for i,j in pairs(tbl) do
    if j < lowest then
      lowest = j
      result = i
    end
  end

  return result
end

local function getHighestValue(tbl)
  local result
  local highest = 0
  for i,j in pairs(tbl) do
    if j > highest then
      highest = j
      result = i
    end
  end

  return highest
end

local function getBoundary(tbl)
  local result
  local highest, lowest = 0, select(2, next(tbl))
  for i,j in pairs(tbl) do
    if j > highest then
      highest = j
      result = i
    elseif j < lowest then
      lowest = j
    end
  end

  return highest, lowest
end

function oneconcat(tbl)
  assert(type(tbl) == "table", "svo.oneconcat wants a table as an argument.")
  local result = {}
  for i,_ in pairs(tbl) do
    result[#result+1] = i
  end

  return table.concat(result, ", ")
end

function oneconcatwithval(tbl)
  assert(type(tbl) == "table", "svo.oneconcatwithval wants a table as an argument.")
  local result = {}
  local sformat = string.format
  for i,v in pairs(tbl) do
    result[#result+1] = sformat("%s(%s)", i, v)
  end

  return table.concat(result, ", ")
end

function concatand(t)
  assert(type(t) == "table", "svo.concatand: argument must be a table")

  if #t == 0 then return ""
  elseif #t == 1 then return t[1]
  else
    return table.concat(t, ", ", 1, #t-1) .. " and "..t[#t]
  end
end

function concatandf(t, f)
  assert(type(t) == "table", "svo.concatandf: argument must be a table")

  return concatand(pl.tablex.map(f, t))
end

function keystolist(t)
  local r = {}

  for k,v in pairs(t) do
    r[#r+1] = k
  end

  return r
end

-- table -> number
-- given a shallow key-value table of items, returns the length of the biggest string value in it
function longeststring(input)
  local longest, found = 0

  local type = type
  for k,v in pairs(input) do
    if type(v) == "string" then
      found = true
      local length = #v

      if length > longest then longest = length end
    end
  end

  if found then return longest else return nil, "no strings found in the given table" end
end


function safeconcat(t, separator)
  assert(type(t) == "table", "svo.safeconcat: argument must be a table")

  if #t == 0 then return ""
  elseif #t == 1 then return tostring(t[1])
  else
    local temp = {}
    for i = 1, #t do
      temp[#temp+1] = tostring(t[i])
    end
    return table.concat(temp, separator or '')
  end
end

function deleteLineP()
  deleteLine()
  gagline = true -- used for not echoing things on lines that'll be deleted
  sk.onprompt_beforeaction_add("deleteLine", function()
    gagline = false
  end)

  if not conf.shipmode or not svo.me.shippromptn then -- if not on shipmode, or in shipmode but didn't actually see the ship prompt...
    tempLineTrigger(1,1,[[
      if isPrompt() then
        deleteLine()
      end
    ]])
  else
    sk.requested_deletelineP = getLineCount() -- remember when the deletion was requested, to work out if we should delete the prompt or not
    sk.onprompt_beforeaction_add("deleteLineP shipmode", function()
      if svo.conf.shipmode and svo.me.shippromptn and sk.requested_deletelineP+1 == svo.me.shippromptn then
        local from, to = svo.me.shippromptn , getLineCount()
        for i = from, to-1 do
          moveCursor(0, i) deleteLine()
        end
        moveCursorEnd()
         -- wrapLine(to) deleteLine()
        tempLineTrigger(0, 1, [[deleteLine()]]) -- cover the customprompt over after
      end
    end)
  end
end

function deleteAllP(count)
  if not count then deleteLine() end
  tempLineTrigger(count or 1,1,[[
  deleteLine()
  if not isPrompt() then
    svo.deleteAllP()
  end
]])
end

local function containsbyname(t, value)
  assert(type(t) == "table", "svo.containsbyname wants a table!")
  for k, v in pairs(t) do
    if v == value then return k end
  end

  return false
end

local function contains(t, value)
  assert(type(t) == "table", "svo.contains wants a table!")
  for k, v in pairs(t) do
    if v == value then
      return true
    elseif k == value then
      return true
    elseif type(v) == "table" then
      if contains(v, value) then return true end
    end
  end

  return false
end

-- longer priorities take thhe first order
local function syncdelay()
  if not sys.sync then
    return 0
  elseif affs.aeon or affs.retardation then
    return 1
  else return 0 -- failsafe
  end
end

function events(event, ...)
  local name = event:lower()
  if signals[name] then signals[name]:emit(...) end
end

function gevents(parent, key)
  local name = key:gsub("%.",""):lower()
  if signals[name] then signals[name]:emit() end
end

local function deepcopy(object)
  local lookup_table = {}
  local function _copy(object)
      if type(object) ~= "table" then
          return object
      elseif lookup_table[object] then
          return lookup_table[object]
      end
      local new_table = {}
      lookup_table[object] = new_table
      for index, value in pairs(object) do
          new_table[_copy(index)] = _copy(value)
      end
      return setmetatable(new_table, getmetatable(object))
  end
  return _copy(object)
end

local yes = {"yes", "yep", "yup", "oui", "on", "y", "da"}
local no = {"no", "nope", "non", "off", "n", "net"}
local function convert_string(which)
  if contains(yes, which) or which == true then return true end
  if contains(no, which) or which == false then return false end

  return nil
end
toboolean = convert_string

function convert_boolean(which)
  if which == true then return "on"
  else return "off" end
end

-- this should also cache to prevent a lot of getLines() calls from the tekura function
-- warning, wrapped lines -will- be split up here
function find_until_last_paragraph (pattern, type)
  local t = getLines(lastpromptnumber, getLastLineNumber("main"))

  local find = string.find
  for i = 1, #t do
    local line = t[i]

    if type == "exact" and line == pattern then return true
    elseif type == "pattern" and find(line, pattern) then return true
    elseif type == "substring" and find(line, pattern, 1, true) then return true end
  end

  return false
end
local find_until_last_paragraph = find_until_last_paragraph

-- returns the count of matches from the current line until the start of the paragraph
function count_until_last_paragraph (pattern, type)
  local t = getLines(lastpromptnumber, getLastLineNumber("main"))

  local find, count = string.find, 0
  for i = 1, #t do
    local line = t[i]

    if type == "exact" and line == pattern then count = count + 1
    elseif type == "pattern" and find(line, pattern) then count = count + 1
    elseif type == "substring" and find(line, pattern, 1, true) then count = count + 1 end
  end

  return count
end

-- merge table2 into table1
update = function (t1, t2)
  for k,v in pairs(t2) do
    if type(v) == "table" then
      t1[k] = update(t1[k] or {}, v)
    else
      t1[k] = v
    end
  end
  return t1
end

-- assumes two table are of same length and does not recurse. Returns the value-key list of differences as the values are in t2
basictableindexdiff = function (t1, t2)
  local diff = {}
  -- have to use pairs to cover holes
  for k,v in pairs(t1) do
    if v ~= t2[k] then diff[#diff+1] = v end
  end
  for k,v in pairs(t2) do
    if v ~= t1[k] then diff[#diff+1] = v end
  end

  return diff
end

local function emptyphp(what)
  for _, _ in what:pairs() do
    return false
  end

  return true
end

oldsend = _G.send
local fancy_send_commands = {}

local function fancysend(what, store)
  if conf.batch then sendc(what); sk.systemscommands[what] = true else oldsend(what, false) end

  if (affs.seriousconcussion or (conf.doubledo and affs.stupidity)) and not sys.sync and not sys.sendonceonly then
    if conf.batch then sendc(what); sk.systemscommands[what] = true else oldsend(what, false) end
  end

  if conf.repeatcmd > 0 then
    for i = 1, conf.repeatcmd do
      if conf.batch then sendc(what); sk.systemscommands[what] = true else oldsend(what, false) end
    end
  end

  if not store then return end

  fancy_send_commands[#fancy_send_commands+1] = what
end

local function fancysendall()
  if #fancy_send_commands == 0 then return end

  if conf.commandechotype == "fancynewline" then echo'\n' end
  decho(string.format("<51,0,255>(<242,234,233>%s<51,0,255>)", table.concat(fancy_send_commands, "<102,98,97>|<242,234,233>")))
  fancy_send_commands = {}
end

-- check if we need to adjust parrying on any limbs or not
local function check_sp_satisfied()
  if sps.something_to_parry() then -- have we asked for any limbs to be parried?
    for name, limb in pairs(sp_config.parry_shouldbe) do
      if limb ~= sps.parry_currently[name] then
       sys.sp_satisfied = false; return
      end
    end
  elseif type(sp_config.parry) == "string" and sp_config.parry == "manual" then
    -- check if we need to unparry in manual
    for limb, status in pairs(sps.parry_currently) do
      if status ~= sp_config.parry_shouldbe[limb] then
       sys.sp_satisfied = false; return
      end
    end
  elseif sp_config.priority[1] and not sps.parry_currently[sp_config.priority[1]] then
    sp_config.parry_shouldbe[sp_config.priority[1]] = true
    sys.sp_satisfied = false; return
  end
  sys.sp_satisfied = true
end

sp_limbs = {
  head = true,
  torso = true,
  ["right arm"] = true,
  ["left arm"] = true,
  ["right leg"] = true,
  ["left leg"] = true
}


local yep = function ()
  return "<0,250,0>Yep" .. getDefaultColor()
end

local nope = function ()
  return "<250,0,0>Nope" .. getDefaultColor()
end

local red = function (what)
  return "<250,0,0>" .. what .. getDefaultColor()
end

local green = function (what)
  return "<0,250,0>" .. what .. getDefaultColor()
end

function sk.reverse(a)
  return (a:gsub("().", function (p)
    return a:sub(#a-p+1,#a-p+1);
  end))
end

function sk.anytoshort(exit)
  local t = {
    n = "north",
    e = "east",
    s = "south",
    w = "west",
    ne = "northeast",
    se = "southeast",
    sw = "southwest",
    nw = "northwest",
    u = "up",
    d = "down",
    ["in"] = "in",
    out = "out"
  }
  local rt = {}
  for s,l in pairs(t) do
    rt[l] = s; rt[s] = s
  end

  return rt[exit]
end

-- things line blind/deaf can be either afflictions or defences. This function is called whenever their status as a defence might change, and you have them - hence they need to be changed to a defence now or back
function sk.fix_affs_and_defs()
  if affs.blindaff and ((defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)
   ) then
    removeaff("blindaff")
    defences.got("blind")
    echof("blindness is now considered a defence.")
  elseif defc.blind and not ((defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)
   ) then
    defences.lost("blind")
    addaff(dict.blindaff)
    echof("blindness is now considered an affliction, will cure it.")
  end

  if affs.deafaff and ((defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye) then
    removeaff("deafaff")
    defences.got("deaf")
    echof("deafness is now considered a defence.")
  elseif defc.deaf and not ((defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye) then
    defences.lost("deaf")
    addaff(dict.deafaff)
    echof("deafness is now considered an affliction, will cure it.")
  end
end

-- rewielding
--[[
basis:
  we re-wield items only we know we had wielded, that we unwielded involuntarily

  received items.update - if it doesn't have an 'l' or an 'r' attribute, then it means we unwielded it, or picked it up, or whatever. So, check if we had it wielded - if we did, then this was unwielded. needs rewielding.

  received items.updateif it does have an 'l' or an 'r' attribute, remember this as wielded - save in mm.me.wielding_left or mm.me.wielding_right.
]]

signals.gmcpcharname:connect(function ()
  sendGMCP("Char.Items.Inv")
  send("\n")
end)

signals.gmcpcharitemslist:connect(function()
  -- catch what is wielded
  local t = gmcp.Char.Items.List
  if t.location ~= "inv" then return end

  me.wielded = {}

  for _, item in pairs(t.items) do
    if item.id and item.attrib then
      local lefthand, righthand = string.find(item.attrib, 'l', 1, true), string.find(item.attrib, 'L', 1, true)

      if (lefthand or righthand) then
        me.wielded[item.id] = deepcopy(item)

        if lefthand and righthand then
          me.wielded[item.id].hand = "both"
        elseif lefthand then
          me.wielded[item.id].hand = "left"
        else
          me.wielded[item.id].hand = "right"
        end
      end
    end
  end

  raiseEvent("svo me.wielded updated")
end)

function ceased_wielding(what)
  for itemid, item in pairs(me.wielded) do
    if item.name and item.name == what then
      me.wielded[itemid] = nil
      raiseEvent("svo me.wielded updated")
      return
    end
  end
end

function sk.checkrewield()
  local s,m = pcall(function()
    if paragraph_length > 1 and not find_until_last_paragraph("You cease to prop up a tall totem pole.", "exact") and not find_until_last_paragraph("You lob", "substring") and not lifevision.l.breath_gone and not find_until_last_paragraph("You begin to wield", "substring") then
      -- we wish to rewield wieldables!
      dict.rewield.rewieldables = deepcopy(sk.rewielddables)
      debugf("dict.rewield.rewieldables - %s", pl.pretty.write(dict.rewield.rewieldables))
      echof("Need to rewield %s%s!", tostring(dict.rewield.rewieldables[1].name), tostring(((dict.rewield.rewieldables[2] and dict.rewield.rewieldables[2].name) and (" and "..dict.rewield.rewieldables[2].name) or "")))
      -- echoLink("(info)", 'printCmdLine([[If the system decided that you\'ve unwielded out of the blue for no reason, copy/paste this in an submit a bug report with: '..pl.pretty.write(gmcp.Char.Items.Update):gsub("\n", " ")..']])', 'Click here if the system decided that you\'ve unwieled for no reason at all')
    end
  end)
  if not s then
    echoLink("(e!)", [[echo("The problem was: ']]..tostring(m)..[['")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end

  sk.rewielddables = nil
  signals.before_prompt_processing:disconnect(sk.checkrewield)
end

function unwielded(itemid, name)
  sk.rewielddables = sk.rewielddables or {}
  if not (sk.rewielddables[1] and sk.rewielddables[1].id == itemid) then
    sk.rewielddables[#sk.rewielddables+1] = {id = itemid, name = name}
  end

  if conf.autorewield then
    signals.before_prompt_processing:connect(sk.checkrewield)
  end

  me.wielded[itemid] = nil
  raiseEvent("svo me.wielded updated")
end

signals.gmcpcharitemsupdate:connect(
function ()
  local t = gmcp.Char.Items.Update

  if t.location ~= "inv" or type(me.wielded) ~= "table" then return end

  -- unwielded?
  if t.item.id and me.wielded[t.item.id] and t.item.name and (not t.item.attrib or (not string.find(t.item.attrib, 'l', 1, true) and not string.find(t.item.attrib, 'L', 1, true))) then
    unwielded(t.item.id, t.item.name)

  -- wielded? allow for a re-update on the wielding data as well
  elseif t.item.attrib and t.item.id and (string.find(t.item.attrib, 'l', 1, true) or string.find(t.item.attrib, 'L', 1, true)) then
    local lefthand, righthand = string.find(t.item.attrib, 'l', 1, true), string.find(t.item.attrib, 'L', 1, true)

    me.wielded[t.item.id] = deepcopy(t.item)

    if lefthand and righthand then
      me.wielded[t.item.id].hand = "both"
    elseif lefthand then
      me.wielded[t.item.id].hand = "left"
    else
      me.wielded[t.item.id].hand = "right"
    end

    checkaction(dict.rewield.physical)
    if actions.rewield_physical then
      lifevision.add(actions.rewield_physical.p, nil, t.item.id)
    end
    raiseEvent("svo me.wielded updated")
  end
end)

signals.gmcpcharitemsremove:connect(function ()
  local t = gmcp.Char.Items.Remove
  if t.location ~= "inv" or type(me.wielded) ~= "table" then return end
  local itemid = tostring(t.item.id)
  if me.wielded[itemid] then
    unwielded(itemid, me.wielded[itemid].name or "")
  end
end)

signals.gmcpcharitemsremove:connect(function ()
  sk.removed_something = true
  sk.onprompt_beforeaction_add("gmcpcharitemsremove", function ()
    sk.removed_something = nil
  end)
end)


function setdefaultprompt()
  config.set("customprompt", [[^1@healthh, ^2@manam, ^5@endurancee, ^4@willpowerw @promptstringorig@affs^W-]], false)
end

signals.enablegmcp:connect(function()
  sendGMCP([[Core.Supports.Add ["IRE.Time 1"] ]])
  sendGMCP("IRE.Time.Request")
end)

function setignore(k,v)
  -- default to true, use unsetignore to clear
  if v == nil then v = true end

  ignore[k] = v
  raiseEvent("svo ignore changed", k)
end

function unsetignore(k)
  ignore[k] = nil
  raiseEvent("svo ignore changed", k)
end

function setserverignore(k)
  serverignore[k] = true
  raiseEvent("svo serverignore changed", k)
end

function unsetserverignore(k)
  serverignore[k] = nil
  raiseEvent("svo serverignore changed", k)
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

local empty = {}




empty.eat_lobelia = function()
  lostbal_herb()

  if not affs.madness then
    removeaff({"claustrophobia","recklessness","agoraphobia","loneliness","masochism","vertigo","spiritdisrupt","airdisrupt","waterdisrupt","earthdisrupt","firedisrupt"})
  else
    removeaff({"claustrophobia","agoraphobia","vertigo","spiritdisrupt","airdisrupt","waterdisrupt","earthdisrupt","firedisrupt"})
  end

end
empty.eat_ash = function()
  lostbal_herb()

  if not affs.madness then
    removeaff({"hallucinations","hypersomnia","confusion","paranoia","dementia"})
  else
    removeaff({})
  end

end
empty.eat_bellwort = function()
  lostbal_herb()

  if not affs.madness then
    removeaff({"generosity","pacifism","justice","inlove","peace"})
  else
    removeaff({"generosity","pacifism","justice","inlove","peace"})
  end

end
empty.eat_goldenseal = function()
  lostbal_herb()

  if not affs.madness then
    removeaff({"dissonance","impatience","stupidity","dizziness","epilepsy","shyness"})
  else
    removeaff({"dissonance","dizziness","epilepsy","shyness"})
  end

end
empty.eat_kelp = function()
  lostbal_herb()

  if not affs.madness then
    removeaff({"asthma","hypochondria","healthleech","sensitivity","clumsiness","weakness"})
  else
    removeaff({"asthma","hypochondria","healthleech","sensitivity","clumsiness","weakness"})
  end

end
empty.eat_ginseng = function()
  lostbal_herb()

  if not affs.madness then
    removeaff({"haemophilia","darkshade","relapsing","addiction","illness","lethargy"})
  else
    removeaff({"haemophilia","darkshade","relapsing"})
  end

end

-- handle affs with madness separately

empty.eat_bloodroot = function()
  lostbal_herb()
  removeaff("paralysis")

  if not affs.stain then removeaff("slickness") end
end

empty.focus = function()
  if affs.madness then return end

  removeaff({"claustrophobia", "weakness", "masochism", "dizziness", "confusion", "stupidity", "generosity", "loneliness", "agoraphobia", "recklessness", "epilepsy", "pacifism", "anorexia", "shyness", "vertigo", "unknownmental", "airdisrupt", "earthdisrupt", "waterdisrupt", "firedisrupt"})
end

-- you /can/ cure hamstring, dissonance with tree
empty.treecurables = {"ablaze", "addiction", "aeon", "agoraphobia", "anorexia", "asthma", "blackout", "bleeding", "claustrophobia", "clumsiness", "confusion", "crippledleftarm", "crippledleftleg", "crippledrightarm", "crippledrightleg", "darkshade", "deadening", "dementia", "disloyalty", "disrupt", "dissonance", "dizziness", "epilepsy", "fear", "generosity", "haemophilia", "hallucinations", "healthleech",  "hellsight", "hypersomnia", "hypochondria", "illness", "impatience", "inlove", "itching", "justice", "lethargy", "loneliness", "madness", "masochism","pacifism", "paralysis", "paranoia", "peace", "recklessness", "relapsing", "selarnia", "sensitivity", "shyness", "slickness", "stupidity", "stuttering", "unknownany", "unknowncrippledarm", "unknowncrippledleg", "unknownmental", "vertigo", "voyria", "weakness", "hamstring", "shivering", "frozen", "skullfractures", "crackedribs", "wristfractures", "torntendons"}
empty.treecurableswithmadness = {"ablaze", "aeon", "agoraphobia", "anorexia", "asthma", "blackout", "bleeding", "claustrophobia", "clumsiness", "crippledleftarm", "crippledleftleg", "crippledrightarm", "crippledrightleg", "darkshade", "deadening", "disloyalty", "disrupt", "dissonance", "dizziness", "epilepsy", "fear", "generosity", "haemophilia", "healthleech",  "hellsight", "hypochondria", "inlove", "itching", "justice", "pacifism", "paralysis", "peace", "relapsing", "selarnia", "sensitivity", "shyness", "slickness", "stuttering", "unknownany", "unknowncrippledarm", "unknowncrippledleg", "unknownmental", "vertigo", "voyria", "weakness", "hamstring", "shivering", "frozen"}

-- expose publicly
treecurables = empty.treecurables
empty.tree = function ()
  if affs.madness then
    removeaff(empty.treecurableswithmadness)
  else
    removeaff(empty.treecurables)
  end
end

empty.dragonheal = empty.tree
-- this includes weakness - but if shrugging didn't cure anything, it still means we didn't have weakness as we can't use shrugging with weakness
empty.shrugging  = empty.tree

empty.smoke_elm = function()
  removeaff({"deadening", "madness", "aeon"})
end

empty.smoke_valerian = function()
  removeaff({"disloyalty", "manaleech", "slickness", "hellsight"})
end


empty.writhe = function()
  removeaff({"impale", "bound", "webbed", "roped", "transfixed", "hoisted"})
end

empty.apply_epidermal_head = function ()
  removeaff({"anorexia", "itching", "stuttering", "slashedthroat", "blindaff", "deafaff", "scalded"})
  defences.lost("blind")
  defences.lost("deaf")
end

empty.apply_epidermal_body = function ()
  removeaff({"anorexia", "itching"})
end

empty.apply_mending = function()
  dict.unknowncrippledlimb.count = 0
  dict.unknowncrippledarm.count = 0
  dict.unknowncrippledleg.count = 0
  removeaff({"selarnia", "crippledleftarm", "crippledleftleg", "crippledrightarm", "crippledrightleg", "ablaze", "severeburn", "extremeburn", "charredburn", "meltingburn", "unknowncrippledarm", "unknowncrippledleg", "unknowncrippledlimb"})
end

empty.noeffect_mending_arms = function()
  removeaff({"crippledrightarm", "crippledleftarm", "unknowncrippledarm"})
  dict.unknowncrippledarm.count = 0
end

empty.noeffect_mending_legs = function()
  removeaff({"crippledrightleg", "crippledleftleg", "unknowncrippledleg"})
  dict.unknowncrippledleg.count = 0
end

empty.apply_health_head = function()
  removeaff({"skullfractures"})
  dict.skullfractures.count = 0
end

empty.apply_health_torso = function()
  removeaff({"crackedribs"})
  dict.crackedribs.count = 0
end

empty.apply_health_arms = function()
  removeaff({"wristfractures"})
  dict.wristfractures.count = 0
end

empty.apply_health_legs = function()
  removeaff({"torntendons"})
  dict.torntendons.count = 0
end

empty.sip_immunity = function ()
  removeaff("voyria")
end

empty.eat_ginger = function ()
  removeaff({"cholerichumour", "melancholichumour", "phlegmatichumour", "sanguinehumour"})
  dict.cholerichumour.count = 0
  dict.melancholichumour.count = 0
  dict.phlegmatichumour.count = 0
  dict.sanguinehumour.count = 0
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

--[[
spriority: global async priority. In use when curing in sync mode.
aspriority: inter-balance sync priority. In use when curing in async mode.
isadvisable: determines if it is possible to cure this aff. some things that
  block bals might not block a single aff
]]



local dict_balanceful = {}
local dict_balanceless = {}


-- defence shortlists
local dict_balanceful_def = {}
local dict_balanceless_def = {}
local dict_herb = {}
local dict_misc = {}
local dict_misc_def = {}
local dict_purgative = {}
local dict_salve_def = {}
local dict_smoke_def = {}

local codepaste = {}


-- used to check if we're writhing from something already
--impale stacks below other writhes
codepaste.writhe = function()
  return (
    not doingaction("curingtransfixed") and not doingaction("transfixed") and
    not doingaction("curingimpale") and not doingaction("impale") and
    not doingaction("curingbound") and not doingaction("bound") and
    not doingaction("curingwebbed") and not doingaction("webbed") and
    not doingaction("curingroped") and not doingaction("roped") and
    not doingaction("curinghoisted") and not doingaction("hoisted") and
    not doingaction("dragonflex"))
end

-- gives a warning if we're having too many reaves
codepaste.checkreavekill = function()
  -- count up all humours, if three - warn of nearly, if four - warn of reaveability
  local c = 0
  if affs.cholerichumour then c = c + 1 end
  if affs.melancholichumour then c = c + 1 end
  if affs.phlegmatichumour then c = c + 1 end
  if affs.sanguinehumour then c = c + 1 end

  if c == 4 then
    sk.warn "reavable"
  elseif c == 3 then
    sk.warn "nearlyreavable"
  elseif c == 2 then
    sk.warn "somewhatreavable"
  end
end

codepaste.checkdismemberkill = function()
  if not enabledclasses.sentinel then return end

  if affs.bound and affs.impale then
    sk.warn "dismemberable"
  end
end

codepaste.badaeon = function()
  -- if we're in a poor aeon situation, warn to gtfo
  if not affs.aeon then return end

  local c = 0
  if affs.asthma then c = c + 1 end
  if affs.stupidity then c = c + 1 end
  if affs.voided then c = c + 1 end
  if affs.asthma and affs.anorexia then c = c + 1 end

  if c >= 1 then sk.warn "badaeon" end
end

codepaste.addrestobreakleg = function(aff, oldhp, tekura)
  local leg = aff:find("right") and "right" or "left"

  if not conf.aillusion or ((not oldhp or oldhp > stats.currenthealth) or paragraph_length >= 3 or (affs.recklessness and getStopWatchTime(affs[aff].sw) >= conf.ai_restoreckless))
    or (sk.tremoloside and sk.tremoloside[leg]) -- accept it when it was a tremolo hit that set us up for a break as well
  then

    -- clear sk.tremoloside for the leg, so tremolo later on can know when it /didn't/ break a leg
    if sk.tremoloside and sk.tremoloside[leg] then
      sk.tremoloside[leg] = nil
    end

    if not tekura then
      addaff(dict[aff])

    else
      if not sk.delaying_break then
        sk.delaying_break = tempTimer(getNetworkLatency() + conf.tekura_delay, function() -- from the first hit, it's approximately getNetworkLatency() time until the second - add the conf.tekura_delay to allow for variation in ping
          sk.delaying_break = nil

          for _, aff in ipairs(sk.tekura_mangles) do
            addaff(dict[aff])
          end
          sk.tekura_mangles = nil
          make_gnomes_work()
        end)
      end

      sk.tekura_mangles = sk.tekura_mangles or {}
      sk.tekura_mangles[#sk.tekura_mangles+1] = aff
    end
  end
end

codepaste.addrestobreakarm = function(aff, oldhp, tekura)
  if not conf.aillusion or ((not oldhp or oldhp > stats.currenthealth) or paragraph_length >= 3 or (affs.recklessness and getStopWatchTime(affs[aff].sw) >= conf.ai_restoreckless)) then

    if not tekura then
      addaff(dict[aff])
      signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      signals.canoutr:emit()

    else
      if not sk.delaying_break then
        sk.delaying_break = tempTimer(getNetworkLatency() + conf.tekura_delay, function() -- from the first hit, it's approximately getNetworkLatency() time until the second - add the conf.tekura_delay to allow for variation in ping
          sk.delaying_break = nil

          for _, aff in ipairs(sk.tekura_mangles) do
            addaff(dict[aff])
          end
          sk.tekura_mangles = nil

          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          signals.canoutr:emit()

          make_gnomes_work()
        end)
      end

      sk.tekura_mangles = sk.tekura_mangles or {}
      sk.tekura_mangles[#sk.tekura_mangles+1] = aff
    end

  end
end

codepaste.remove_focusable = function ()
  if not affs.unknownmental then return end
  affs.unknownmental.p.count = affs.unknownmental.p.count - 1
  if affs.unknownmental.p.count <= 0 then
    removeaff("unknownmental")
    dict.unknownmental.count = 0
  else
    updateaffcount(dict.unknownmental)
  end
end

-- keep argument is used when the aff is still on you
codepaste.remove_stackableaff = function (aff, keep)
  if not affs[aff] then return end
  dict[aff].count = dict[aff].count - 1

  if keep and dict[aff].count <= 0 then dict[aff].count = 1 end

  if dict[aff].count <= 0 then
    removeaff(aff)
    dict[aff].count = 0
  else
    updateaffcount(dict[aff])
  end
end

-- -> boolean
-- returns true if we're using some non-standard cure - tree, restore, class skill...
codepaste.nonstdcure = function()
  return (doingaction"touchtree" or doingaction"restore"
    )
end


codepaste.smoke_elm_pipe = function()
  if pipes.elm.id == 0 then sk.warn "noelmid" end
  if not (pipes.elm.lit or pipes.elm.arty) then
    sk.forcelight_elm = true
  end

  return (not (pipes.elm.id == 0) and
    (pipes.elm.lit or pipes.elm.arty) and
    -- can't smoke elm with inquisition and hellsight together
    not (affs.inquisition and affs.hellsight) and
    not (pipes.elm.puffs == 0))
end

codepaste.smoke_valerian_pipe = function()
  if pipes.valerian.id == 0 then sk.warn "novalerianid" end
  if not (pipes.valerian.lit or pipes.valerian.arty) then
    sk.forcelight_valerian = true
  end

  return (not (pipes.valerian.id == 0) and
    (pipes.valerian.lit or pipes.valerian.arty) and
    not (pipes.valerian.puffs == 0))
end

codepaste.smoke_skullcap_pipe = function()
  if pipes.skullcap.id == 0 then sk.warn "noskullcapid" end
  if not (pipes.skullcap.lit or pipes.skullcap.arty) then
    sk.forcelight_skullcap = true
  end

  return (not (pipes.skullcap.id == 0) and
    (pipes.skullcap.lit or pipes.skullcap.arty) and
    not (pipes.skullcap.puffs == 0))
end

codepaste.balanceful_defs_codepaste = function()
  for k,v in pairs(dict_balanceful_def) do
    if doingaction(k) then return true end
  end
end

-- adds the unknownany aff or increases the count by 1 or specified amount
codepaste.addunknownany = function(amount)
  local count = dict.unknownany.count
  addaff(dict.unknownany)

  dict.unknownany.count = (count or 0) + (amount or 1)
  updateaffcount(dict.unknownany)
end

sk.burns = {"ablaze", "severeburn", "extremeburn", "charredburn", "meltingburn"}
-- removes all burning afflictions except for the optional specified one
codepaste.remove_burns = function(skipaff)
  local burns = deepcopy(sk.burns)
  if skipaff then
    table.remove(burns, table.index_of(burns, skipaff))
  end

  removeaff(burns)
end

sk.next_burn = function()
  for i,v in ipairs(sk.burns) do
    if affs[v] then return sk.burns[i+1] or sk.burns[#sk.burns] end
  end
end

sk.current_burn = function()
  for i,v in ipairs(sk.burns) do
    if affs[v] then return v end
  end
end

sk.previous_burn = function(howfar)
  for i,v in ipairs(sk.burns) do
    if affs[v] then return sk.burns[i-(howfar and howfar or 1)] or nil end
  end
end

codepaste.serversideahealthmanaprio = function()
  local healhealth_prio = svo.prio.getnumber("healhealth", "sip")
  local healmana_prio   = svo.prio.getnumber("healmana"  , "sip")

  -- swap using curing system commands as appropriate
  -- setup special balance in cache mentioning which is first, so it is remembered
  sk.priochangecache.special = sk.priochangecache.special or { healthormana = ""}

  if healhealth_prio > healmana_prio and sk.priochangecache.special.healthormana ~= "health" then
    sendcuring("priority health")
    sk.priochangecache.special.healthormana = "health"
  elseif healmana_prio > healhealth_prio and sk.priochangecache.special.healthormana ~= "mana" then
    sendcuring("priority mana")
    sk.priochangecache.special.healthormana = "mana"
  end
end

--[[ dict is to NEVER be iterated over fully by prompt checks; so isadvisable functions can
      typically expect not to check for the common things because pre-
      filtering is done.
  ]]

dict = {
  gamename = nil, -- (string) what serverside calls this by - names can be different as they were revealed years after Svof was made
  onservereignore = nil, -- (function) a function which'll return true if this needs to be ignored serverside
  healhealth = {
    description = "heals health with health/vitality or moss/potash",
    sip = {
      name = false, --"healhealth_sip",
      balance = false, --"sip",
      action_name = false, --"healhealth"
      aspriority = 0,
      spriority = 0,

      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
        -- should healhealth be prioritised above health affs, don't apply if above healthaffsabove% and have an aff
        local function shouldntsip()
          local crackedribs    = prio.getnumber("crackedribs", "sip")
          local healhealth     = prio.getnumber("healhealth", "sip")
          local skullfractures = prio.getnumber("skullfractures", "sip")
          local torntendons    = prio.getnumber("torntendons", "sip")
          local wristfractures = prio.getnumber("wristfractures", "sip")

          if stats.hp >= conf.healthaffsabove and ((healhealth > crackedribs and affs.crackedribs) or (healhealth > skullfractures and affs.skullfractures) or (healhealth > torntendons and affs.torntendons) or (healhealth > wristfractures and affs.wristfractures)) then
            return true
          end

          return false
        end

        return ((stats.currenthealth < sys.siphealth or (sk.gettingfullstats and stats.currenthealth < stats.maxhealth)) and not actions.healhealth_sip and not shouldntsip())
      end,

      oncompleted = function ()
        lostbal_sip()
      end,

      noeffect = function()
        lostbal_sip()
      end,

      onprioswitch = function()
        codepaste.serversideahealthmanaprio()
      end,

      sipcure = {"health", "vitality"},

      onstart = function ()
        sip(dict.healhealth.sip)
      end
    },
    moss = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
        return ((stats.currenthealth < sys.mosshealth) and (not doingaction ("healhealth") or (stats.currenthealth < (sys.mosshealth-600)))) or false
      end,

      oncompleted = function ()
        lostbal_moss()
      end,

      noeffect = function()
        lostbal_moss()
      end,

      eatcure = {"irid", "potash"},
      actions = {"eat moss", "eat irid", "eat potash"},
      onstart = function ()
        eat(dict.healhealth.moss)
      end
    },
  },
  healmana = {
    description = "heals mana with mana/mentality or moss/potash",
    sip = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
        return ((stats.currentmana < sys.sipmana or (sk.gettingfullstats and stats.currentmana < stats.maxmana)) and not doingaction ("healmana")) or false
      end,

      oncompleted = function ()
        lostbal_sip()
      end,

      noeffect = function()
        lostbal_sip()
      end,

      onprioswitch = function()
        codepaste.serversideahealthmanaprio()
      end,

      sipcure = {"mana", "mentality"},

      onstart = function ()
        sip(dict.healmana.sip)
      end
    },
    moss = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
        return ((stats.currentmana < sys.mossmana) and (not doingaction ("healmana") or (stats.currentmana < (sys.mossmana-600)))) or false
      end,

      oncompleted = function ()
        lostbal_moss()
      end,

      noeffect = function()
        lostbal_moss()
      end,

      eatcure = {"irid", "potash"},
      actions = {"eat moss", "eat irid", "eat potash"},
      onstart = function ()
        eat(dict.healmana.moss)
      end
    },
  },
  skullfractures = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.skullfractures and stats.hp >= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        lostbal_sip()
        -- two counts are cured if you're above 5
        local howmany = dict.skullfractures.count
        codepaste.remove_stackableaff("skullfractures", true)
        if howmany > 5 then
          codepaste.remove_stackableaff("skullfractures", true)
        end
      end,

      cured = function()
        lostbal_sip()
        removeaff("skullfractures")
        dict.skullfractures.count = 0
      end,

      fizzled = function ()
        lostbal_sip()
        empty.apply_health_head()
      end,

      noeffect = function ()
        lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {"apply health to head"},
      onstart = function ()
        send("apply health to head", conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = dict.skullfractures.count
        addaff(dict.skullfractures)

        dict.skullfractures.count = (count or 0) + (number or 1)
        if dict.skullfractures.count > 7 then
          dict.skullfractures.count = 7
        end
        updateaffcount(dict.skullfractures)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("skullfractures")
        dict.skullfractures.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = dict.skullfractures.count
        for i = 1, (amount or 1) do
          codepaste.remove_stackableaff("skullfractures", not dontkeep)
        end
        if howmany > 5 then
          codepaste.remove_stackableaff("skullfractures", not dontkeep)
        end
      end,

      general_cured = function(amount)
        removeaff("skullfractures")
        dict.skullfractures.count = 0
      end,
    }
  },
  crackedribs = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crackedribs and stats.hp >= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        lostbal_sip()
        -- two counts are cured if you're above 5
        local howmany = dict.crackedribs.count
        codepaste.remove_stackableaff("crackedribs", true)
        if howmany > 5 then
          codepaste.remove_stackableaff("crackedribs", true)
        end
      end,

      cured = function()
        lostbal_sip()
        removeaff("crackedribs")
        dict.crackedribs.count = 0
      end,

      fizzled = function ()
        lostbal_sip()
        empty.apply_health_torso()
      end,

      noeffect = function ()
        lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {"apply health to torso"},
      onstart = function ()
        send("apply health to torso", conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = dict.crackedribs.count
        addaff(dict.crackedribs)

        dict.crackedribs.count = (count or 0) + (number or 1)
        if dict.crackedribs.count > 7 then
          dict.crackedribs.count = 7
        end
        updateaffcount(dict.crackedribs)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("crackedribs")
        dict.crackedribs.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = dict.crackedribs.count
        for i = 1, (amount or 1) do
          codepaste.remove_stackableaff("crackedribs", not dontkeep)
        end
        if howmany > 5 then
          codepaste.remove_stackableaff("crackedribs", not dontkeep)
        end
      end,

      general_cured = function(amount)
        removeaff("crackedribs")
        dict.crackedribs.count = 0
      end,
    }
  },
  wristfractures = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.wristfractures and stats.hp >= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        lostbal_sip()
        -- two counts are cured if you're above 5
        local howmany = dict.wristfractures.count
        codepaste.remove_stackableaff("wristfractures", true)
        if howmany > 5 then
          codepaste.remove_stackableaff("wristfractures", true)
        end
      end,

      cured = function()
        lostbal_sip()
        removeaff("wristfractures")
        dict.wristfractures.count = 0
      end,

      fizzled = function ()
        lostbal_sip()
        empty.apply_health_arms()
      end,

      noeffect = function ()
        lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {"apply health to arms"},
      onstart = function ()
        send("apply health to arms", conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = dict.wristfractures.count
        addaff(dict.wristfractures)

        dict.wristfractures.count = (count or 0) + (number or 1)
        if dict.wristfractures.count > 7 then
          dict.wristfractures.count = 7
        end
        updateaffcount(dict.wristfractures)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("wristfractures")
        dict.wristfractures.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = dict.wristfractures.count
        for i = 1, (amount or 1) do
          codepaste.remove_stackableaff("wristfractures", not dontkeep)
        end
        if howmany > 5 then
          codepaste.remove_stackableaff("wristfractures", not dontkeep)
        end
      end,

      general_cured = function(amount)
        removeaff("wristfractures")
        dict.wristfractures.count = 0
      end,
    }
  },
  torntendons = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.torntendons and stats.hp >= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        lostbal_sip()
                -- two counts are cured if you're above 5
        local howmany = dict.torntendons.count
        codepaste.remove_stackableaff("torntendons", true)
        if howmany > 5 then
          codepaste.remove_stackableaff("torntendons", true)
        end
      end,

      cured = function()
        lostbal_sip()
        removeaff("torntendons")
        dict.torntendons.count = 0
      end,

      fizzled = function ()
        lostbal_sip()
        empty.apply_health_legs()
      end,

      noeffect = function ()
        lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {"apply health to legs"},
      onstart = function ()
        send("apply health to legs", conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = dict.torntendons.count
        addaff(dict.torntendons)

        dict.torntendons.count = (count or 0) + (number or 1)
        if dict.torntendons.count > 7 then
          dict.torntendons.count = 7
        end
        updateaffcount(dict.torntendons)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("torntendons")
        dict.torntendons.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = dict.torntendons.count
        for i = 1, (amount or 1) do
          codepaste.remove_stackableaff("torntendons", not dontkeep)
        end
        if howmany > 5 then
          codepaste.remove_stackableaff("torntendons", not dontkeep)
        end
      end,

      general_cured = function(amount)
        removeaff("torntendons")
        dict.torntendons.count = 0
      end,
    }
  },
  cholerichumour = {
    gamename = "temperedcholeric",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.cholerichumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        lostbal_herb()
        codepaste.remove_stackableaff("cholerichumour", true)
      end,

      empty = function()
        empty.eat_ginger()
        lostbal_herb()
      end,

      cured = function()
        lostbal_herb()
        removeaff("cholerichumour")
        dict.cholerichumour.count = 0
      end,

      noeffect = function()
        lostbal_herb()
      end,

      -- does damage based on humour count
      inundated = function()
        removeaff("cholerichumour")
        dict.cholerichumour.count = 0
      end,

      eatcure = {"ginger", "antimony"},

      onstart = function ()
        eat(dict.cholerichumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = dict.cholerichumour.count
        addaff(dict.cholerichumour)

        dict.cholerichumour.count = (count or 0) + (number or 1)
        if dict.cholerichumour.count > 8 then
          dict.cholerichumour.count = 8
        end
        updateaffcount(dict.cholerichumour)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("cholerichumour")
        dict.cholerichumour.count = 0
      end
    }
  },
  melancholichumour = {
    gamename = "temperedmelancholic",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.melancholichumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        lostbal_herb()
        codepaste.remove_stackableaff("melancholichumour", true)
      end,

      empty = function()
        empty.eat_ginger()
        lostbal_herb()
      end,

      cured = function()
        lostbal_herb()
        removeaff("melancholichumour")
        dict.melancholichumour.count = 0
      end,

      noeffect = function()
        lostbal_herb()
      end,

      -- does mana damage based on humour count
      inundated = function()
        removeaff("melancholichumour")
        dict.melancholichumour.count = 0
      end,

      eatcure = {"ginger", "antimony"},

      onstart = function ()
        eat(dict.melancholichumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = dict.melancholichumour.count
        addaff(dict.melancholichumour)

        dict.melancholichumour.count = (count or 0) + (number or 1)
        if dict.melancholichumour.count > 8 then
          dict.melancholichumour.count = 8
        end
        updateaffcount(dict.melancholichumour)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("melancholichumour")
        dict.melancholichumour.count = 0
      end
    }
  },
  phlegmatichumour = {
    gamename = "temperedphlegmatic",
    count = 0,
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.phlegmatichumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        lostbal_herb()
        codepaste.remove_stackableaff("phlegmatichumour", true)
      end,

      empty = function()
        empty.eat_ginger()
        lostbal_herb()
      end,

      cured = function()
        lostbal_herb()
        removeaff("phlegmatichumour")
        dict.phlegmatichumour.count = 0
      end,

      noeffect = function()
        lostbal_herb()
      end,

      -- gives various afflictions, amount of which depends on your humour level
      --[[
        slickness always seems to happen
        1-2: add 1 unknown
        3-6: add 2 unknowns
        7-9: add 3 unknowns
        10: add 4 unknowns

        anorexia 50% time
        slickness 8+
      ]]
      inundated = function()
        addaff(dict.slickness)

        if dict.phlegmatichumour.count >= 3 and math.random(1,2) == 1 then
          addaff(dict.anorexia)
        end

        if dict.phlegmatichumour.count == 8 then
          codepaste.addunknownany(4)
        elseif dict.phlegmatichumour.count >= 6 then
          codepaste.addunknownany(3)
        elseif dict.phlegmatichumour.count >= 4 then
          codepaste.addunknownany(2)
        else
          codepaste.addunknownany(1)
        end

        removeaff("phlegmatichumour")
        dict.phlegmatichumour.count = 0
      end,

      eatcure = {"ginger", "antimony"},

      onstart = function ()
        eat(dict.phlegmatichumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = dict.phlegmatichumour.count
        addaff(dict.phlegmatichumour)

        dict.phlegmatichumour.count = (count or 0) + (number or 1)
        if dict.phlegmatichumour.count > 8 then
          dict.phlegmatichumour.count = 8
        end
        updateaffcount(dict.phlegmatichumour)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("phlegmatichumour")
        dict.phlegmatichumour.count = 0
      end
    }
  },
  sanguinehumour = {
    gamename = "temperedphlegmatic",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.sanguinehumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        lostbal_herb()
        codepaste.remove_stackableaff("sanguinehumour", true)
      end,

      empty = function()
        empty.eat_ginger()
        lostbal_herb()
      end,

      cured = function()
        lostbal_herb()
        removeaff("sanguinehumour")
        dict.sanguinehumour.count = 0
      end,

      noeffect = function()
        lostbal_herb()
      end,

      -- gives bleeding depending on your sanguine humour level, from 250 for first to 2500 for last
      inundated = function()
        local min, max = 250, 2500
        if not affs.sanguinehumour then return end

        local bledfor = dict.sanguinehumour.count * min

        addaff(dict.bleeding)
        dict.bleeding.count = bledfor
        updateaffcount(dict.bleeding)

        removeaff("sanguinehumour")
        dict.sanguinehumour.count = 0
      end,

      eatcure = {"ginger", "antimony"},

      onstart = function ()
        eat(dict.sanguinehumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = dict.sanguinehumour.count
        addaff(dict.sanguinehumour)

        dict.sanguinehumour.count = (count or 0) + (number or 1)
        if dict.sanguinehumour.count > 8 then
          dict.sanguinehumour.count = 8
        end
        updateaffcount(dict.sanguinehumour)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("sanguinehumour")
        dict.sanguinehumour.count = 0
      end
    }
  },
  waterbubble = {
    gamename = "airpocket",
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,
      -- not handled by serverside
      undeffable = true,

      isadvisable = function ()
        return false
      end,

      eatcure = {"pear", "calcite"},

      onstart = function ()
        eat(dict.waterbubble.herb)
      end,

      oncompleted = function ()
      end,

      empty = function()
      end
    }
  },
  pacifism = {
    gamename = "pacified",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.pacifism and
          not doingaction("pacifism")
        ) or false
      end,

      oncompleted = function ()
        removeaff("pacifism")
        lostbal_herb()
      end,

      eatcure = {"bellwort", "cuprum"},
      onstart = function ()
        eat(dict.pacifism.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.pacifism and
          not doingaction("pacifism")
        ) or false
      end,

      oncompleted = function ()
        removeaff("pacifism")
        lostbal_focus()
      end,

      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.pacifism)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("pacifism")
        codepaste.remove_focusable()
      end,
    }
  },
  peace = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.peace
        ) or false
      end,

      oncompleted = function ()
        removeaff("peace")
        lostbal_herb()
      end,

      eatcure = {"bellwort", "cuprum"},
      onstart = function ()
        eat(dict.peace.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.peace)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("peace")
      end,
    }
  },
  inlove = {
    gamename = "lovers",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.inlove
        ) or false
      end,

      oncompleted = function ()
        removeaff("inlove")
        lostbal_herb()
      end,

      eatcure = {"bellwort", "cuprum"},
      onstart = function ()
        eat(dict.inlove.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.inlove)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("inlove")
      end,
    }
  },
  dissonance = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dissonance and not usingbal("focus")) or false
      end,

      oncompleted = function ()
        removeaff("dissonance")
        lostbal_herb()
      end,

      eatcure = {"goldenseal", "plumbum"},
      onstart = function ()
        eat(dict.dissonance.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.dissonance)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("dissonance")
      end,
    }
  },
  dizziness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dizziness and
          not doingaction("dizziness") and not usingbal("focus")) or false
      end,

      oncompleted = function ()
        removeaff("dizziness")
        lostbal_herb()
      end,

      eatcure = {"goldenseal", "plumbum"},
      onstart = function ()
        eat(dict.dizziness.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dizziness and
          not doingaction("dizziness")) or false
      end,

      oncompleted = function ()
        removeaff("dizziness")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.dizziness)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("dizziness")
        codepaste.remove_focusable()
      end,
    }
  },
  shyness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.shyness and
          not doingaction("shyness") and not usingbal("focus")) or false
      end,

      oncompleted = function ()
        removeaff("shyness")
        lostbal_herb()
      end,

      eatcure = {"goldenseal", "plumbum"},
      onstart = function ()
        eat(dict.shyness.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.shyness and
          not doingaction("shyness")) or false
      end,

      oncompleted = function ()
        removeaff("shyness")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.shyness)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("shyness")
        codepaste.remove_focusable()
      end,
    }
  },
  epilepsy = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.epilepsy and
          not doingaction("epilepsy") and not usingbal("focus")) or false
      end,

      oncompleted = function ()
        removeaff("epilepsy")
        lostbal_herb()
      end,

      eatcure = {"goldenseal", "plumbum"},
      onstart = function ()
        eat(dict.epilepsy.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.epilepsy and
          not doingaction("epilepsy")) or false
      end,

      oncompleted = function ()
        removeaff("epilepsy")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.epilepsy)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("epilepsy")
        codepaste.remove_focusable()
      end,
    }
  },
  impatience = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing impatience before hypochondria will make it get re-applied
        return (affs.impatience and not affs.madness and not usingbal("focus")  and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        removeaff("impatience")
        lostbal_herb()

        -- if serverside cures impatience before we can even validate it, cancel it
        affsp.impatience = nil
        killaction (dict.checkimpatience.misc)
      end,

      eatcure = {"goldenseal", "plumbum"},
      onstart = function ()
        eat(dict.impatience.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.impatience)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("impatience")
      end,
    }
  },
  stupidity = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.stupidity and
          not doingaction("stupidity") and not usingbal("focus")) or false
      end,

      oncompleted = function ()
        removeaff("stupidity")
        lostbal_herb()
      end,

      eatcure = {"goldenseal", "plumbum"},
      onstart = function ()
        eat(dict.stupidity.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.stupidity and
          not doingaction("stupidity") and not affs.madness) or false
      end,

      oncompleted = function ()
        removeaff("stupidity")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.stupidity)
        sk.stupidity_count = 0
        codepaste.badaeon()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("stupidity")
        codepaste.remove_focusable()
      end,
    }
  },
  masochism = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.masochism and not affs.madness and
          not doingaction("masochism")) or false
      end,

      oncompleted = function ()
        removeaff("masochism")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.masochism.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.masochism and not affs.madness and
          not doingaction("masochism")) or false
      end,

      oncompleted = function ()
        removeaff("masochism")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.masochism)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("masochism")
        codepaste.remove_focusable()
      end,
    }
  },
  recklessness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.recklessness and not affs.madness and
          not doingaction("recklessness")) or false
      end,

      oncompleted = function ()
        removeaff("recklessness")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.recklessness.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.recklessness and not affs.madness and
          not doingaction("recklessness")) or false
      end,

      oncompleted = function ()
        removeaff("recklessness")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function (data)
        if data and data.attacktype and data.attacktype == "domination" and (data.atline+1 == getLastLineNumber("main") or (data.atline+1 == getLastLineNumber("main") and find_until_last_paragraph("The gremlin races between your legs, throwing you off-balance.", "exact"))) then
          addaff(dict.recklessness)
        elseif not conf.aillusion or (stats.maxhealth == stats.currenthealth and stats.maxmana == stats.currentmana) then
          addaff(dict.recklessness)
        end
      end,

      -- used for addaff to skip all checks
      forced = function ()
        addaff(dict.recklessness)
      end
    },
    gone = {
      oncompleted = function()
        removeaff("recklessness")
        codepaste.remove_focusable()
      end,
    },
    onremoved = function ()
      check_generics()
      if not affs.blackout then
        killaction (dict.nomana.waitingfor)
      end
      signals.before_prompt_processing:block(valid.check_recklessness)
    end,
    onadded = function()
      signals.before_prompt_processing:unblock(valid.check_recklessness)
    end,
  },
  justice = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.justice
        ) or false
      end,

      oncompleted = function ()
        removeaff("justice")
        lostbal_herb()
      end,

      eatcure = {"bellwort", "cuprum"},
      onstart = function ()
        eat(dict.justice.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.justice)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("justice")
      end,
    }
  },
  generosity = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.generosity and
          not doingaction("generosity")
        ) or false
      end,

      oncompleted = function ()
        removeaff("generosity")
        lostbal_herb()
      end,

      eatcure = {"bellwort", "cuprum"},
      onstart = function ()
        eat(dict.generosity.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.generosity and
          not doingaction("generosity")
        ) or false
      end,

      oncompleted = function ()
        removeaff("generosity")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.generosity)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("generosity")
        codepaste.remove_focusable()
      end,
    }
  },
  weakness = {
    gamename = "weariness",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.weakness and
          not doingaction("weakness")) or false
      end,

      oncompleted = function ()
        removeaff("weakness")
        lostbal_herb()
      end,

      eatcure = {"kelp", "aurum"},
      onstart = function ()
        eat(dict.weakness.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.weakness and
          not doingaction("weakness")) or false
      end,

      oncompleted = function ()
        removeaff("weakness")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.weakness)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("weakness")
        codepaste.remove_focusable()
      end,
    }
  },
  vertigo = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.vertigo and
          not doingaction("vertigo")) or false
      end,

      oncompleted = function ()
        removeaff("vertigo")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.vertigo.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.vertigo and
          not doingaction("vertigo")) or false
      end,

      oncompleted = function ()
        removeaff("vertigo")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.vertigo)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("vertigo")
        codepaste.remove_focusable()
      end,
    }
  },
  loneliness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.loneliness and not affs.madness and not doingaction("loneliness")) or false
      end,

      oncompleted = function ()
        removeaff("loneliness")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.loneliness.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.loneliness and not affs.madness and not doingaction("loneliness")) or false
      end,

      oncompleted = function ()
        removeaff("loneliness")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.loneliness)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("loneliness")
        codepaste.remove_focusable()
      end,
    }
  },
  dementia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dementia and not affs.madness) or false
      end,

      oncompleted = function ()
        removeaff("dementia")
        lostbal_herb()
      end,

      eatcure = {"ash", "stannum"},
      onstart = function ()
        eat(dict.dementia.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.dementia)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("dementia")
      end,
    }
  },
  paranoia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.paranoia and not affs.madness) or false
      end,

      oncompleted = function ()
        removeaff("paranoia")
        lostbal_herb()
      end,

      eatcure = {"ash", "stannum"},
      onstart = function ()
        eat(dict.paranoia.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.paranoia)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("paranoia")
      end,
    }
  },
  hypersomnia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hypersomnia and not affs.madness) or false
      end,

      oncompleted = function ()
        removeaff("hypersomnia")
        lostbal_herb()
      end,

      eatcure = {"ash", "stannum"},
      onstart = function ()
        eat(dict.hypersomnia.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hypersomnia)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("hypersomnia")
      end,
    }
  },
  hallucinations = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hallucinations and not affs.madness) or false
      end,

      oncompleted = function ()
        removeaff("hallucinations")
        lostbal_herb()
      end,

      eatcure = {"ash", "stannum"},
      onstart = function ()
        eat(dict.hallucinations.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hallucinations)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("hallucinations")
      end,
    }
  },
  confusion = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.confusion and
          not doingaction("confusion") and not affs.madness) or false
      end,

      oncompleted = function ()
        removeaff("confusion")
        lostbal_herb()
      end,

      eatcure = {"ash", "stannum"},
      onstart = function ()
        eat(dict.confusion.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.confusion and
          not doingaction("confusion") and not affs.madness) or false
      end,

      oncompleted = function ()
        removeaff("confusion")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.confusion)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("confusion")
        codepaste.remove_focusable()
      end,
    }
  },
  agoraphobia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.agoraphobia and
          not doingaction("agoraphobia")) or false
      end,

      oncompleted = function ()
        removeaff("agoraphobia")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.agoraphobia.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.agoraphobia and
          not doingaction("agoraphobia")) or false
      end,

      oncompleted = function ()
        removeaff("agoraphobia")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.agoraphobia)
        codepaste.remove_focusable()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("agoraphobia")
      end,
    }
  },
  claustrophobia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.claustrophobia and
          not doingaction("claustrophobia")) or false
      end,

      oncompleted = function ()
        removeaff("claustrophobia")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.claustrophobia.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.claustrophobia and
          not doingaction("claustrophobia")) or false
      end,

      oncompleted = function ()
        removeaff("claustrophobia")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.claustrophobia)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("claustrophobia")
        codepaste.remove_focusable()
      end,
    }
  },
  paralysis = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.paralysis) or false
      end,

      oncompleted = function ()
        removeaff("paralysis")
        lostbal_herb()
        killaction(dict.checkparalysis.misc)
      end,

      eatcure = {"bloodroot", "magnesium"},
      onstart = function ()
        eat(dict.paralysis.herb)
      end,

      empty = function()
        empty.eat_bloodroot()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.paralysis)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("paralysis")
      end,
    },
    onremoved = function () affsp.paralysis = nil donext() end
  },
  asthma = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.asthma) or false
      end,

      oncompleted = function ()
        removeaff("asthma")
        lostbal_herb()
      end,

      eatcure = {"kelp", "aurum"},
      onstart = function ()
        eat(dict.asthma.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.asthma)
        local r = findbybal("smoke")
        if r then
          killaction(dict[r.action_name].smoke)
        end

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        codepaste.badaeon()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("asthma")
      end,
    }
  },
  clumsiness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.clumsiness) or false
      end,

      oncompleted = function ()
        removeaff("clumsiness")
        lostbal_herb()
      end,

      eatcure = {"kelp", "aurum"},
      onstart = function ()
        eat(dict.clumsiness.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.clumsiness)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("clumsiness")
      end,
    }
  },
  sensitivity = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.sensitivity) or false
      end,

      oncompleted = function ()
        removeaff("sensitivity")
        lostbal_herb()
      end,

      eatcure = {"kelp", "aurum"},
      onstart = function ()
        eat(dict.sensitivity.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.sensitivity)
      end,

      -- used by AI to check if we're deaf when we got sensi
      checkdeaf = function()
        -- if deafness was stripped, then prompt flags would have removed it at this point and defc.deaf wouldn't be set
        -- also check back to see if deafness went instead, like from bloodleech:
        -- A bloodleech leaps at you, clamping with teeth onto exposed flesh and secreting some foul toxin into your bloodstream. You stumble as you are afflicted with sensitivity.$Your hearing is suddenly restored.
        -- or dragoncurse: A sudden sense of panic overtakes you as the draconic curse manifests, afflicting you with sensitivity.$Your hearing is suddenly restored.
        -- however, don't go off on dstab: Bob pricks you twice in rapid succession with her dirk.$Your hearing is suddenly restored.$A prickly, stinging sensation spreads through your body.
        if find_until_last_paragraph("Your hearing is suddenly restored.", "exact") and not find_until_last_paragraph("A prickly, stinging sensation spreads through your body.", "exact") then return end

        if not conf.aillusion or (not defc.deaf and not affs.deafaff) then
          addaff(dict.sensitivity)
        end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("sensitivity")
      end,
    }
  },
  healthleech = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.healthleech) or false
      end,

      oncompleted = function ()
        removeaff("healthleech")
        lostbal_herb()
      end,

      eatcure = {"kelp", "aurum"},
      onstart = function ()
        eat(dict.healthleech.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.healthleech)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("healthleech")
      end,
    }
  },
  relapsing = {
    -- if it's an aff that can be checked, remove it's action and add an appropriate checkaff. Then if the checkaff succeeds, add the relapsing too.
    saw_with_checkable = false,
    gamename = "scytherus",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.relapsing) or false
      end,

      oncompleted = function ()
        removeaff("relapsing")
        lostbal_herb()
      end,

      eatcure = {"ginseng", "ferrum"},
      onstart = function ()
        eat(dict.relapsing.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    --[[
      relapsing:  ai off, accept everything
                  ai on, accept everything only if we do have relapsing, or it's a checkable symptom -> undeaf/unblind, blind/deaf, camus, else -> ignore

      implementation: generic affs get called to aff.oncompleted, otherwise specialities deal with aff.<func>
    ]]
    aff = {
      -- this goes off when there is no AI or we got a generic affliction that doesn't mean much
      oncompleted = function ()
        -- don't mess with anything special if we have it confirmed
        if affs.relapsing then return end

        if not conf.aillusion or lifevision.l.diag_physical then
          addaff(dict.relapsing)
          dict.relapsing.saw_with_checkable = nil
        else
          if actions.checkparalysis_aff then
            dict.relapsing.saw_with_checkable = "paralysis"
          elseif not pl.tablex.find_if(actions:keys(), function (key) return string.find(key, "check", 1, true) end) then
            -- don't process the rest of the affs it gives if it's not checkable and we don't have relapsing already
            sk.stopprocessing = true
          end
        end
        dict.relapsing.aff.hitvitality = nil
      end,

      forced = function ()
        addaff(dict.relapsing)
      end,

      camus = function (oldhp)
        if not conf.aillusion or
          ((not affs.recklessness and stats.currenthealth < oldhp) -- health went down without recklessness
           or (dict.relapsing.aff.hitvitality and ((100/stats.maxhealth)* stats.currenthealth) <= 60)) then -- or we're above due to vitality
          addaff(dict.relapsing)
          dict.relapsing.aff.hitvitality = nil
          dict.relapsing.saw_with_checkable = nil
        end
      end,

      sumac = function (oldhp)
        if not conf.aillusion or
          ((not affs.recklessness and stats.currenthealth < oldhp) -- health went down without recklessness
           or (dict.relapsing.aff.hitvitality and ((100/stats.maxhealth)* stats.currenthealth) <= 60)) then -- or we're above due to vitality
          addaff(dict.relapsing)
          dict.relapsing.aff.hitvitality = nil
          dict.relapsing.saw_with_checkable = nil
        end
      end,

      oleander = function (hadblind)
        if not conf.aillusion or (not hadblind and (defc.blind or affs.blindaff)) then
          addaff(dict.relapsing)
          dict.relapsing.saw_with_checkable = nil
        end
      end,

      colocasia = function (hadblindordeaf)
        if not conf.aillusion or (not hadblindordeaf and (defc.blind or affs.blindaff or defc.deaf or deafaff)) then
          addaff(dict.relapsing)
          dict.relapsing.saw_with_checkable = nil
        end
      end,

      oculus = function (hadblind)
        if not conf.aillusion or (hadblind and not (defc.blind or affs.blindaff)) then
          addaff(dict.relapsing)
          dict.relapsing.saw_with_checkable = nil
        end
      end,

      prefarar = function (haddeaf)
        if not conf.aillusion or (haddeaf and not (defc.deaf or affs.deafaff)) then
          addaff(dict.relapsing)
          dict.relapsing.saw_with_checkable = nil
        end
      end,

      asthma = function ()
        if not conf.aillusion or lifevision.l.diag_physical then
          addaff(dict.relapsing)
          dict.relapsing.saw_with_checkable = nil
        else
          if actions.checkasthma_aff then
            dict.relapsing.saw_with_checkable = "asthma"
          elseif not pl.tablex.find_if(actions:keys(), function (key) return string.find(key, "check", 1, true) end) then
            -- don't process the rest of the affs it gives.
            sk.stopprocessing = true
          end
        end
        dict.relapsing.aff.hitvitality = nil
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("relapsing")
        dict.relapsing.saw_with_checkable = nil
      end,
    }
  },
  darkshade = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.darkshade) or false
      end,

      oncompleted = function ()
        removeaff("darkshade")
        lostbal_herb()
      end,

      eatcure = {"ginseng", "ferrum"},
      onstart = function ()
        eat(dict.darkshade.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or (not oldhp or stats.currenthealth < oldhp) then
          addaff(dict.darkshade)
        end
      end,

      forced = function ()
        addaff(dict.darkshade)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("darkshade")
      end,
    }
  },
  lethargy = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing lethargy before hypochondria or torntendons will make it get re-applied
        return (affs.lethargy and not affs.madness and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        removeaff("lethargy")
        lostbal_herb()
      end,

      eatcure = {"ginseng", "ferrum"},
      onstart = function ()
        eat(dict.lethargy.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.lethargy)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("lethargy")
      end,
    }
  },
  illness = {
    gamename = "nausea",
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing illness before hypochondria will make it get re-applied
        return (affs.illness and not affs.madness and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        removeaff("illness")
        lostbal_herb()
      end,

      eatcure = {"ginseng", "ferrum"},
      onstart = function ()
        eat(dict.illness.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        if not find_until_last_paragraph("Your enhanced constitution allows you to shrug off the nausea.", "exact") then
          addaff(dict.illness)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("illness")
      end,
    }
  },
  addiction = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing addiction before hypochondria or skullfractures will make it get re-applied
        return (affs.addiction and not affs.madness and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        removeaff("addiction")
        lostbal_herb()
      end,

      eatcure = {"ginseng", "ferrum"},
      onstart = function ()
        eat(dict.addiction.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.addiction)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("addiction")
      end,
    },
    onremoved = function ()
      rift.checkprecache()
    end
  },
  haemophilia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.haemophilia) or false
      end,

      oncompleted = function ()
        removeaff("haemophilia")
        lostbal_herb()
      end,

      eatcure = {"ginseng", "ferrum"},
      onstart = function ()
        eat(dict.haemophilia.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.haemophilia)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("haemophilia")
      end,
    }
  },
  hypochondria = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hypochondria) or false
      end,

      oncompleted = function ()
        removeaff("hypochondria")
        lostbal_herb()
      end,

      eatcure = {"kelp", "aurum"},
      onstart = function ()
        eat(dict.hypochondria.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hypochondria)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("hypochondria")
      end,
    }
  },

-- smoke cures
  aeon = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.aeon and codepaste.smoke_elm_pipe()) or false
      end,

      oncompleted = function ()
        removeaff("aeon")
        lostbal_smoke()
        sk.elm_smokepuff()
      end,

      smokecure = {"elm", "cinnabar"},
      onstart = function ()
        send("smoke " .. pipes.elm.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_elm()
        lostbal_smoke()
        sk.elm_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.aeon)
        affsp.aeon = nil
        defences.lost("speed")
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        sk.checkaeony()
        signals.aeony:emit()
        codepaste.badaeon()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("aeon")
      end,
    },
    onremoved = function ()
      affsp.aeon = nil
      sk.retardation_count = 0
      sk.checkaeony()
      signals.aeony:emit()
    end
  },
  hellsight = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hellsight and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        removeaff("hellsight")
        lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {"valerian", "realgar"},
      onstart = function ()
        send("smoke " .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      inquisition = function ()
        addaff(dict.inquisition)
        sk.valerian_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hellsight)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("hellsight")
      end,
    }
  },
  deadening = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.deadening and codepaste.smoke_elm_pipe()) or false
      end,

      oncompleted = function ()
        removeaff("deadening")
        lostbal_smoke()
        sk.elm_smokepuff()
      end,

      smokecure = {"elm", "cinnabar"},
      onstart = function ()
        send("smoke " .. pipes.elm.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_elm()
        lostbal_smoke()
        sk.elm_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.deadening)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("deadening")
      end,
    }
  },
  madness = {
    gamename = "whisperingmadness",
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.madness and codepaste.smoke_elm_pipe() and not affs.hecate) or false
      end,

      oncompleted = function ()
        removeaff("madness")
        lostbal_smoke()
        sk.elm_smokepuff()
      end,

      smokecure = {"elm", "cinnabar"},
      onstart = function ()
        send("smoke " .. pipes.elm.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_elm()
        lostbal_smoke()
        sk.elm_smokepuff()
      end,

      hecate = function()
        sk.elm_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.madness)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("madness")
      end,
    }
  },
  -- valerian cures
  slickness = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.slickness and codepaste.smoke_valerian_pipe() and not doingaction"slickness") or false
      end,

      oncompleted = function ()
        removeaff("slickness")
        lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {"valerian", "realgar"},
      onstart = function ()
        send("smoke " .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        lostbal_smoke()
        sk.valerian_smokepuff()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.slickness and not affs.anorexia and not doingaction"slickness" and not affs.stain) or false -- anorexia is redundant, but just in for now
      end,

      oncompleted = function ()
        removeaff("slickness")
        lostbal_herb()
      end,

      eatcure = {"bloodroot", "magnesium"},
      onstart = function ()
        eat(dict.slickness.herb)
      end,

      empty = function()
        empty.eat_bloodroot()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.slickness)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("slickness")
      end,
    }
  },
  disloyalty = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.disloyalty and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        removeaff("disloyalty")
        lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {"valerian", "realgar"},
      onstart = function ()
        send("smoke " .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        lostbal_smoke()
        sk.valerian_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.disloyalty)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("disloyalty")
      end,
    }
  },
  manaleech = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.manaleech and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        removeaff("manaleech")
        lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {"valerian", "realgar"},
      onstart = function ()
        send("smoke " .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        lostbal_smoke()
        sk.valerian_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.manaleech)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("manaleech")
      end,
    }
  },


  -- restoration cures
  heartseed = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.heartseed and not affs.mildtrauma) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingheartseed.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to torso", "apply restoration", "apply reconstructive to torso", "apply reconstructive"},
      onstart = function ()
        apply(dict.heartseed.salve, " to torso")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.heartseed.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.heartseed)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("heartseed")
      end,
    }
  },
  curingheartseed = {
    spriority = 0,
    waitingfor = {
      customwait = 6, -- 4 to cure

      oncompleted = function ()
        removeaff("heartseed")
      end,

      ontimeout = function ()
        removeaff("heartseed")
      end,

      noeffect = function ()
        removeaff("heartseed")
      end,

      onstart = function ()
    -- add blocking of the cure coming too early if it'll become necessary.
      end,
    }
  },
  hypothermia = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hypothermia and not affs.mildtrauma) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curinghypothermia.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to torso", "apply restoration", "apply reconstructive to torso", "apply reconstructive"},
      onstart = function ()
        apply(dict.hypothermia.salve, " to torso")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.hypothermia.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hypothermia)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("hypothermia")
      end,
    }
  },
  curinghypothermia = {
    spriority = 0,
    waitingfor = {
      customwait = 6, -- 4 to cure

      oncompleted = function ()
        removeaff("hypothermia")
      end,

      ontimeout = function ()
        removeaff("hypothermia")
      end,

      noeffect = function ()
        removeaff("hypothermia")
      end,

      onstart = function ()
        -- add blocking of the cure coming too early if it'll become necessary.
      end,
    }
  },

  mutilatedrightleg = {
    gamename = "mangledrightleg",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedrightleg) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmutilatedrightleg.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to legs", "apply restoration", "apply reconstructive to legs", "apply reconstructive"},
      onstart = function ()
        apply(dict.mutilatedrightleg.salve, " to legs")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mutilatedrightleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          dict.mutilatedrightleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg("mutilatedrightleg", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg("mutilatedrightleg", oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mutilatedrightleg")
      end,
    }
  },
  curingmutilatedrightleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("mutilatedrightleg")
        addaff(dict.mangledrightleg)

        local result = checkany(dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedrightleg then
          removeaff("mutilatedrightleg")
          addaff(dict.mangledrightleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mutilatedrightleg")
        addaff(dict.mangledrightleg)
      end,

      noeffect = function ()
        removeaff("mutilatedrightleg")
      end
    }
  },
  parestolegs = {
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      customwaitf = function()
        return not affs.blackout and 0 or 4 -- can't see applies in blackout
      end,

      isadvisable = function ()
        return (affs.parestolegs) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingparestolegs.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to legs", "apply restoration", "apply reconstructive to legs", "apply reconstructive"},
      onstart = function ()
        apply(dict.parestolegs.salve, " to legs")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.parestolegs.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.parestolegs)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("parestolegs")
      end,
    }
  },
  curingparestolegs = {
    waitingfor = {
      customwait = 4,

      oncompleted = function ()
        removeaff("parestolegs")

        local result = checkany(dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      onstart = function ()
      end,

      ontimeout = function ()
        removeaff("parestolegs")
      end,

      noeffect = function ()
        removeaff("parestolegs")
      end
    }
  },
  mangledrightleg = {
    gamename = "damagedrightleg",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledrightleg and not (affs.mutilatedrightleg or affs.mutilatedleftleg)) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmangledrightleg.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to legs", "apply restoration", "apply reconstructive to legs", "apply reconstructive"},
      onstart = function ()
        apply(dict.mangledrightleg.salve, " to legs")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mangledrightleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          dict.mangledrightleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg("mangledrightleg", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg("mangledrightleg", oldhp, true)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("mangledrightleg")
      end,
    }
  },
  curingmangledrightleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("parestolegs")
        removeaff("mangledrightleg")
        addaff(dict.crippledrightleg)

        local result = checkany(dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledrightleg then
          removeaff("mangledrightleg")
          addaff(dict.crippledrightleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mangledrightleg")
        addaff(dict.crippledrightleg)
      end,

      noeffect = function ()
        removeaff("mangledrightleg")
      end
    }
  },
  crippledrightleg = {
    gamename = "brokenrightleg",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledrightleg and not (affs.mutilatedrightleg or affs.mangledrightleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("crippledrightleg")

        if affs.unknowncrippledlimb then
          dict.unknowncrippledlimb.count = dict.unknowncrippledlimb.count - 1
          if dict.unknowncrippledlimb.count <= 0 then removeaff"unknowncrippledlimb" else updateaffcount(dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledleg then return end
        dict.unknowncrippledleg.count = dict.unknowncrippledleg.count - 1
        if dict.unknowncrippledleg.count <= 0 then removeaff"unknowncrippledleg" else updateaffcount(dict.unknowncrippledleg) end
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to legs", "apply mending", "apply renewal to legs", "apply renewal"},
      onstart = function ()
        apply(dict.crippledrightleg.salve, " to legs")
      end,

      fizzled = function ()
        lostbal_salve()
        addaff(dict.mangledrightleg)
      end,

      noeffect = function ()
        lostbal_salve()
        empty.noeffect_mending_legs()
      end,

      -- sometimes restoration can lag out and hit when this goes - ignore
      empty = function() end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.crippledrightleg)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("crippledrightleg")
      end,
    }
  },
  mutilatedleftleg = {
    gamename = "mangledleftleg",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedleftleg) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmutilatedleftleg.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to legs", "apply restoration", "apply reconstructive to legs", "apply reconstructive"},
      onstart = function ()
        apply(dict.mutilatedleftleg.salve, " to legs")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mutilatedleftleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          dict.mutilatedleftleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg("mutilatedleftleg", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg("mutilatedleftleg", oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mutilatedleftleg")
      end,
    }
  },
  curingmutilatedleftleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("mutilatedleftleg")
        addaff(dict.mangledleftleg)

        local result = checkany(dict.curingmutilatedrightleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedleftleg then
          removeaff("mutilatedleftleg")
          addaff(dict.mangledleftleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mutilatedleftleg")
        addaff(dict.mangledleftleg)
      end,

      noeffect = function ()
        removeaff("mutilatedleftleg")
      end
    }
  },
  mangledleftleg = {
    gamename = "damagedleftleg",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledleftleg and not (affs.mutilatedrightleg or affs.mutilatedleftleg)) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmangledleftleg.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to legs", "apply restoration", "apply reconstructive to legs", "apply reconstructive"},
      onstart = function ()
        apply(dict.mangledleftleg.salve, " to legs")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mangledleftleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          dict.mangledleftleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg("mangledleftleg", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg("mangledleftleg", oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mangledleftleg")
      end,
    }
  },
  curingmangledleftleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("parestolegs")
        removeaff("mangledleftleg")
        addaff(dict.crippledleftleg)

        local result = checkany(dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingparestolegs.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledleftleg then
          removeaff("mangledleftleg")
          addaff(dict.crippledleftleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mangledleftleg")
        addaff(dict.crippledleftleg)
      end,

      noeffect = function ()
        removeaff("mangledleftleg")
      end
    }
  },
  crippledleftleg = {
    gamename = "brokenleftleg",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledleftleg and not (affs.mutilatedleftleg or affs.mangledleftleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("crippledleftleg")

        if affs.unknowncrippledlimb then
          dict.unknowncrippledlimb.count = dict.unknowncrippledlimb.count - 1
          if dict.unknowncrippledlimb.count <= 0 then removeaff"unknowncrippledlimb" else updateaffcount(dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledleg then return end
        dict.unknowncrippledleg.count = dict.unknowncrippledleg.count - 1
        if dict.unknowncrippledleg.count <= 0 then removeaff"unknowncrippledleg" else updateaffcount(dict.unknowncrippledleg) end
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to legs", "apply mending", "apply renewal to legs", "apply renewal"},
      onstart = function ()
        apply(dict.crippledleftleg.salve, " to legs")
      end,

      fizzled = function ()
        lostbal_salve()
        addaff(dict.mangledleftleg)
      end,

      noeffect = function ()
        lostbal_salve()
        empty.noeffect_mending_legs()
      end,

      -- sometimes restoration can lag out and hit when this goes - ignore
      empty = function() end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.crippledleftleg)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("crippledleftleg")
      end,
    }
  },
  parestoarms = {
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      customwaitf = function()
        return not affs.blackout and 0 or 4 -- can't see applies in blackout
      end,

      isadvisable = function ()
        return (affs.parestoarms) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingparestoarms.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to arms", "apply restoration", "apply reconstructive to arms", "apply reconstructive"},
      onstart = function ()
        apply(dict.parestoarms.salve, " to arms")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.parestoarms.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.parestoarms)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("parestoarms")
      end,
    }
  },
  curingparestoarms = {
    waitingfor = {
      customwait = 4,

      oncompleted = function ()
        removeaff("parestoarms")

        local result = checkany(dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      onstart = function ()
      end,

      ontimeout = function ()
        removeaff("parestoarms")
      end,

      noeffect = function ()
        removeaff("parestoarms")
      end
    }
  },
  mutilatedleftarm = {
    gamename = "mangledleftarm",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedleftarm) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmutilatedleftarm.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to arms", "apply restoration", "apply reconstructive to arms", "apply reconstructive"},
      onstart = function ()
        apply(dict.mutilatedleftarm.salve, " to arms")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mutilatedleftarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm("mutilatedleftarm", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm("mutilatedleftarm", oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mutilatedleftarm")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmutilatedleftarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("mutilatedleftarm")
        addaff(dict.mangledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = checkany(dict.curingmutilatedrightarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedleftarm then
          removeaff("mutilatedleftarm")
          addaff(dict.mangledleftarm)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mutilatedleftarm")
        addaff(dict.mangledleftarm)
      end,

      noeffect = function ()
        removeaff("mutilatedleftarm")
      end
    }
  },
  mangledleftarm = {
    gamename = "damagedleftarm",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledleftarm and not (affs.mutilatedrightarm or affs.mutilatedleftarm)) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmangledleftarm.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to arms", "apply restoration", "apply reconstructive to arms", "apply reconstructive"},
      onstart = function ()
        apply(dict.mangledleftarm.salve, " to arms")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mangledleftarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm("mangledleftarm", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm("mangledleftarm", oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mangledleftarm")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmangledleftarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("parestoarms")
        removeaff("mangledleftarm")
        addaff(dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = checkany(dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingparestoarms.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledleftarm then
          removeaff("mangledleftarm")
          addaff(dict.crippledleftarm)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mangledleftarm")
        addaff(dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      noeffect = function ()
        removeaff("mangledleftarm")
      end
    }
  },
  crippledleftarm = {
    gamename = "brokenleftarm",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledleftarm and not (affs.mutilatedleftarm or affs.mangledleftarm or affs.parestoarms)) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("crippledleftarm")

        if affs.unknowncrippledlimb then
          dict.unknowncrippledlimb.count = dict.unknowncrippledlimb.count - 1
          if dict.unknowncrippledlimb.count <= 0 then removeaff"unknowncrippledlimb" else updateaffcount(dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledarm then return end
        dict.unknowncrippledarm.count = dict.unknowncrippledarm.count - 1
        if dict.unknowncrippledarm.count <= 0 then removeaff"unknowncrippledarm" else updateaffcount(dict.unknowncrippledarm) end
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to arms", "apply mending", "apply renewal to arms", "apply renewal"},
      onstart = function ()
        apply(dict.crippledleftarm.salve, " to arms")
      end,

      fizzled = function ()
        lostbal_salve()
        addaff(dict.mangledleftarm)
      end,

      noeffect = function ()
        lostbal_salve()
        empty.noeffect_mending_arms()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("crippledleftarm")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  mutilatedrightarm = {
    gamename = "mangledrightarm",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedrightarm) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmutilatedrightarm.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to arms", "apply restoration", "apply reconstructive to arms", "apply reconstructive"},
      onstart = function ()
        apply(dict.mutilatedrightarm.salve, " to arms")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mutilatedrightarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm("mutilatedrightarm", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm("mutilatedrightarm", oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mutilatedrightarm")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmutilatedrightarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("mutilatedrightarm")
        addaff(dict.mangledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = checkany(dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedrightarm then
          removeaff("mutilatedrightarm")
          addaff(dict.mangledrightarm)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mutilatedleftarm")
        addaff(dict.mangledleftarm)
      end,

      noeffect = function ()
        removeaff("mutilatedrightarm")
      end
    }
  },
  mangledrightarm = {
    gamename = "damagedrightarm",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledrightarm and not (affs.mutilatedrightarm or affs.mutilatedleftarm)) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmangledrightarm.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to arms", "apply restoration", "apply reconstructive to arms", "apply reconstructive"},
      onstart = function ()
        apply(dict.mangledrightarm.salve, " to arms")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mangledrightarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm("mangledrightarm", oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm("mangledrightarm", oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mangledrightarm")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmangledrightarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("mangledrightarm")
        removeaff("parestoarms")
        addaff(dict.crippledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = checkany(dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

        if result then
          killaction(dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledrightarm then
          removeaff("mangledrightarm")
          addaff(dict.crippledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        removeaff("mangledleftarm")
        addaff(dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      noeffect = function ()
        removeaff("mangledrightarm")
      end
    }
  },
  crippledrightarm = {
    gamename = "brokenrightarm",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledrightarm and not (affs.mutilatedrightarm or affs.mangledrightarm or affs.parestoarms)) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("crippledrightarm")

        if affs.unknowncrippledlimb then
          dict.unknowncrippledlimb.count = dict.unknowncrippledlimb.count - 1
          if dict.unknowncrippledlimb.count <= 0 then removeaff"unknowncrippledlimb" else updateaffcount(dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledarm then return end
        dict.unknowncrippledarm.count = dict.unknowncrippledarm.count - 1
        if dict.unknowncrippledarm.count <= 0 then removeaff"unknowncrippledarm" else updateaffcount(dict.unknowncrippledarm) end
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to arms", "apply mending", "apply renewal to arms", "apply renewal"},
      onstart = function ()
        apply(dict.crippledrightarm.salve, " to arms")
      end,

      fizzled = function ()
        lostbal_salve()
        addaff(dict.mangledrightarm)
      end,

      noeffect = function ()
        lostbal_salve()
        empty.noeffect_mending_arms()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.crippledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("crippledrightarm")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  laceratedthroat = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.laceratedthroat) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curinglaceratedthroat.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to head", "apply restoration", "apply reconstructive to head", "apply reconstructive"},
      onstart = function ()
        apply(dict.laceratedthroat.salve, " to head")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.laceratedthroat.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.laceratedthroat)
      end,

      -- separated, so we can use it normally if necessary - another class might get it
      sylvanhit = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth < oldhp) then
          addaff(dict.laceratedthroat)
        end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("laceratedthroat")
      end,
    }
  },
  curinglaceratedthroat = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("laceratedthroat")
        addaff(dict.slashedthroat)
      end,

      onstart = function ()
      end,

      noeffect = function()
        removeaff("laceratedthroat")
        addaff(dict.slashedthroat)
      end,

      noeffect = function ()
        removeaff("laceratedthroat")
      end
    }
  },
  slashedthroat = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.slashedthroat) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("slashedthroat")
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {"epidermal", "sensory"},
      actions = {"apply epidermal to head", "apply epidermal", "apply sensory to head", "apply sensory"},
      onstart = function ()
        apply(dict.slashedthroat.salve, " to head")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.slashedthroat)
      end,

      -- separated, so we can use it normally if necessary - another class might get it
      sylvanhit = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth < oldhp) then
          addaff(dict.slashedthroat)
        end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("slashedthroat")
      end,
    }
  },
  serioustrauma = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.serioustrauma) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingserioustrauma.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to torso", "apply restoration", "apply reconstructive to torso", "apply reconstructive"},
      onstart = function ()
        apply(dict.serioustrauma.salve, " to torso")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.serioustrauma.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp > stats.currenthealth or paragraph_length >= 3 then
          if affs.mildtrauma then removeaff("mildtrauma") end
          addaff(dict.serioustrauma)
        end
      end,

      forced = function ()
        if affs.mildtrauma then removeaff("mildtrauma") end
        addaff(dict.serioustrauma)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("serioustrauma")
      end,
    }
  },
  curingserioustrauma = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("serioustrauma")
        addaff(dict.mildtrauma)
      end,

      ontimeout = function ()
        if affs.serioustrauma then
          removeaff("serioustrauma")
          addaff(dict.mildtrauma)
        end
      end,

      onstart = function ()
      end,

      noeffect = function ()
        removeaff("serioustrauma")
        removeaff("mildtrauma")
      end
    }
  },
  mildtrauma = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mildtrauma) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmildtrauma.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to torso", "apply restoration", "apply reconstructive to torso", "apply reconstructive"},
      onstart = function ()
        apply(dict.mildtrauma.salve, " to torso")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mildtrauma.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp > stats.currenthealth or paragraph_length >= 3 then
          addaff(dict.mildtrauma)
        end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mildtrauma")
      end,
    }
  },
  curingmildtrauma = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("mildtrauma")
      end,

      ontimeout = function ()
        removeaff("mildtrauma")
      end,

      onstart = function ()
      end,

      noeffect = function ()
        removeaff("mildtrauma")
      end
    }
  },
  seriousconcussion = {
    gamename = "mangledhead",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.seriousconcussion) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingseriousconcussion.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to head", "apply restoration", "apply reconstructive to head", "apply reconstructive"},
      onstart = function ()
        apply(dict.seriousconcussion.salve, " to head")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.seriousconcussion.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp > stats.currenthealth or paragraph_length >= 3 then
          if affs.mildconcussion then removeaff("mildconcussion") end
          addaff(dict.seriousconcussion)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      forced = function ()
        if affs.mildconcussion then removeaff("mildconcussion") end
        addaff(dict.seriousconcussion)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("seriousconcussion")
      end,
    },
    onadded = function()
      if affs.prone and affs.seriousconcussion then
        sk.warn "pulpable"
      end
    end
  },
  curingseriousconcussion = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("seriousconcussion")
        addaff(dict.mildconcussion)
      end,

      ontimeout = function ()
        if affs.seriousconcussion then
          removeaff("seriousconcussion")
          addaff(dict.mildconcussion)
        end
      end,

      onstart = function ()
      end,

      noeffect = function ()
        removeaff("seriousconcussion")
        removeaff("mildconcussion")
      end
    }
  },
  mildconcussion = {
    gamename = "damagedhead",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mildconcussion) or false
      end,

      oncompleted = function ()
        lostbal_salve()

        doaction(dict.curingmildconcussion.waitingfor)
      end,

      applycure = {"restoration", "reconstructive"},
      actions = {"apply restoration to head", "apply restoration", "apply reconstructive to head", "apply reconstructive"},
      onstart = function ()
        apply(dict.mildconcussion.salve, " to head")
      end,

      -- we get no msg from an application of this
      empty = function ()
        dict.mildconcussion.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp > stats.currenthealth or paragraph_length >= 3 then
          addaff(dict.mildconcussion)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      forced = function ()
        addaff(dict.mildconcussion)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mildconcussion")
      end,
    }
  },
  curingmildconcussion = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("mildconcussion")
      end,

      ontimeout = function ()
        removeaff("mildconcussion")
      end,

      onstart = function ()
      end,

      noeffect = function ()
        removeaff("mildconcussion")
      end
    }
  },


-- salve cures
  anorexia = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.anorexia and not doingaction "anorexia") or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("anorexia")
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_epidermal_body()
      end,

      empty = function ()
        empty.apply_epidermal_body()
      end,

      applycure = {"epidermal", "sensory"},
      actions = {"apply epidermal to body", "apply epidermal", "apply sensory to body", "apply sensory"},
      onstart = function ()
        apply(dict.anorexia.salve, " to body")
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.anorexia and
          not doingaction("anorexia")) or false
      end,

      oncompleted = function ()
        removeaff("anorexia")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.anorexia)
        codepaste.badaeon()
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("anorexia")
        codepaste.remove_focusable()
      end,
    }
  },
  ablaze = {
    gamename = "burning",
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.ablaze) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("ablaze")
      end,

      all = function()
        lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to body", "apply mending", "apply renewal to body", "apply renewal"},
      onstart = function ()
        apply(dict.ablaze.salve, " to body")
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns("ablaze")
        addaff(dict.ablaze)
      end,
    },
    gone = {
      oncompleted = function ()
        local currentburn = sk.current_burn()
        removeaff(currentburn)
      end,

      -- used in blackout and passive curing where multiple levels could be cured at once
      generic_reducelevel = function(amount)
        -- if no amount is specified, find the current level and take it down a notch
        if not amount then
          local reduceto, currentburn = sk.previous_burn(), sk.current_burn()

          removeaff(currentburn)
          addaff(dict[reduceto])
        else -- amount is specified
          local reduceto, currentburn = sk.previous_burn(amount), sk.current_burn()
          removeaff(currentburn)

          if not reduceto then reduceto = "ablaze" end
          addaff(dict[reduceto])
        end
      end
    }
  },
  severeburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.severeburn) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("severeburn")
        addaff(dict.ablaze)
      end,

      all = function()
        lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to body", "apply mending", "apply renewal to body", "apply renewal"},
      onstart = function ()
        apply(dict.severeburn.salve, " to body")
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns("severeburn")
        addaff(dict.severeburn)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("severeburn")
      end,
    }
  },
  extremeburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.extremeburn) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("extremeburn")
        addaff(dict.severeburn)
      end,

      all = function()
        lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to body", "apply mending", "apply renewal to body", "apply renewal"},
      onstart = function ()
        apply(dict.extremeburn.salve, " to body")
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns("extremeburn")
        addaff(dict.extremeburn)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("extremeburn")
      end,
    }
  },
  charredburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.charredburn) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("charredburn")
        addaff(dict.extremeburn)
      end,

      all = function()
        lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to body", "apply mending", "apply renewal to body", "apply renewal"},
      onstart = function ()
        apply(dict.charredburn.salve, " to body")
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns("charredburn")
        addaff(dict.charredburn)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("charredburn")
      end,
    }
  },
  meltingburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.meltingburn) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("meltingburn")
        addaff(dict.charredburn)
      end,

      all = function()
        lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to body", "apply mending", "apply renewal to body", "apply renewal"},
      onstart = function ()
        apply(dict.meltingburn.salve, " to body")
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns("meltingburn")
        addaff(dict.meltingburn)

        sk.warn "golemdestroyable"
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("meltingburn")
      end,
    }
  },
  selarnia = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.selarnia) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("selarnia")
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending to body", "apply mending", "apply renewal to body", "apply renewal", "apply mending to torso", "apply renewal to torso"},
      onstart = function ()
        apply(dict.selarnia.salve, " to body")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.selarnia)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("selarnia")
      end,
    }
  },
  itching = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.itching) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("itching")
      end,

      noeffect = function ()
        empty.apply_epidermal_body()
      end,

      empty = function ()
        empty.apply_epidermal_body()
      end,

      applycure = {"epidermal", "sensory"},
      actions = {"apply epidermal to body", "apply epidermal", "apply sensory to body", "apply sensory"},
      onstart = function ()
        apply(dict.itching.salve, " to body")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.itching)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("itching")
      end,
    }
  },
  stuttering = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.stuttering) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("stuttering")
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {"epidermal", "sensory"},
      actions = {"apply epidermal to head", "apply epidermal", "apply sensory to head", "apply sensory"},
      onstart = function ()
        apply(dict.stuttering.salve, " to head")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.stuttering)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("stuttering")
      end,
    }
  },
  scalded = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.scalded and not defc.blind and not affs.blindaff) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("scalded")
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {"epidermal", "sensory"},
      actions = {"apply epidermal to head", "apply epidermal", "apply sensory to head", "apply sensory"},
      onstart = function ()
        apply(dict.scalded.salve, " to head")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.scalded)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("scalded")
      end,
    }
  },
  numbedleftarm = {
    waitingfor = {
      customwait = 15, -- lasts 15s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        removeaff("numbedleftarm")
        make_gnomes_work()
      end,

      oncompleted = function ()
        removeaff("numbedleftarm")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.numbedleftarm)
        if not actions.numbedleftarm_waitingfor then doaction(dict.numbedleftarm.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("numbedleftarm")
        killaction (dict.numbedleftarm.waitingfor)
      end,
    }
  },
  numbedrightarm = {
    waitingfor = {
      customwait = 8, -- lasts 8s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        removeaff("numbedrightarm")
        make_gnomes_work()
      end,

      oncompleted = function ()
        removeaff("numbedrightarm")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.numbedrightarm)
        if not actions.numbedrightarm_waitingfor then doaction(dict.numbedrightarm.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("numbedrightarm")
        killaction (dict.numbedrightarm.waitingfor)
      end,
    }
  },
  blindaff = {
    gamename = "blind",
    onservereignore = function()
      return not dict.blind.onservereignore()
    end,
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.blindaff or (defc.blind and not ((sys.deffing and defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind))) or affs.scalded) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("blindaff")
        defences.lost("blind")

        local restoreaff, restoredef
        if affs.deafaff then restoreaff = true end
        if defc.deaf then restoredef = true end

        empty.apply_epidermal_head()

        if restoreaff then addaff(dict.deafaff) end
        if restoredef then defences.got("deaf") end
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {"epidermal", "sensory"},
      actions = {"apply epidermal to head", "apply epidermal", "apply sensory to head", "apply sensory"},
      onstart = function ()
        apply(dict.blindaff.salve, " to head")
      end
    },
    aff = {
      oncompleted = function ()
        if (defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)
         then
          defences.got("blind")
        else
          addaff(dict.blindaff)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("blindaff")
        defences.lost("blind")
      end,
    }
  },
  deafaff = {
    gamename = "deaf",
    onservereignore = function()
      return not dict.deaf.onservereignore()
    end,
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.deafaff or defc.deaf and not ((sys.deffing and defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf))) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("deafaff")
        defences.lost("deaf")
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {"epidermal", "sensory"},
      actions = {"apply epidermal to head", "apply epidermal", "apply sensory to head", "apply sensory"},
      onstart = function ()
        apply(dict.deafaff.salve, " to head")
      end
    },
    aff = {
      oncompleted = function ()
        if (defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye then
          defences.got("deaf")
        else
          addaff(dict.deafaff)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("deafaff")
        defences.lost("deaf")
      end,
    }
  },

  shivering = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.shivering and not affs.frozen and not affs.hypothermia) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("shivering")
      end,

      noeffect = function()
        lostbal_salve()
      end,

      gotcaloricdef = function (hypothermia)
        if not hypothermia then removeaff({"frozen", "shivering"}) end
        dict.caloric.salve.oncompleted ()
      end,

      applycure = {"caloric", "exothermic"},
      actions = {"apply caloric to body", "apply caloric", "apply exothermic to body", "apply exothermic"},
      onstart = function ()
        apply(dict.shivering.salve, " to body")
      end,

      empty = function ()
        lostbal_salve()
        removeaff("shivering")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.shivering)
        defences.lost("caloric")
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("shivering")
      end,
    }
  },
  frozen = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.frozen and not affs.hypothermia) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("frozen")
        addaff(dict.shivering)
      end,

      noeffect = function()
        lostbal_salve()
      end,

      gotcaloricdef = function (hypothermia)
        if not hypothermia then removeaff({"frozen", "shivering"}) end
        dict.caloric.salve.oncompleted ()
      end,

      applycure = {"caloric", "exothermic"},
      actions = {"apply caloric to body", "apply caloric", "apply exothermic to body", "apply exothermic"},
      onstart = function ()
        apply(dict.frozen.salve, " to body")
      end,

      empty = function ()
        lostbal_salve()
        removeaff("frozen")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.frozen)
        defences.lost("caloric")
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("frozen")
      end
    }
  },

-- purgatives
  voyria = {
    purgative = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.voyria) or false
      end,

      oncompleted = function ()
        lostbal_purgative()
        removeaff("voyria")
      end,

      sipcure = {"immunity", "antigen"},
      onstart = function ()
        sip(dict.voyria.purgative)
      end,

      noeffect = function()
        removeaff("voyria")
        lostbal_purgative()
      end,

      empty = function ()
        lostbal_purgative()
        empty.sip_immunity()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.voyria)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("voyria")
      end
    }
  },


-- misc
  lovers = {
    map = {},
    tempmap = {},
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.lovers and not doingaction("lovers")) or false
      end,

      oncompleted = function (whom)
        dict.lovers.map[whom] = nil
        if not next(dict.lovers.map) then
          removeaff("lovers")
        end
      end,

      onclear = function ()
        dict.lovers.tempmap = {}
      end,

      nobody = function ()
        if dict.lovers.rejecting then
          dict.lovers.map[dict.lovers.rejecting] = nil
          dict.lovers.rejecting = nil
        end

        if not next(dict.lovers.map) then
          removeaff("lovers")
        end
      end,

      onstart = function ()
        dict.lovers.rejecting = next(dict.lovers.map)
        if not dict.lovers.rejecting then -- if we added it via some manual way w/o a name, this failsafe will catch & remove it
          removeaff("lovers")
          return
        end

        send("reject " .. dict.lovers.rejecting, conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (whom)
        if not dict.lovers.tempmap and not whom then return end

        addaff(dict.lovers)
        for _, name in ipairs(dict.lovers.tempmap) do
          dict.lovers.map[name] = true
        end
        dict.lovers.tempmap = {}

        if whom then
          dict.lovers[whom] = true
        end

        affl.lovers = {names = dict.lovers.map}
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("lovers")
        dict.lovers.map = {}
      end,
    }
  },
  fear = {
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.fear and not doingaction("fear")) or false
      end,

      oncompleted = function ()
        removeaff("fear")
      end,

      action = "compose",
      onstart = function ()
        send("compose", conf.commandecho)
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return false
        --[[return (affs.fear and
          not doingaction("fear")) or false]]
      end,

      oncompleted = function ()
        removeaff("fear")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.fear)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("fear")
        codepaste.remove_focusable()
      end
    }
  },
  sleep = {
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.sleep and
          not doingaction("curingsleep") and not doingaction("sleep")) or false
      end,

      oncompleted = function ()
        doaction(dict.curingsleep.waitingfor)
      end,

      actions = {"wake", "wake up"},
      onstart = function ()
        send("wake up", conf.commandecho)
      end,

      -- ???
      empty = function ()
      end
    },
    aff = {
      oncompleted = function ()
        if not affs.sleep then addaff(dict.sleep) defences.lost("insomnia") end
      end,

      symptom = function()
        if not affs.sleep then addaff(dict.sleep) defences.lost("insomnia") end
        addaff(dict.prone)

        -- reset non-wait things we were doing, because they got cancelled by the stun
        if affs.sleep or actions.sleep_aff then
          for k,v in actions:iter() do
            if v.p.balance ~= "waitingfor" and v.p.balance ~= "aff" and v.p.name ~= "sleep_misc" then
              killaction(dict[v.p.action_name][v.p.balance])
            end
          end
        end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("sleep")
      end,
    }
  },
  curingsleep = {
    spriority = 0,
    waitingfor = {
      customwait = 999,

      oncompleted = function ()
        removeaff("sleep")

        -- reset sleep so we try waking up again after being awoken and slept at once (like in a dsl or a delph snipe)
        if actions.sleep_misc then
          killaction(dict.sleep.misc)
        end
      end,

      onstart = function () end
    }
  },
  bleeding = {
    count = 0,
    -- affs.bleeding.spammingbleed is used to throttle bleed spamming so it doesn't get out of control
    misc = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priorities
      uncurable = true,

      isadvisable = function ()
        if affs.bleeding and not doingaction("bleeding") and not affs.bleeding.spammingbleed and not affs.haemophilia and not affs.sleep and can_usemana() and conf.clot then
          if (not affs.corrupted and dict.bleeding.count >= conf.bleedamount) then
            return true
          elseif (affs.corrupted and dict.bleeding.count >= conf.manableedamount) then
            if stats.currenthealth >= sys.corruptedhealthmin then
              return true
            else
              sk.warn "cantclotmana"
              return false
            end
          end
        else return false end
      end,

      -- by default, oncompleted means a clot went through okay
      oncompleted = function ()
        dict.bleeding.saw_haemophilia = nil
      end,

      -- oncured in this case means that we actually cured it; don't have any more bleeding
      oncured = function ()
        if affs.bleeding and affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
        removeaff("bleeding")
        dict.bleeding.count = 0
        dict.bleeding.saw_haemophilia = nil
      end,

      nomana = function ()
        if not actions.nomana_waitingfor and stats.currentmana ~= 0 then
          echof("Seems we're out of mana.")
          doaction(dict.nomana.waitingfor)
        end

        dict.bleeding.saw_haemophilia = nil
        if affs.bleeding and affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
      end,

      haemophilia = function()
        if dict.bleeding.saw_haemophilia then
          addaff(dict.haemophilia)
          echof("Seems like we do have haemophilia for real.")
        else
          dict.bleeding.saw_haemophilia = true
        end
        if affs.bleeding and affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
      end,

      action = "clot",
      onstart = function ()
        local show = conf.commandecho and not conf.gagclot
        send("clot", show)

        -- don't optimize with corruption for now (but do if need need be)
        if not sys.sync and ((not affs.corrupted and svo.stats.mp >= 70 and (dict.bleeding.count and dict.bleeding.count >= 200))
            or (affs.corrupted and stats.currenthealth+500 >= sys.corruptedhealthmin)) then
          send("clot", show)
          send("clot", show)

          -- after sending a bunch of clots, wait a bit before doing it again
          if affs.bleeding then
            if affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
            affs.bleeding.spammingbleed = tempTimer(getping(), function () affs.bleeding.spammingbleed = nil; make_gnomes_work() end)
          end
        end
      end
    },
    aff = {
      oncompleted = function (amount)
        addaff(dict.bleeding)
        -- TODO: affs.count vs dict.count?
        affs.bleeding.p.count = amount or (affs.bleeding.p.count + 200)
        updateaffcount(dict.bleeding)

        -- remove bleeding if we've had it for a while and didn't clot it up
        if sk.smallbleedremove then killTimer(sk.smallbleedremove) end
        sk.smallbleedremove = tempTimer(conf.smallbleedremove or 8, function()
          sk.smallbleedremove = nil
          if not affs.bleeding then return end

          if dict.bleeding.count <= conf.bleedamount or dict.bleeding.count <= conf.manableedamount then
            removeaff("bleeding")
          end
        end)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("bleeding")
      end,
    },
    onremoved = function()
      dict.bleeding.count = 0
      if sk.smallbleedremove then
        killTimer(sk.smallbleedremove)
        sk.smallbleedremove = nil
      end
    end
  },
  touchtree = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        if not next(affs) or not bals.tree or doingaction("touchtree") or affs.sleep or not conf.tree or affs.stun or affs.unconsciousness or affs.numbedrightarm or affs.numbedleftarm or affs.paralysis or affs.webbed or affs.bound or affs.transfixed or affs.roped or affs.impale or ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm)) or codepaste.nonstdcure() then return false end

        for name, func in pairs(tree) do
          if not me.disabledtreefunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function (aff)
        -- small heuristic - shivering can be upgraded to frozen
        if aff == "shivering" and not affs.shivering and affs.frozen then
          removeaff("frozen")
        -- handle levels of burns
        elseif aff == "all burns" then
          codepaste.remove_burns()
        elseif aff == "burn" then
          local previousburn, currentburn = sk.previous_burn(), sk.current_burn()

          if not burn then
            codepaste.remove_burns()
          else
            removeaff(currentburn)
            addaff(dict[previousburn])
          end
        elseif aff == "skullfractures" then
          -- two counts are cured if you're above 5
          local howmany = dict.skullfractures.count
          codepaste.remove_stackableaff("skullfractures", true)
          if howmany > 5 then
            codepaste.remove_stackableaff("skullfractures", true)
          end
        elseif aff == "skullfractures cured" then
          removeaff("skullfractures")
          dict.skullfractures.count = 0
        elseif aff == "crackedribs" then
          -- two counts are cured if you're above 5
          local howmany = dict.crackedribs.count
          codepaste.remove_stackableaff("crackedribs", true)
          if howmany > 5 then
            codepaste.remove_stackableaff("crackedribs", true)
          end
        elseif aff == "crackedribs cured" then
          removeaff("crackedribs")
          dict.crackedribs.count = 0
        elseif aff == "wristfractures" then
          -- two counts are cured if you're above 5
          local howmany = dict.wristfractures.count
          codepaste.remove_stackableaff("wristfractures", true)
          if howmany > 5 then
            codepaste.remove_stackableaff("wristfractures", true)
          end
        elseif aff == "wristfractures cured" then
          removeaff("wristfractures")
          dict.wristfractures.count = 0
        elseif aff == "torntendons" then
          -- two counts are cured if you're above 5
          local howmany = dict.torntendons.count
          codepaste.remove_stackableaff("torntendons", true)
          if howmany > 5 then
            codepaste.remove_stackableaff("torntendons", true)
          end
        elseif aff == "torntendons cured" then
          removeaff("torntendons")
          dict.torntendons.count = 0
        else
          removeaff(aff)
        end

        lostbal_tree()
      end,

      action = "touch tree",
      onstart = function ()
        send("touch tree", conf.commandecho)
      end,

      empty = function ()
        lostbal_tree()
        empty.tree()
      end,

      offbal = function ()
        lostbal_tree()
      end
    }
  },
  restore = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      uncurable = true,

      isadvisable = function ()
        if not next(affs) or not conf.restore or usingbal("salve") or codepaste.balanceful_codepaste() or codepaste.nonstdcure() then return false end

        for name, func in pairs(restore) do
          if not me.disabledrestorefunc[name] then
            local s,m = pcall(func[1])
            if s and m then debugf("restore: %s strat went off", name) return true end
          end
        end
      end,

      oncompleted = function (number)
        if number then
          -- empty
          if number+1 == getLineNumber() then
            dict.unknowncrippledlimb.count = 0
            dict.unknowncrippledarm.count = 0
            dict.unknowncrippledleg.count = 0
            removeaff({"crippledleftarm", "crippledleftleg", "crippledrightarm", "crippledrightleg", "unknowncrippledarm", "unknowncrippledleg", "unknowncrippledlimb"})
          end
        end
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      action = "restore",
      onstart = function ()
        send("restore", conf.commandecho)
      end
    }
  },
  dragonheal = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      uncurable = true,

      isadvisable = function ()
        if not next(affs) or not defc.dragonform or not conf.dragonheal or not bals.dragonheal or codepaste.balanceful_codepaste() or codepaste.nonstdcure() or (affs.recklessness and affs.weakness) then return false end

        for name, func in pairs(dragonheal) do
          if not me.disableddragonhealfunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function (number)
        if number then
          -- empty
          if number+1 == getLineNumber() then
            empty.dragonheal()
          end
        end

        lostbal_dragonheal()
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      nobalance = function ()
        lostbal_dragonheal()
      end,

      action = "dragonheal",
      onstart = function ()
        send("dragonheal", conf.commandecho)
      end
    }
  },
  defcheck = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        local bals = bals
        return (bals.balance and bals.equilibrium and me.manualdefcheck and not doingaction("defcheck")) or false
      end,

      oncompleted = function ()
        me.manualdefcheck = false
        process_defs()
      end,

      ontimeout = function ()
        me.manualdefcheck = false
      end,

      action = "def",
      onstart = function ()
        send("def", conf.commandecho)
      end
    },
  },
  diag = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return ((sys.manualdiag or (affs.unknownmental and affs.unknownmental.p.count >= conf.unknownfocus) or (affs.unknownany and affs.unknownany.p.count >= conf.unknownany)) and bals.balance and bals.equilibrium and not doingaction("diag")) or false
      end,

      oncompleted = function ()
        sys.manualdiag = false
        sk.diag_list = {}
        removeaff("unknownmental")
        removeaff("unknownany")
        dict.unknownmental.count = 0
        dict.unknownany.count = 0
        dict.bleeding.saw_haemophilia = nil
        dict.relapsing.saw_with_checkable = nil

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      actions = {"diag", "diagnose", "diag me", "diagnose me"},
      onstart = function ()
        send("diag", conf.commandecho)
      end
    },
  },
  block = {
    gamename = "blocking",
    physical = {
      blockingdir = "",
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        if defc.block and ((conf.keepup and not defkeepup[defs.mode].block and not sys.deffing) or (sys.deffing and not defdefup[defs.mode].block)) and not doingaction"block" then return true end

        return (((sys.deffing and defdefup[defs.mode].block) or (conf.keepup and defkeepup[defs.mode].block and not sys.deffing)) and (not defc.block or dict.block.physical.blockingdir ~= conf.blockingdir) and not doingaction"block" and (not sys.enabledgmcp or (gmcp.Room and gmcp.Room.Info.exits[conf.blockingdir])) and not codepaste.balanceful_codepaste() and not affs.prone
        ) or false
      end,

      oncompleted = function (dir)
        if dir then
          dict.block.physical.blockingdir = sk.anytoshort(dir)
        else --workaround for looping
          dict.block.physical.blockingdir = conf.blockingdir
        end
        defences.got("block")
      end,

      -- in case of failing to block, register that the action has been completed
      failed = function()
      end,

      onstart = function ()
        if (not defc.block or dict.block.physical.blockingdir ~= conf.blockingdir) then
          send("block "..tostring(conf.blockingdir), conf.commandecho)
        else
          send("unblock", conf.commandecho)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        defences.lost("block")
        dict.block.physical.blockingdir = ""

        if actions.block_physical then
          killaction(dict.block.physical)
        end
      end
    }
  },
  doparry = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (not sys.sp_satisfied and not sys.blockparry and not affs.paralysis
          and not doingaction "doparry" and (
            conf.parry
           ) and not codepaste.balanceful_codepaste()
          -- blademasters can parry with their sword sheathed
          and ((not sys.enabledgmcp or defc.dragonform) or (next(me.wielded) and sk.have_parryable()))
          and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function (limb)
        local t = sps.parry_currently
        for limb, _ in pairs(t) do t[limb] = false end
        t[limb] = true
        check_sp_satisfied()
      end,

      onstart = function ()
        if sps.something_to_parry() then
          for name, limb in pairs(sp_config.parry_shouldbe) do
            if limb and limb ~= sps.parry_currently[name] then
              send(string.format("%sparry %s", (not defc.dragonform and "" or "claw"), name), conf.commandecho)
              return
            end
          end
        elseif type(sp_config.parry) == "string" and sp_config.parry == "manual" then
          -- check if we need to unparry in manual
          for limb, status in pairs(sps.parry_currently) do
            if status ~= sp_config.parry_shouldbe[limb] then
             send(string.format("%sparry nothing", (not defc.dragonform and "" or "claw")), conf.commandecho)
             return
            end
          end

          -- got here? nothing to do...
          sys.sp_satisfied = true
        elseif sp_config.priority[1] and not sps.parry_currently[sp_config.priority[1]] then
          send(string.format("%sparry %s", (not defc.dragonform and "" or "claw"), sp_config.priority[1]), conf.commandecho)
        else -- got here? nothing to do...
          sys.sp_satisfied = true end
      end,

      none = function ()
        for limb, _ in pairs(sps.parry_currently) do
          sps.parry_currently[limb] = false
        end

        check_sp_satisfied()
      end
    }
  },
  doprecache = {
    misc = {
      aspriority = 0,
      spriority = 0,
      -- not a curable in-game affliction? mark it so priority doesn't get set
      uncurable = true,

      isadvisable = function ()
        return (rift.doprecache and not sys.blockoutr and not findbybal"herb" and not doingaction"doprecache" and sys.canoutr) or false
      end,

      oncompleted = function ()
        -- check if we still need to precache, and if not, clear rift.doprecache
        rift.checkprecache()

        if rift.doprecache then
          -- allow other outrs to catch up, then re-check again
          if sys.blockoutr then killTimer(sys.blockoutr); sys.blockoutr = nil end
          sys.blockoutr = tempTimer(sys.wait + syncdelay(), function () sys.blockoutr = nil; debugf("sys.blockoutr expired") make_gnomes_work() end)
          debugf("sys.blockoutr setup: ", debug.traceback())
        end
      end,

      ontimeout = function ()
        rift.checkprecache()
      end,

      onstart = function ()
        for herb, amount in pairs(rift.precache) do
          if rift.precache[herb] ~= 0 and rift.riftcontents[herb] ~= 0 and (rift.invcontents[herb] < rift.precache[herb]) then
            send(string.format("outr %s%s", (affs.addiction and "" or (rift.precache[herb] - rift.invcontents[herb].." ")), herb), conf.commandecho)
            if sys.sync then return end
          end
        end
      end
    }
  },
  prone = {
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.prone and (not affs.paralysis or doingaction"paralysis")
          and bals.balance and bals.equilibrium and bals.leftarm and bals.rightarm
          and not doingaction("prone") and not affs.sleep
          and not affs.impale
          and not affs.transfixed
          and not affs.webbed and not affs.bound and not affs.roped
          and not affs.crippledleftleg and not affs.crippledrightleg
          and not affs.mangledleftleg and not affs.mangledrightleg
          and not affs.mutilatedleftleg and not affs.mutilatedrightleg) or false
      end,

      oncompleted = function ()
        removeaff("prone")
      end,

      action = "stand",
      onstart = function ()
        send("stand", conf.commandecho)
        if affs.blackout then send("stand", conf.commandecho) end
      end
    },
    aff = {
      oncompleted = function ()
        if not affs.prone then addaff(dict.prone) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("prone")
      end
    },
    onremoved = function () donext() end,
    onadded = function()
      if affs.prone and affs.seriousconcussion then
        sk.warn "pulpable"
      end
    end
  },
  disrupt = {
    gamename = "disrupted",
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.disrupt and not doingaction("disrupt")
          and not affs.confusion and not affs.sleep) or false
      end,

      oncompleted = function ()
        removeaff("disrupt")
      end,

      oncured = function ()
        removeaff("disrupt")
      end,

      action = "concentrate",
      onstart = function ()
        send("concentrate", conf.commandecho)
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.disrupt)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("disrupt")
      end
    }
  },
  lightpipes = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return ((not pipes.valerian.arty and not pipes.valerian.lit and pipes.valerian.puffs > 0 and not (pipes.valerian.id == 0)
          or (not pipes.elm.arty and not pipes.elm.lit and pipes.elm.puffs > 0 and not (pipes.elm.id == 0))
          or (not pipes.skullcap.arty and not pipes.skullcap.lit and pipes.skullcap.puffs > 0 and not (pipes.skullcap.id == 0))
          or (not pipes.elm.arty2 and not pipes.elm.lit2 and pipes.elm.puffs2 > 0 and not (pipes.elm.id2 == 0))
          or (not pipes.valerian.arty2 and not pipes.valerian.lit2 and pipes.valerian.puffs2 > 0 and not (pipes.valerian.id2 == 0))
          or (not pipes.skullcap.arty2 and not pipes.skullcap.lit2 and pipes.skullcap.puffs2 > 0 and not (pipes.skullcap.id2 == 0))
          )
        and (conf.relight or sk.forcelight_valerian or sk.forcelight_skullcap or sk.forcelight_elm)
        and not (doingaction("lightskullcap") or doingaction("lightelm") or doingaction("lightvalerian") or doingaction("lightpipes"))) or false
      end,

      oncompleted = function ()
        pipes.valerian.lit = true
        pipes.valerian.lit2 = true
        sk.forcelight_valerian = false
        pipes.elm.lit = true
        pipes.elm.lit2 = true
        sk.forcelight_elm = false
        pipes.skullcap.lit = true
        pipes.skullcap.lit2 = true
        sk.forcelight_skullcap = false

        lastlit("valerian")
      end,

      actions = {"light pipes"},
      onstart = function ()
        if conf.gagrelight then
          send("light pipes", false)
        else
          send("light pipes", conf.commandecho) end
      end
    }
  },
  fillskullcap = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      herb = "skullcap",
      uncurable = true,
      fillingid = 0,

      mainpipeout = function()
        return (pipes.skullcap.puffs <= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.skullcap.id == 0)
      end,

      secondarypipeout = function()
        return (pipes.skullcap.puffs2 <= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.skullcap.id2 == 0)
      end,

      isadvisable = function ()
        return ((dict.fillskullcap.physical.mainpipeout() or dict.fillskullcap.physical.secondarypipeout()) and not doingaction("fillskullcap") and not doingaction("fillelm") and not doingaction("fillvalerian") and not will_take_balance() and not (affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm or affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm or affs.paralysis or affs.transfixed)) or false
      end,

      oncompleted = function ()
        if dict.fillskullcap.fillingid == pipes.skullcap.id then
          pipes.skullcap.puffs = pipes.skullcap.maxpuffs or 10
          pipes.skullcap.lit = false
          rift.invcontents.skullcap = rift.invcontents.skullcap - 1
          if rift.invcontents.skullcap < 0 then rift.invcontents.skullcap = 0 end
        else
          pipes.skullcap.puffs2 = pipes.skullcap.maxpuffs2 or 10
          pipes.skullcap.lit2 = false
          rift.invcontents.skullcap = rift.invcontents.skullcap - 1
          if rift.invcontents.skullcap < 0 then rift.invcontents.skullcap = 0 end
        end
      end,

      onstart = function ()
        if dict.fillskullcap.physical.mainpipeout() then
          fillpipe("skullcap", pipes.skullcap.id)
          dict.fillskullcap.fillingid = pipes.skullcap.id
        else
          fillpipe("skullcap", pipes.skullcap.id2)
          dict.fillskullcap.fillingid = pipes.skullcap.id2
        end
      end
    }
  },
  fillelm = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      herb = "elm",
      uncurable = true,
      fillingid = 0,

      mainpipeout = function()
        return (pipes.elm.puffs <= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.elm.id == 0)
      end,

      secondarypipeout = function()
        return (pipes.elm.puffs2 <= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.elm.id2 == 0)
      end,

      isadvisable = function ()
        return ((dict.fillelm.physical.mainpipeout() or dict.fillelm.physical.secondarypipeout()) and not doingaction("fillskullcap") and not doingaction("fillelm") and not doingaction("fillvalerian") and not will_take_balance()  and not (affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm or affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm or affs.paralysis or affs.transfixed)) or false
      end,

      oncompleted = function ()
        if dict.fillelm.fillingid == pipes.elm.id then
          pipes.elm.puffs = pipes.elm.maxpuffs or 10
          pipes.elm.lit = false
          rift.invcontents.elm = rift.invcontents.elm - 1
          if rift.invcontents.elm < 0 then rift.invcontents.elm = 0 end
        else
          pipes.elm.puffs2 = pipes.elm.maxpuffs2 or 10
          pipes.elm.lit2 = false
          rift.invcontents.elm = rift.invcontents.elm - 1
          if rift.invcontents.elm < 0 then rift.invcontents.elm = 0 end
        end
      end,

      onstart = function ()
        if dict.fillelm.physical.mainpipeout() then
          fillpipe("elm", pipes.elm.id)
          dict.fillelm.fillingid = pipes.elm.id
        else
          fillpipe("elm", pipes.elm.id2)
          dict.fillelm.fillingid = pipes.elm.id2
        end
      end
    }
  },
  fillvalerian = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      herb = "valerian",
      uncurable = true,
      fillingid = 0,

      mainpipeout = function()
        return (pipes.valerian.puffs <= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.valerian.id == 0)
      end,

      secondarypipeout = function()
        return (pipes.valerian.puffs2 <= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.valerian.id2 == 0)
      end,

      isadvisable = function ()
        if (dict.fillvalerian.physical.mainpipeout() or dict.fillvalerian.physical.secondarypipeout()) and not doingaction("fillskullcap") and not doingaction("fillelm") and not doingaction("fillvalerian") and not will_take_balance() then

          if (affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm or affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm or affs.paralysis or affs.transfixed) then
            sk.warn "emptyvalerianpipenorefill"
            return false
          else
            return true
          end
        end
      end,

      oncompleted = function ()
        if dict.fillvalerian.fillingid == pipes.valerian.id then
          pipes.valerian.puffs = pipes.valerian.maxpuffs or 10
          pipes.valerian.lit = false
          rift.invcontents.valerian = rift.invcontents.valerian - 1
          if rift.invcontents.valerian < 0 then rift.invcontents.valerian = 0 end
        else
          pipes.valerian.puffs2 = pipes.valerian.maxpuffs2 or 10
          pipes.valerian.lit2 = false
          rift.invcontents.valerian = rift.invcontents.valerian - 1
          if rift.invcontents.valerian < 0 then rift.invcontents.valerian = 0 end
        end
      end,

      onstart = function ()
        if dict.fillvalerian.physical.mainpipeout() then
          fillpipe("valerian", pipes.valerian.id)
          dict.fillvalerian.fillingid = pipes.valerian.id
        else
          fillpipe("valerian", pipes.valerian.id2)
          dict.fillvalerian.fillingid = pipes.valerian.id2
        end
      end
    }
  },
  rewield = {
    rewieldables = false,
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (conf.autorewield and dict.rewield.rewieldables and not doingaction"rewield" and not affs.impale and not affs.webbed and not affs.transfixed and not affs.roped and not affs.transfixed and sys.canoutr and not affs.mutilatedleftarm and not affs.mutilatedrightarm and not affs.mangledrightarm and not affs.mangledleftarm and not affs.crippledrightarm and not affs.crippledleftarm) or false
      end,

      oncompleted = function (id)
        if not dict.rewield.rewieldables then return end

        for count, item in ipairs(dict.rewield.rewieldables) do
          if item.id == id then
            table.remove(dict.rewield.rewieldables, count)
            break
          end
        end

        if #dict.rewield.rewieldables == 0 then
          dict.rewield.rewieldables = false
        end
      end,

      failed = function ()
        dict.rewield.rewieldables = false
      end,

      clear = function ()
        dict.rewield.rewieldables = false
      end,

      onstart = function ()
        for _, t in pairs(dict.rewield.rewieldables) do
          send("wield "..t.id, conf.commandecho)
          if sys.sync then return end
        end
      end
    }
  },
  blackout = {
    waitingfor = {
      customwait = 60,

      onstart = function ()
      end,

      oncompleted = function ()
        removeaff("blackout")
      end,

      ontimeout = function ()
        removeaff("blackout")
      end
    },
    aff = {
      oncompleted = function ()
        if affs.blackout then return end

        addaff(dict.blackout)
        check_generics()

        tempTimer(4.5, function() if affs.blackout then addaff(dict.disrupt) make_gnomes_work() end end)

        -- prevent leprosy in blackout
        if svo.enabledskills.necromancy then
          echof("Fighting a Necromancer - going to assume crippled limbs every now and then.")
          tempTimer(3, function() if affs.blackout then addaff(dict.unknowncrippledlimb) make_gnomes_work() end end)
          tempTimer(5, function() if affs.blackout then addaff(dict.unknowncrippledlimb) make_gnomes_work() end end)
        end

        if svo.enabledskills.curses then
          echof("Fighting a Shaman - going to check for asthma/anorexia.")
          tempTimer(3, function() if affs.blackout then affsp.anorexia = true; affsp.asthma = true; make_gnomes_work() end end)
          tempTimer(5, function() if affs.blackout then affsp.anorexia = true; affsp.asthma = true; make_gnomes_work() end end)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("blackout")
      end,
    },
    onremoved = function ()
      check_generics()
      if sk.sylvan_eclipse then
        sys.manualdiag = true
      end

      if not affs.recklessness then
        killaction (dict.nomana.waitingfor)
      end

      if dict.blackout.check_lust then
        echof("Checking allies for potential lust...")
        send("allies", conf.commandecho)
        dict.blackout.check_lust = nil
      end

      tempTimer(0.5, function()
        if not bals.equilibrium and not conf.serverside then addaff(dict.disrupt) end

        if stats.currenthealth == 0 and conf.assumestats ~= 0 then
          reset.affs()
          reset.general()
          reset.defs()
          conf.paused = true
          echo"\n"echof("We died.")
          raiseEvent("svo config changed", "paused")
        end
      end)

      -- if we came out with full health and mana out of blackout, assume we've got recklessness meanwhile. don't do it in serverside curing though, because that doesn't assume the same
      if (not dict.blackout.addedon or dict.blackout.addedon ~= os.time()) and stats.currenthealth == stats.maxhealth and stats.currentmana == stats.maxmana then
        addaff(dict.recklessness)
        echof("suspicious full stats out of blackout - going to assume reckless.")
        if conf.serverside then
          sendcuring("predict recklessness")
        end
      end
    end,
    onadded = function()
      dict.blackout.addedon = os.time()
    end
  },
  unknownany = {
    count = 0,
    reckhp = false, reckmana = false,
    waitingfor = {
      customwait = 999,

      onstart = function ()
      end,

      empty = function ()
      end
    },
    aff = {
      oncompleted = function (number)

        if ((dict.unknownany.reckhp and stats.currenthealth == stats.maxhealth) or
          (dict.unknownany.reckmana and stats.currentmana == stats.maxmana)) then
            addaff(dict.recklessness)

            if conf.serverside then
              sendcuring("predict recklessness")
            end

            if number and number > 1 then
              -- take one off because one affliction is recklessness
              codepaste.addunknownany(number-1)
            end
        else
          codepaste.addunknownany(number)
        end

        dict.unknownany.reckhp = false; dict.unknownany.reckmana = false
      end,

      wrack = function()
        -- if 3, then it was not hidden, ignore - affliction triggers will watch the aff
        if paragraph_length >= 3 then return end

        if ((dict.unknownany.reckhp and stats.currenthealth == stats.maxhealth) or
          (dict.unknownany.reckmana and stats.currentmana == stats.maxmana)) then
            addaff(dict.recklessness)

            if conf.serverside then
              sendcuring("predict recklessness")
            end
        else
          codepaste.addunknownany()
        end

        dict.unknownany.reckhp = false; dict.unknownany.reckmana = false
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("unknownany")
        dict.unknownany.count = 0
      end,

      -- to be used when you lost one unknown (for example, you saw a symptom for something else)
      lost_level = function()
        if not affs.unknownany then return end
        affs.unknownany.p.count = affs.unknownany.p.count - 1
        if affs.unknownany.p.count <= 0 then
          removeaff("unknownany")
          dict.unknownany.count = 0
        else
          updateaffcount(dict.unknownany)
        end
      end
    }
  },
  unknownmental = {
    count = 0,
    reckhp = false, reckmana = false,
    focus = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknownmental) or false
      end,

      oncompleted = function ()
        -- special: gets called on each focus mind cure, but we most of
        -- the time don't have an unknown aff
        if not affs.unknownmental then return end
        affs.unknownmental.p.count = affs.unknownmental.p.count - 1
        if affs.unknownmental.p.count <= 0 then
          removeaff("unknownmental")
          dict.unknownmental.count = 0
        else
          updateaffcount(dict.unknownmental)
        end

        lostbal_focus()
      end,

      onstart = function ()
        send("focus mind", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        removeaff("unknownmental")
      end
    },
    aff = {
      oncompleted = function (number)
        if ((dict.unknownmental.reckhp and stats.currenthealth == stats.maxhealth) or
          (dict.unknownmental.reckmana and stats.currentmana == stats.maxmana)) then
            addaff(dict.recklessness)

            if conf.serverside then
              sendcuring("predict recklessness")
            end

            if number and number > 1 then
              local count = dict.unknownany.count
              addaff(dict.unknownany)
              -- take one off because one affliction is recklessness
              affs.unknownany.p.count = (count or 0) + (number - 1)
              updateaffcount(dict.unknownany)
            end
        else
          local count = dict.unknownmental.count
          addaff(dict.unknownmental)

          dict.unknownmental.count = (count or 0) + (number or 1)
          updateaffcount(dict.unknownmental)
        end

        dict.unknownmental.reckhp = false; dict.unknownmental.reckmana = false
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("unknownmental")
        dict.unknownmental.count = 0
      end,

      -- to be used when you lost one focusable (for example, you saw a symptom for something else)
      lost_level = function()
        if not affs.unknownmental then return end
        affs.unknownmental.p.count = affs.unknownmental.p.count - 1
        if affs.unknownmental.p.count <= 0 then
          removeaff("unknownmental")
          dict.unknownmental.count = 0
        else
          updateaffcount(dict.unknownmental)
        end
      end
    }
  },
  unknowncrippledlimb = {
    count = 0,
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknowncrippledlimb and not (affs.mutilatedrightarm or affs.mutilatedleftarm or affs.mangledleftarm or affs.mangledrightarm or affs.parestoarms) and not (affs.mutilatedrightleg or affs.mutilatedleftleg or affs.mangledleftleg or affs.mangledrightleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("unknowncrippledlimb")
      end,

      applycure = {"mending", "renewal"},
      actions = {"apply mending", "apply renewal"},
      onstart = function ()
        apply(dict.unknowncrippledlimb.salve)
      end,

      noeffect = function ()
        lostbal_salve()
        empty.apply_mending()
      end,

      fizzled = function ()
        lostbal_salve()
        -- if it fizzled, then it means we've got a resto break on arms or legs
        -- applying resto without targetting a limb doesn't work, so try mending on both, see what happens
        removeaff("unknowncrippledlimb")
        addaff(dict.unknowncrippledarm)
        addaff(dict.unknowncrippledleg)
        tempTimer(0, function() show_info("some limb broken?", "It would seem an arm or a leg of yours is broken (the salve fizzled), not just crippled - going to work out which is it and fix it") end)
      end,
    },
    aff = {
      oncompleted = function (amount)
        dict.unknowncrippledlimb.count = dict.unknowncrippledlimb.count + (amount or 1)
        if dict.unknowncrippledlimb.count > 4 then dict.unknowncrippledlimb.count = 4 end
        addaff(dict.unknowncrippledlimb)
        updateaffcount(dict.unknowncrippledlimb)
      end
    },
    gone = {
      oncompleted = function ()
        dict.unknowncrippledlimb.count = 0
        removeaff("unknowncrippledlimb")
      end,
    },
    onremoved = function ()
      if dict.unknowncrippledlimb.count <= 0 then return end

      dict.unknowncrippledlimb.count = dict.unknowncrippledlimb.count - 1
      if dict.unknowncrippledlimb.count <= 0 then return end
      addaff (dict.unknowncrippledlimb)
      updateaffcount(dict.unknowncrippledlimb)
    end,
  },
  unknowncrippledarm = {
    count = 0,
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknowncrippledarm and not (affs.mutilatedrightarm or affs.mutilatedleftarm or affs.mangledleftarm or affs.mangledrightarm or affs.parestoarms)) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("unknowncrippledarm")
      end,

      actions = {"apply mending to arms", "apply mending", "apply renewal to arms", "apply renewal"},
      applycure = {"mending", "renewal"},
      onstart = function ()
        apply(dict.unknowncrippledarm.salve, " to arms")
      end,

      noeffect = function ()
        lostbal_salve()
        empty.noeffect_mending_arms()
      end,

      fizzled = function (limb)
        lostbal_salve()
        if limb and dict["mangled"..limb] then addaff(dict["mangled"..limb]) end
      end,
    },
    aff = {
      oncompleted = function (amount)
        dict.unknowncrippledarm.count = dict.unknowncrippledarm.count + (amount or 1)
        if dict.unknowncrippledarm.count > 2 then dict.unknowncrippledarm.count = 2 end
        addaff(dict.unknowncrippledarm)
        updateaffcount(dict.unknowncrippledarm)
      end,
    },
    gone = {
      oncompleted = function ()
        dict.unknowncrippledarm.count = 0
        removeaff("unknowncrippledarm")
      end,
    },
    onremoved = function ()
      if dict.unknowncrippledarm.count <= 0 then return end

      dict.unknowncrippledarm.count = dict.unknowncrippledarm.count - 1
      if dict.unknowncrippledarm.count <= 0 then return end
      addaff (dict.unknowncrippledarm)
      updateaffcount(dict.unknowncrippledarm)
    end,
  },
  unknowncrippledleg = {
    count = 0,
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknowncrippledleg and not (affs.mutilatedrightleg or affs.mutilatedleftleg or affs.mangledleftleg or affs.mangledrightleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        removeaff("unknowncrippledleg")
      end,

      actions = {"apply mending to legs", "apply mending", "apply renewal to legs", "apply renewal"},
      applycure = {"mending", "renewal"},
      onstart = function ()
        apply(dict.unknowncrippledleg.salve, " to legs")
      end,

      noeffect = function ()
        lostbal_salve()
        empty.noeffect_mending_legs()
      end,

      fizzled = function (limb)
        lostbal_salve()
        if limb and dict["mangled"..limb] then addaff(dict["mangled"..limb]) end
      end,
    },
    aff = {
      oncompleted = function (amount)
        dict.unknowncrippledleg.count = dict.unknowncrippledleg.count + (amount or 1)
        if dict.unknowncrippledleg.count > 2 then dict.unknowncrippledleg.count = 2 end
        addaff(dict.unknowncrippledleg)
        updateaffcount(dict.unknowncrippledleg)
      end
    },
    gone = {
      oncompleted = function ()
        dict.unknowncrippledleg.count = 0
        removeaff("unknowncrippledleg")
      end,
    },
    onremoved = function ()
      if dict.unknowncrippledleg.count <= 0 then return end

      dict.unknowncrippledleg.count = dict.unknowncrippledleg.count - 1
      if dict.unknowncrippledleg.count <= 0 then return end
      addaff (dict.unknowncrippledleg)
      updateaffcount(dict.unknowncrippledleg)
    end,
  },
  unknowncure = {
    count = 0,
    waitingfor = {
      customwait = 999,

      onstart = function ()
      end,

      empty = function ()
      end
    },
    aff = {
      oncompleted = function (number)
        local count = dict.unknowncure.count
        addaff(dict.unknowncure)

        dict.unknowncure.count = (count or 0) + (number or 1)
        updateaffcount(dict.unknowncure)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("unknowncure")
        dict.unknowncure.count = 0
      end
    }
  },


-- writhes
  bound = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.bound and codepaste.writhe()) or false
      end,

      oncompleted = function ()
        doaction(dict.curingbound.waitingfor)
      end,

      action = "writhe",
      onstart = function ()
        send("writhe", conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        doaction(dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.bound)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("bound")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingbound = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("bound")
      end,

      onstart = function ()
      end
    }
  },
  webbed = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.webbed and codepaste.writhe() and not (bals.balance and bals.rightarm and bals.leftarm and dict.dragonflex.misc.isadvisable())
        ) or false
      end,

      oncompleted = function ()
        doaction(dict.curingwebbed.waitingfor)
      end,

      action = "writhe",
      onstart = function ()
        if math.random(1, 30) == 1 then
          send("writhe wiggle wiggle", conf.commandecho)
        else
          send("writhe", conf.commandecho)
        end
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        doaction(dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        affs.webbed = nil
        addaff(dict.webbed)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("webbed")
      end,
    },
    onremoved = function () signals.canoutr:emit() donext() end
  },
  curingwebbed = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("webbed")
      end,

      onstart = function ()
      end
    }
  },
  roped = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.roped and codepaste.writhe() and not (bals.balance and bals.rightarm and bals.leftarm and dict.dragonflex.misc.isadvisable())
        ) or false
      end,

      oncompleted = function ()
        doaction(dict.curingroped.waitingfor)
      end,

      action = "writhe",
      onstart = function ()
        send("writhe", conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        doaction(dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.roped)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("roped")
      end,
    },
    onremoved = function () signals.canoutr:emit() donext() end
  },
  curingroped = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("roped")
      end,

      onstart = function ()
      end
    }
  },
  hoisted = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,
      uncurable = true,

      isadvisable = function ()
        return (affs.hoisted and codepaste.writhe() and bals.balance and bals.rightarm and bals.leftarm) or false
      end,

      oncompleted = function ()
        doaction(dict.curinghoisted.waitingfor)
      end,

      action = "writhe",
      onstart = function ()
        send("writhe", conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        doaction(dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hoisted)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("hoisted")
      end,
    }
  },
  curinghoisted = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("hoisted")
      end,

      onstart = function ()
      end
    }
  },
  transfixed = {
    gamename = "transfixation",
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.transfixed and codepaste.writhe()) or false
      end,

      oncompleted = function ()
        doaction(dict.curingtransfixed.waitingfor)
      end,

      action = "writhe",
      onstart = function ()
        send("writhe", conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        doaction(dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        if not conf.aillusion or ((not affs.blindaff and not defc.blind) or lifevision.l.blindaff_aff or lifevision.l.blind_herb or lifevision.l.blind_misc) then
          affsp.transfixed = nil
          addaff(dict.transfixed)
        end

        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("transfixed")
      end,
    },
    onremoved = function () signals.canoutr:emit() donext() end
  },
  curingtransfixed = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("transfixed")
      end,

      onstart = function ()
      end
    }
  },
  impale = {
    gamename = "impaled",
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,


      isadvisable = function ()
        return (affs.impale and not doingaction("curingimpale") and not doingaction("impale") and bals.balance and bals.rightarm and bals.leftarm) or false
      end,

      oncompleted = function ()
        doaction(dict.curingimpale.waitingfor)
      end,

      action = "writhe",
      onstart = function ()
        send("writhe", conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      dragged = function()
        removeaff("impale")
      end,
    },
    aff = {
      oncompleted = function ()
        addaff(dict.impale)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("impale")
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingimpale = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        removeaff("impale")
      end,

      withdrew = function ()
        removeaff("impale")
      end,

      dragged = function()
        removeaff("impale")
      end,

      onstart = function ()
      end
    }
  },
  dragonflex = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (conf.dragonflex and ((affs.webbed and not ignore.webbed) or (affs.roped and not ignore.roped)) and codepaste.writhe() and not affs.paralysis and defc.dragonform and bals.balance and not doingaction"impale") or false
      end,

      oncompleted = function ()
        removeaff{"webbed", "roped"}
      end,

      action = "dragonflex",
      onstart = function ()
        send("dragonflex", conf.commandecho)
      end
    },
  },


  -- anti-illusion checks, grouped by symptom similarity
  checkslows = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (next(affsp) and (affsp.retardation or affsp.aeon or affsp.truename)) or false
      end,

      oncompleted = function () end,

      sluggish = function ()
        if affsp.retardation then
          affsp.retardation = nil
          addaff (dict.retardation)
          signals.newroom:unblock(sk.check_retardation)
        elseif affsp.aeon then
          affsp.aeon = nil

          addaff(dict.aeon)
          defences.lost("speed")
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        elseif affsp.truename then
          affsp.truename = nil

          addaff(dict.aeon)
          defences.lost("speed")
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end

        sk.checkaeony()
        signals.aeony:emit()
        codepaste.badaeon()
      end,

      onclear = function ()
        if affsp.retardation then
          affsp.retardation = nil
        elseif affsp.aeon then
          affsp.aeon = nil
        elseif affsp.truename then
          affsp.truename = nil
        end
      end,

      onstart = function ()
        send("say", false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (which)
      if paragraph_length > 2 or ignore.checkslows then
          if which == "truename" then which = "aeon" end

          addaff(dict[which])
          killaction (dict.checkslows.misc)

          if which == "aeon" then defences.lost("speed") end
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)

          sk.checkaeony()
          signals.aeony:emit()
          codepaste.badaeon()

          if which == 'retardation' then
            signals.newroom:unblock(sk.check_retardation)
          end
        else
          affsp[which] = true
        end
      end,

      truename = function()
        affsp.truename = true
      end,
    },
  },

  checkanorexia = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affsp.anorexia) or false
      end,

      oncompleted = function () end,

      blehfood = function ()
        addaff(dict.anorexia)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        affsp.anorexia = nil
      end,

      onclear = function ()
        affsp.anorexia = nil
      end,

      onstart = function ()
        send("eat something", false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function ()
        if paragraph_length > 2 then
          addaff(dict.anorexia)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          killaction (dict.checkanorexia.misc)
        else
          affsp.anorexia = true
        end

        -- register it as a possible hypochondria symptom
        if paragraph_length == 1 then
          sk.hypochondria_symptom()
        end
      end
    },
  },

  checkparalysis = {
    description = "anti-illusion check for paralysis",
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return false -- hardcoded to be off, as there's no known solution currently that works
        --return (affsp.paralysis and not affs.sleep and (not conf.waitparalysisai or (bals.balance and bals.equilibrium)) and not affs.roped) or false
      end,

      oncompleted = function () end,

      paralysed = function ()
        addaff(dict.paralysis)

        if dict.relapsing.saw_with_checkable == "paralysis" then
          dict.relapsing.saw_with_checkable = nil
          addaff(dict.relapsing)
        end

        if type(affsp.paralysis) == "string" then
          addaff(dict[affsp.paralysis])
        end
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        affsp.paralysis = nil
      end,

      onclear = function ()
        affsp.paralysis = nil
      end,

      onstart = function ()
        send("fling paralysis", false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (withaff) -- ie, "darkshade" - add the additional aff if we have paralysis
        -- disabled, as fling no longer works and illusions are not so prevalent
        if true then
        -- if paragraph_length > 2 or (not (bals.balance and bals.equilibrium) and not conf.waitparalysisai) then -- if it's not an illusion for sure, or if we have waitparalysisai off and don't have both balance/eq, accept it as paralysis right now
          addaff(dict.paralysis)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          killaction(dict.checkparalysis.misc)
          if withaff then addaff(dict[withaff]) end
        else -- else, it gets added to be checked later if we have waitparalysisai on and don't have balance or eq
          affsp.paralysis = withaff or true
        end
      end
    },
  },

  checkimpatience = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affsp.impatience and not affs.sleep and bals.focus and conf.focus) or false
      end,

      oncompleted = function () end,

      impatient = function ()
        if not affs.impatience then
          addaff(dict.impatience)
          echof("Looks like the impatience is real.")
        end

        affsp.impatience = nil
      end,

      -- if serverside cures impatience before we can even validate it, cancel it
      oncancel = function ()
        affsp.impatience = nil
        killaction (dict.checkimpatience.misc)
      end,

      onclear = function ()
        if affsp.impatience then
          lostbal_focus()
          if affsp.impatience ~= "quiet" then
            echof("The impatience earlier was actually an illusion, ignoring it.")
          end
          affsp.impatience = nil
        end
      end,

      onstart = function ()
        send("focus", false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (option)
        if paragraph_length > 2 then
          addaff(dict.impatience)
          killaction (dict.checkimpatience.misc)
        else
          affsp.impatience = option and option or true
        end
      end
    },
  },

  checkasthma = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affsp.asthma and conf.breath and bals.balance and bals.equilibrium) or false
      end,

      oncompleted = function () end,

      weakbreath = function ()
        addaff(dict.asthma)
        local r = findbybal("smoke")
        if r then
          killaction(dict[r.action_name].smoke)
        end

        if dict.relapsing.saw_with_checkable == "asthma" then
          dict.relapsing.saw_with_checkable = nil
          addaff(dict.relapsing)
        end

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        affsp.asthma = nil
        codepaste.badaeon()
      end,

      onclear = function ()
        affsp.asthma = nil
      end,

      onstart = function ()
        send("hold breath", conf.commandecho)
      end
    },
    smoke = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affsp.asthma and not dict.checkasthma.misc.isadvisable() and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        lostbal_smoke()
      end,

      badlungs = function ()
        addaff(dict.asthma)
        local r = findbybal("smoke")
        if r then
          killaction(dict[r.action_name].smoke)
        end

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        affsp.asthma = nil
      end,

      -- mucous can hit when we aren't even afflicted, so it's moot. Have to wait for it to clear up
      mucous = function()
      end,

      onclear = function ()
        affsp.asthma = nil
        lostbal_smoke()
      end,

      empty = function()
        affsp.asthma = nil
        lostbal_smoke()
      end,

      smokecure = {"valerian", "realgar"},
      onstart = function ()
        send("smoke " .. pipes.valerian.id, conf.commandecho)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (oldhp)
      if paragraph_length > 2 or (oldhp and stats.currenthealth < oldhp) or (paragraph_length == 2 and find_until_last_paragraph("aura of weapons rebounding disappears", "substring")) then
          addaff(dict.asthma)
          local r = findbybal("smoke")
          if r then
            killaction(dict[r.action_name].smoke)
          end

          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          killaction (dict.checkasthma.misc)

          -- if we were checking and we got a verified aff, kill verification
          if actions.checkasthma_smoke then
            killaction (dict.checkasthma.smoke)
          end
        else
          affsp.asthma = true
        end
      end
    },
  },

  checkhypersomnia = {
    description = "anti-illusion check for hypersomnia",
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affsp.hypersomnia and not affs.sleep) or false
      end,

      oncompleted = function () end,

      hypersomnia = function ()
        addaff(dict.hypersomnia)

        affsp.hypersomnia = nil
      end,

      onclear = function ()
        affsp.hypersomnia = nil
      end,

      onstart = function ()
        send("insomnia", conf.commandecho)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function ()
        -- can't check hypersomnia with insomina up - it'll give the insomnia
        -- def line
        if paragraph_length > 2 or defc.insomnia then
          addaff(dict.hypersomnia)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          killaction(dict.checkhypersomnia.misc)
        else
          affsp.hypersomnia = true
        end
      end
    },
  },

  checkstun = {
    templifevision = false, -- stores the lifevision actions that will be wiped until confirmed
    tempactions = false, -- stores the actions queue items that will be wiped until confirmed
    time = 0,
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affsp.stun) or false
      end,

      oncompleted = function (data)
        -- 'fromstun' is given to us if we just had started checking for stun with checkstun_misc, and stun wore off before we could finish - for this rare scenario, we complete checkstun
        if data ~= "fromstun" then dict.stun.aff.oncompleted(dict.checkstun.time) end
        dict.checkstun.time = 0
        affsp.stun = nil
        tempTimer(0, function ()
          if not dict.checkstun.templifevision then return end

          lifevision.l = deepcopy(dict.checkstun.templifevision)
          dict.checkstun.templifevision = nil

          if lifevision.l.checkstun_aff then
            lifevision.l:set("checkstun_aff", nil)
          end

          for k,v in dict.checkstun.tempactions:iter() do
            if actions[k] then
              debugf("%s already exists, overwriting it", k)
            else
              debugf("re-added %s", k)
            end

            actions[k] = v
          end

          dict.checkstun.tempactions = nil
          send_in_the_gnomes()
        end)
      end,

      onclear = function ()
        affsp.stun = nil
        dict.checkstun.templifevision = nil
        dict.checkstun.tempactions = nil
      end,

      onstart = function ()
        send("eat something", false)
      end
    },
    aff = {
      -- this is an affliction for svo's purposes, but not in the game. Although it would be best if the 'aff' balance was replaced with something else
      notagameaff = true,
      oncompleted = function (num)
      if paragraph_length > 2 then
          dict.stun.aff.oncompleted()
          killaction (dict.checkstun.misc)
        elseif not affs.sleep and not conf.paused then -- let autodetection take care of after we wake up. otherwise, a well timed stun & stun symptom on awake can trick us. if paused, let it through as well, because we don't want to kill affs
          affsp.stun = true
          dict.checkstun.time = num
          dict.checkstun.templifevision = deepcopy(lifevision.l)
          dict.checkstun.tempactions = deepcopy(actions)
          sk.stopprocessing = true
        end
      end
    },
  },

  checkwrithes = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (next(affsp) and ((affsp.impale and not affs.transfixed and not affs.webbed and not affs.roped) or (affsp.webbed and not affs.transfixed and not affs.roped) or affsp.transfixed)) or false
      end,

      oncompleted = function () end,

      webbily = function ()
        affsp.webbed = nil
        addaff(dict.webbed)
        signals.canoutr:emit()
      end,

      impaly = function ()
        affsp.impale = nil
        addaff(dict.impale)
        signals.canoutr:emit()
      end,

      transfixily = function ()
        affsp.transfixed = nil
        addaff(dict.transfixed)
        signals.canoutr:emit()
      end,

      onclear = function ()
        affsp.impale = nil
        affsp.webbed = nil
        affsp.transfixed = nil
      end,

      onstart = function ()
        send("outr", false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (which)
        if paragraph_length > 2 then
          addaff(dict[which])
          killaction (dict.checkwrithes.misc)
        else
          affsp[which] = true
        end
      end,

      impale = function (oldhp)
        if (oldhp and stats.currenthealth < oldhp) then
          addaff(dict.impale)
          signals.canoutr:emit()
        else
          affsp.impale = true
        end
      end
    }
  },
  amnesia = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.amnesia) or false
      end,

      oncompleted = function ()
      end,

      onstart = function ()
        send("touch stuff", conf.commandecho)
        removeaff("amnesia")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.amnesia)

        -- cancel what we were doing, do it again
        if sys.sync then
          local result
          for balance,actions in pairs(bals_in_use) do
            if balance ~= "waitingfor" and balance ~= "gone" and balance ~= "aff" and next(actions) then result = select(2, next(actions)) break end
          end
          if result then
            killaction(dict[result.action_name][result.balance])
          end

          svo.conf.send_bypass = true
          send("touch stuff", conf.commandecho)
          svo.conf.send_bypass = false
        end
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("amnesia")
      end,
    }
  },

  -- uncurable
  stun = {
    waitingfor = {
      customwait = 1,

      isadvisable = function ()
        return false
      end,

      ontimeout = function ()
        removeaff("stun")

        if dict.checkstun.templifevision then
          dict.checkstun.misc.oncompleted("fromstun")
          make_gnomes_work()
        end

      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("stun")

        if dict.checkstun.templifevision then
          dict.checkstun.misc.oncompleted("fromstun")
        end
      end
    },
    aff = {
      oncompleted = function (num)
        if affs.stun then return end

        dict.stun.waitingfor.customwait = (num and num ~= 0) and num or 1
        addaff(dict.stun)
        doaction(dict.stun.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("stun")
        killaction (dict.stun.waitingfor)
      end,
    },
    onremoved = function () donext() end
  },
  unconsciousness = {
    waitingfor = {
      customwait = 7,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        removeaff("unconsciousness")
        make_gnomes_work()
      end,

      oncompleted = function ()
        removeaff("unconsciousness")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.unconsciousness)
        if not actions.unconsciousness_waitingfor then doaction(dict.unconsciousness.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("unconsciousness")
        killaction (dict.unconsciousness.waitingfor)
      end,
    },
    onremoved = function () donext() end
  },
  swellskin = { -- eating any herb cures it
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("swellskin")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.swellskin)
        if not actions.swellskin_waitingfor then doaction(dict.swellskin.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("swellskin")
        killaction (dict.swellskin.waitingfor)
      end,
    }
  },
  pinshot = {
    waitingfor = {
      customwait = 20, -- lasts 18s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        removeaff("pinshot")
        make_gnomes_work()
      end,

      oncompleted = function ()
        removeaff("pinshot")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.pinshot)
        if not actions.pinshot_waitingfor then doaction(dict.pinshot.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("pinshot")
        killaction (dict.pinshot.waitingfor)
      end,
    }
  },
  dehydrated = {
    waitingfor = {
      customwait = 45, -- lasts 45s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        removeaff("dehydrated")
        make_gnomes_work()
      end,

      oncompleted = function ()
        removeaff("dehydrated")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.dehydrated)
        if not actions.dehydrated_waitingfor then doaction(dict.dehydrated.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("dehydrated")
        killaction (dict.dehydrated.waitingfor)
      end,
    }
  },
  timeflux = {
    waitingfor = {
      customwait = 50, -- lasts 50s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        removeaff("timeflux")
        make_gnomes_work()
      end,

      oncompleted = function ()
        removeaff("timeflux")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.timeflux)
        if not actions.timeflux_waitingfor then doaction(dict.timeflux.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("timeflux")
        killaction (dict.timeflux.waitingfor)
      end,
    }
  },
  inquisition = {
    waitingfor = {
      customwait = 30, -- ??

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("inquisition")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.inquisition)
        if not actions.inquisition_waitingfor then doaction(dict.inquisition.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("inquisition")
        killaction (dict.inquisition.waitingfor)
      end,
    }
  },
  lullaby = {
    waitingfor = {
      customwait = 45, -- takes 45s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("lullaby")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.lullaby)
        if not actions.lullaby_waitingfor then doaction(dict.lullaby.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("lullaby")
        killaction (dict.lullaby.waitingfor)
      end,
    }
  },
  corrupted = {
    waitingfor = {
      customwait = 999, -- time increases

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("corrupted")
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.corrupted)
        if not actions.corrupted_waitingfor then doaction(dict.corrupted.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("corrupted")
        killaction (dict.corrupted.waitingfor)
      end,
    }
  },
  mucous = {
    waitingfor = {
      customwait = 6,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("mucous")
      end,

      ontimeout = function()
        removeaff("mucous")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.mucous)
        if not actions.mucous_waitingfor then doaction(dict.mucous.waitingfor) end

        local r = findbybal("smoke")
        if r then
          killaction(dict[r.action_name].smoke)
        end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("mucous")
        killaction (dict.mucous.waitingfor)
      end,
    }
  },
  phlogistication = {
    waitingfor = {
      customwait = 999, -- time increases

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("phlogistication")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.phlogistication)
        if not actions.phlogistication_waitingfor then doaction(dict.phlogistication.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("phlogistication")
        killaction (dict.phlogistication.waitingfor)
      end,
    }
  },
  vitrification = {
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("vitrification")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.vitrification)
        if not actions.vitrification_waitingfor then doaction(dict.vitrification.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("vitrification")
        killaction (dict.vitrification.waitingfor)
      end,
    }
  },

  icing = {
    waitingfor = {
      customwait = 30, -- ??

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("icing")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.icing)
        if not actions.icing_waitingfor then doaction(dict.icing.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("icing")
        killaction (dict.icing.waitingfor)
      end,
    }
  },
  burning = {
    waitingfor = {
      customwait = 30, -- ??

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("burning")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.burning)
        if not actions.burning_waitingfor then doaction(dict.burning.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("burning")
        killaction (dict.burning.waitingfor)
      end,
    }
  },
  voided = {
    waitingfor = {
      customwait = 20, -- lasts 20s tops, 15s in some stances. out-times multiple pommelstrikes

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("voided")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.voided)
        codepaste.badaeon()
        if not actions.voided_waitingfor then doaction(dict.voided.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("voided")
        killaction (dict.voided.waitingfor)
      end,
    }
  },
  hamstring = {
    waitingfor = {
      customwait = 10,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        if affs.hamstring then
          removeaff("hamstring")
          echof("Hamstring should have worn off by now, removing it.")
        end
      end,

      oncompleted = function ()
        removeaff("hamstring")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hamstring)
        if not actions.hamstring_waitingfor then doaction(dict.hamstring.waitingfor) end
      end,

      renew = function ()
        addaff(dict.hamstring)

        -- hamstrings timer gets renewed on hit
        if actions.hamstring_waitingfor then
          killaction (dict.hamstring.waitingfor)
        end
        doaction(dict.hamstring.waitingfor)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("hamstring")
        killaction (dict.hamstring.waitingfor)
      end,
    }
  },
  galed = {
    waitingfor = {
      customwait = 10,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("galed")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.galed)
        if not actions.galed_waitingfor then doaction(dict.galed.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("galed")
        killaction (dict.galed.waitingfor)
      end,
    }
  },
  rixil = {
    -- will double the cooldown period of the next focus ability.
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("rixil")
        killaction (dict.rixil.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.rixil)
        if actions.rixil_waitingfor then killaction(dict.rixil.waitingfor) end
        doaction(dict.rixil.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("rixil")
        killaction (dict.rixil.waitingfor)
      end,
    }
  },
  hecate = {
    waitingfor = {
      customwait = 22, -- seems to last at least 18s per log

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
        removeaff("hecate")
        killaction (dict.hecate.waitingfor)
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("hecate")
        killaction (dict.hecate.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.hecate)
        if actions.hecate_waitingfor then killaction(dict.hecate.waitingfor) end
        doaction(dict.hecate.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("hecate")
        killaction (dict.hecate.waitingfor)
      end,
    }
  },
  palpatar = {
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("palpatar")
        killaction (dict.palpatar.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.palpatar)
        if actions.palpatar_waitingfor then killaction(dict.palpatar.waitingfor) end
        doaction(dict.palpatar.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("palpatar")
        killaction (dict.palpatar.waitingfor)
      end,
    }
  },
  -- extends tree balance by 10s now
  ninkharsag = {
    waitingfor = {
      customwait = 60, -- it lasts a minute

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
        removeaff("ninkharsag")
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("ninkharsag")
        killaction (dict.ninkharsag.waitingfor)
      end,

    },
    aff = {
      oncompleted = function ()
        addaff(dict.ninkharsag)
        if actions.ninkharsag_waitingfor then killaction(dict.ninkharsag.waitingfor) end
        doaction(dict.ninkharsag.waitingfor)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("ninkharsag")
        killaction (dict.ninkharsag.waitingfor)
      end,

      -- anti-illusion-checked aff hiding. in 'gone' because 'aff' resets the timer with checkaction, waitingfor has some other effect
      hiddencures = function (amount)
        local curableaffs = svo.gettreeableaffs()

        -- if we saw more ninkharsag lines than affs we've got, we can remove the affs safely
        if amount >= #curableaffs then
          removeaff(curableaffs)
        else
          -- otherwise add an unknown aff - so we eventually diagnose to see what is our actual aff status like.
          -- this does mess with the aff counts, but it is better than not diagnosing ever.
          codepaste.addunknownany()
        end
      end
    }
  },
  cadmus = {
    -- focusing will give one of: lethargy, clumsiness, haemophilia, healthleech, sensitivity, darkshade
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("cadmus")
        killaction (dict.cadmus.waitingfor)
      end
    },
    aff = {
      oncompleted = function (oldmaxhp)
        addaff(dict.cadmus)
        if actions.cadmus_waitingfor then killaction(dict.cadmus.waitingfor) end
        doaction(dict.cadmus.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("cadmus")
        killaction (dict.cadmus.waitingfor)
      end,
    }
  },
  spiritdisrupt = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.spiritdisrupt and not affs.madness and
          not doingaction("spiritdisrupt")) or false
      end,

      oncompleted = function ()
        removeaff("spiritdisrupt")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.spiritdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.spiritdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("spiritdisrupt")
        codepaste.remove_focusable()
      end,
    }
  },
  airdisrupt = {
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.airdisrupt and not affs.spiritdisrupt) or false
      end,

      oncompleted = function ()
        removeaff("airdisrupt")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.airdisrupt and not doingaction("airdisrupt")) or false
      end,

      oncompleted = function ()
        removeaff("airdisrupt")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.airdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.airdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("airdisrupt")
        codepaste.remove_focusable()
      end,
    }
  },
  earthdisrupt = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.earthdisrupt and not doingaction("earthdisrupt")) or false
      end,

      oncompleted = function ()
        removeaff("earthdisrupt")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.earthdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.earthdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("earthdisrupt")
        codepaste.remove_focusable()
      end,
    }
  },
  waterdisrupt = {
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.waterdisrupt and not affs.spiritdisrupt) or false
      end,

      oncompleted = function ()
        removeaff("waterdisrupt")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.waterdisrupt and not doingaction("waterdisrupt")) or false
      end,

      oncompleted = function ()
        removeaff("waterdisrupt")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.waterdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.waterdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("waterdisrupt")
        codepaste.remove_focusable()
      end,
    }
  },
  firedisrupt = {
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.firedisrupt and not affs.spiritdisrupt) or false
      end,

      oncompleted = function ()
        removeaff("firedisrupt")
        lostbal_focus()
      end,

      action = "focus",
      onstart = function ()
        send("focus", conf.commandecho)
      end,

      empty = function ()
        lostbal_focus()

        empty.focus()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.firedisrupt and not doingaction("firedisrupt")) or false
      end,

      oncompleted = function ()
        removeaff("firedisrupt")
        lostbal_herb()
      end,

      eatcure = {"lobelia", "argentum"},
      onstart = function ()
        eat(dict.firedisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        addaff(dict.firedisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("firedisrupt")
        codepaste.remove_focusable()
      end,
    }
  },
  stain = {
    waitingfor = {
      customwait = 60*2+20, -- lasts 2min, but varies, so let's go with 140s

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
        removeaff("stain")
        echof("Taking a guess, I think stain expired by now.")
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("stain")
        make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function (oldmaxhp)
        -- oldmaxhp doesn't come from diag, it is optional
        if (not conf.aillusion) or (oldmaxhp and (stats.maxhealth < oldmaxhp)) then
          addaff(dict.stain)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          codepaste.badaeon()
          if actions.stain_waitingfor then killaction(dict.stain.waitingfor) end
          doaction(dict.stain.waitingfor)
        end
      end
    },
    gone = {
      oncompleted = function ()
        removeaff("stain")
        killaction (dict.stain.waitingfor)
      end,
    }
  },
  retardation = {
    waitingfor = {
      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        removeaff("retardation")
      end
    },
    aff = {
      oncompleted = function ()
        if not affs.retardation then
          addaff(dict.retardation)
          sk.checkaeony()
          signals.aeony:emit()
          signals.newroom:unblock(sk.check_retardation)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        removeaff("retardation")
      end,
    },
    onremoved = function ()
      affsp.retardation = nil
      sk.checkaeony()
      signals.aeony:emit()
      signals.newroom:block(sk.check_retardation)
    end,
    onadded = function()
      signals.newroom:unblock(sk.check_retardation)
    end
  },
  nomana = {
    waitingfor = {
      customwait = 30,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,
      ontimeout = function ()
        echo"\n"echof("Hm, maybe we have enough mana for mana skills now...")
        killaction (dict.nomana.waitingfor)
        make_gnomes_work()
      end
    }
  },

-- random actions that should be protected by AI
  givewarning = {
    happened = {
      oncompleted = function (tbl)
        if tbl and tbl.initialmsg then
          echo"\n\n"
          echof("Careful: %s", tbl.initialmsg)
          echo"\n"
        end

        if tbl and tbl.prefixwarning then
          local duration = tbl.duration or 4
          local startin = tbl.startin or 0
          cnrl.warning = tbl.prefixwarning or ""

          -- timer for starting
          if not conf.warningtype then return end

          tempTimer(startin, function ()

            if cnrl.warnids[tbl.prefixwarning] then killTrigger(cnrl.warnids[tbl.prefixwarning]) end

              cnrl.warnids[tbl.prefixwarning] = tempRegexTrigger('^', [[
                if ((svo.conf.warningtype == "prompt" and isPrompt()) or svo.conf.warningtype == "all" or svo.conf.warningtype == "right") and getCurrentLine() ~= "" and not svo.gagline then
                  svo.prefixwarning()
                end
              ]])
            end)

          -- timer for ending
          tempTimer(startin+duration, function () killTrigger(cnrl.warnids[tbl.prefixwarning]) end)
        end
      end
    }
  },
  stolebalance = {
    happened = {
      oncompleted = function (balance)
        svo["lostbal_"..balance]()
      end
    }
  },
  gotbalance = {
    happened = {
      tempmap = {},
      oncompleted = function ()
        for _, balance in ipairs(dict.gotbalance.happened.tempmap) do
          if not bals[balance] then
            bals[balance] = true

            raiseEvent("svo got balance", balance)

            endbalancewatch(balance)

            -- this concern should be separated into its own
            if balance == "tree" then
              killTimer(sys.treetimer)
            end
          end
        end
        dict.gotbalance.happened.tempmap = {}
      end,

      oncancel = function ()
        dict.gotbalance.happened.tempmap = {}
      end
    }
  },
  gothit = {
    happened = {
      tempmap = {},
      oncompleted = function ()
        for name, class in pairs(dict.gothit.happened.tempmap) do
          if name == '?' then
            raiseEvent("svo got hit by", class)
          else
            raiseEvent("svo got hit by", class, name)
          end
        end
        dict.gothit.happened.tempmap = {}
      end,

      oncancel = function ()
        dict.gothit.happened.tempmap = {}
      end
    }
  },

-- general defences
  rebounding = {
    blocked = false, -- we need to block off in blackout, because otherwise we waste sips
    smoke = {
      aspriority = 137,
      spriority = 261,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].rebounding and not defc.rebounding) or (conf.keepup and defkeepup[defs.mode].rebounding and not defc.rebounding)) and codepaste.smoke_skullcap_pipe() and not doingaction("waitingonrebounding") and not dict.rebounding.blocked) or false
      end,

      oncompleted = function ()
        doaction(dict.waitingonrebounding.waitingfor)
        sk.skullcap_smokepuff()
        lostbal_smoke()
      end,

      alreadygot = function ()
        defences.got("rebounding")
        sk.skullcap_smokepuff()
        lostbal_smoke()
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        dict.rebounding.blocked = true
        tempTimer(3, function () dict.rebounding.blocked = false; make_gnomes_work() end)
      end,

      smokecure = {"skullcap", "malachite"},
      onstart = function ()
        send("smoke " .. pipes.skullcap.id, conf.commandecho)
      end,

      empty = function ()
        dict.rebounding.smoke.oncompleted()
      end
    }
  },
  waitingonrebounding = {
    spriority = 0,
    waitingfor = {
      customwait = 9,

      onstart = function () raiseEvent("svo rebounding start") end,

      oncompleted = function ()
        defences.got("rebounding")
      end,

      deathtarot = function () -- nothing happens! It just doesn't come up :/
      end,

      -- expend torso cancels rebounding coming up
      expend = function()
        if actions.waitingonrebounding_waitingfor then
          killaction(dict.waitingonrebounding.waitingfor)
        end
      end,
    }
  },
  frost = {
    purgative = {
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].frost and not defc.frost) or (conf.keepup and defkeepup[defs.mode].frost and not defc.frost)) or false
      end,

      oncompleted = function ()
        defences.got("frost")
      end,

      sipcure = {"frost", "endothermia"},

      onstart = function ()
        sip(dict.frost.purgative)
      end,

      empty = function ()
        defences.got("frost")
      end,

      noeffect = function()
        defences.got("frost")
      end
    },
    gone = {
      oncompleted = function ()
      end
    }
  },
  venom = {
    gamename = "poisonresist",
    purgative = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].venom and not defc.venom) or (conf.keepup and defkeepup[defs.mode].venom and not defc.venom)) or false
      end,

      oncompleted = function ()
        defences.got("venom")
      end,

      noeffect = function()
        defences.got("venom")
      end,

      sipcure = {"venom", "toxin"},

      onstart = function ()
        sip(dict.venom.purgative)
      end,

      empty = function ()
        defences.got("venom")
      end
    }
  },
  levitation = {
    gamename = "levitating",
    purgative = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].levitation and not defc.levitation) or (conf.keepup and defkeepup[defs.mode].levitation and not defc.levitation)) or false
      end,

      oncompleted = function ()
        defences.got("levitation")
      end,

      noeffect = function()
        defences.got("levitation")
      end,

      sipcure = {"levitation", "hovering"},

      onstart = function ()
        sip(dict.levitation.purgative)
      end,

      empty = function ()
        defences.got("levitation")
      end
    }
  },
  speed = {
    blocked = false, -- we need to block off in blackout, because otherwise we waste sips
    purgative = {
      aspriority = 8,
      spriority = 265,
      def = true,

      isadvisable = function ()
        return (not defc.speed and ((sys.deffing and defdefup[defs.mode].speed) or (conf.keepup and defkeepup[defs.mode].speed)) and not doingaction("curingspeed") and not doingaction("speed") and not dict.speed.blocked and not me.manualdefcheck) or false
      end,

      oncompleted = function (def)
        if def then defences.got("speed")
        else
          if affs.palpatar then
            dict.curingspeed.waitingfor.customwait = 10
          else
            dict.curingspeed.waitingfor.customwait = 7
          end

          doaction(dict.curingspeed.waitingfor)
        end
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        dict.speed.blocked = true
        tempTimer(3, function () dict.speed.blocked = false; make_gnomes_work() end)
      end,

      noeffect = function()
        defences.got("speed")
      end,

      sipcure = {"speed", "haste"},

      onstart = function ()
        sip(dict.speed.purgative)
      end,

      empty = function ()
        dict.speed.purgative.oncompleted ()
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost("speed")
      end
    }
  },
  curingspeed = {
    spriority = 0,
    waitingfor = {
      customwait = 7,

      oncompleted = function ()
        defences.got("speed")
      end,

      ontimeout = function ()
        if defc.speed then return end

        if (sys.deffing and defdefup[defs.mode].speed) or (conf.keepup and defkeepup[defs.mode].speed) then
          echof("Warning - speed didn't come up in 7s, checking 'def'.")
          me.manualdefcheck = true
        end
      end,

      onstart = function () end
    }
  },
  sileris = {
    gamename = "fangbarrier",
    applying = "",
    misc = {
      aspriority = 8,
      spriority = 265,
      def = true,

      isadvisable = function ()
        return (not defc.sileris and ((sys.deffing and defdefup[defs.mode].sileris) or (conf.keepup and defkeepup[defs.mode].sileris)) and not doingaction("waitingforsileris") and not doingaction("sileris") and not affs.paralysis and not affs.slickness and not me.manualdefcheck) or false
      end,

      oncompleted = function (def)
        if def and not defc.sileris then defences.got("sileris")
        else doaction(dict.waitingforsileris.waitingfor) end
      end,

      slick = function()
        addaff(dict.slickness)
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        dict.sileris.blocked = true
        tempTimer(3, function () dict.sileris.blocked = false; make_gnomes_work() end)
      end,

      -- special case for 'missing herb' trig
      eatcure = {"sileris", "quicksilver"},
      applycure = {"sileris", "quicksilver"},
      actions = {"apply sileris", "apply quicksilver"},
      onstart = function ()
        local use = "sileris"

        if conf.curemethod and conf.curemethod ~= "conconly" and (

          conf.curemethod == "transonly" or

          (conf.curemethod == "preferconc" and
            -- we don't have in inventory, but do have alchemy in inventory, use alchemy
             (not (rift.invcontents.sileris > 0) and (rift.invcontents.quicksilver > 0)) or
              -- or if we don't have the conc cure in rift either, use alchemy
             (not (rift.riftcontents.sileris > 0))) or

          (conf.curemethod == "prefertrans" and
            (rift.invcontents.quicksilver > 0
              or (not (rift.invcontents.sileris > 0) and (rift.riftcontents.quicksilver > 0)))) or

          -- prefercustom, and we either prefer alchy and have it, or prefer conc and don't have it
          (conf.curemethod == "prefercustom" and (
            (me.curelist[use] == use and rift.riftcontents[use] <= 0)
              or
            (me.curelist[use] == "quicksilver" and rift.riftcontents["quicksilver"] > 0)
          ))

          ) then
            use = "quicksilver"
        end

        sys.last_used["sileris_misc"] = use

        dict.sileris.applying = use
        if rift.invcontents[use] > 0 then
          send("outr "..use, conf.commandecho)
          send("apply "..use, conf.commandecho)
        else
          send("outr "..use, conf.commandecho)
          send("apply "..use, conf.commandecho)
        end
      end,

      empty = function ()
        dict.sileris.misc.oncompleted()
      end
    },
    gone = {
      oncompleted = function (line_spotted_on)
        if not conf.aillusion or not line_spotted_on or (line_spotted_on+1 == getLastLineNumber("main")) then
          defences.lost("sileris")
        end
      end,

      camusbite = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth < oldhp) then
          defences.lost("sileris")
        end
      end,

      sumacbite = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth < oldhp) then
          defences.lost("sileris")
        end
      end,
    }
  },
  waitingforsileris = {
    spriority = 0,
    waitingfor = {
      customwait = 8,

      oncompleted = function ()
        defences.got("sileris")
      end,

      ontimeout = function ()
        if defc.sileris then return end

        if (sys.deffing and defdefup[defs.mode].sileris) or (conf.keepup and defkeepup[defs.mode].sileris) then
          echof("Warning - sileris isn't back yet, we might've been tricked. Going to see if we get bitten.")
          local oldsileris = defc.sileris
          defc.sileris = "unsure"
          if oldsileris ~= defc.sileris then raiseEvent("svo got def", "sileris") end
        end
      end,

      onstart = function () end
    }
  },
  deathsight = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.deathsight and (not conf.deathsight or not can_usemana()) and ((sys.deffing and defdefup[defs.mode].deathsight) or (conf.keepup and defkeepup[defs.mode].deathsight)) and not doingaction("deathsight")) or false
      end,

      oncompleted = function ()
        defences.got("deathsight")
      end,

      eatcure = {"skullcap", "azurite"},
      onstart = function ()
        eat(dict.deathsight.herb)
      end,

      empty = function()
        defences.got("deathsight")
      end
    },
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        return (not defc.deathsight and conf.deathsight and can_usemana() and not doingaction("deathsight") and ((sys.deffing and defdefup[defs.mode].deathsight) or (conf.keepup and defkeepup[defs.mode].deathsight)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got("deathsight")
      end,

      action = "deathsight",
      onstart = function ()
        send("deathsight", conf.commandecho)
      end
    },
  },
  thirdeye = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].thirdeye and not defc.thirdeye) or (conf.keepup and defkeepup[defs.mode].thirdeye and not defc.thirdeye)) and not doingaction("thirdeye") and not (conf.thirdeye and can_usemana())) or false
      end,

      oncompleted = function ()
        defences.got("thirdeye")
      end,

      eatcure = {"echinacea", "dolomite"},
      onstart = function ()
        eat(dict.thirdeye.herb)
      end,

      empty = function()
        defences.got("thirdeye")
      end
    },
    misc = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (conf.thirdeye and can_usemana() and not doingaction("thirdeye") and ((sys.deffing and defdefup[defs.mode].thirdeye and not defc.thirdeye) or (conf.keepup and defkeepup[defs.mode].thirdeye and not defc.thirdeye))) or false
      end,

      -- by default, oncompleted means a clot went through okay
      oncompleted = function ()
        defences.got("thirdeye")
      end,

      action = "thirdeye",
      onstart = function ()
        send("thirdeye", conf.commandecho)
      end
    },
  },
  insomnia = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].insomnia and not defc.insomnia) or (conf.keepup and defkeepup[defs.mode].insomnia and not defc.insomnia)) and not doingaction("insomnia") and not (conf.insomnia and can_usemana()) and not affs.hypersomnia) or false
      end,

      oncompleted = function ()
        defences.got("insomnia")
      end,

      eatcure = {"cohosh", "gypsum"},
      onstart = function ()
        eat(dict.insomnia.herb)
      end,

      empty = function()
        defences.got("insomnia")
      end,

      hypersomnia = function ()
        addaff(dict.hypersomnia)
      end
    },
    misc = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (conf.insomnia and can_usemana() and not doingaction("insomnia") and ((sys.deffing and defdefup[defs.mode].insomnia and not defc.insomnia) or (conf.keepup and defkeepup[defs.mode].insomnia and not defc.insomnia)) and not affs.hypersomnia) or false
      end,

      oncompleted = function ()
        defences.got("insomnia")
      end,

      hypersomnia = function ()
        addaff(dict.hypersomnia)
      end,

      action = "insomnia",
      onstart = function ()
        send("insomnia", conf.commandecho)
      end
    },
    -- small cheat for insomnia being on diagnose
    aff = {
      oncompleted = function ()
        defences.got("insomnia")
      end
    },
    gone = {
      oncompleted = function(aff)
        defences.lost("insomnia")

        if aff and aff == "unknownany" then
          dict.unknownany.count = dict.unknownany.count - 1
          if dict.unknownany.count <= 0 then
            removeaff("unknownany")
            dict.unknownany.count = 0
          else
            updateaffcount(dict.unknownany)
          end
        elseif aff and aff == "unknownmental" then
          dict.unknownmental.count = dict.unknownmental.count - 1
          if dict.unknownmental.count <= 0 then
            removeaff("unknownmental")
            dict.unknownmental.count = 0
          else
            updateaffcount(dict.unknownmental)
          end
        end
      end,

      relaxed = function (line_spotted_on)
        if not conf.aillusion or not line_spotted_on or (line_spotted_on+1 == getLastLineNumber("main")) then
          defences.lost("insomnia")
        end
      end,
    }
  },
  myrrh = {
    gamename = "scholasticism",
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].myrrh and not defc.myrrh) or (conf.keepup and defkeepup[defs.mode].myrrh and not defc.myrrh))) or false
      end,

      oncompleted = function ()
        defences.got("myrrh")
      end,

      noeffect = function ()
        dict.myrrh.herb.oncompleted ()
      end,

      eatcure = {"myrrh", "bisemutum"},
      onstart = function ()
        eat(dict.myrrh.herb)
      end,

      empty = function()
        defences.got("myrrh")
      end
    },
  },
  kola = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].kola and not defc.kola) or (conf.keepup and defkeepup[defs.mode].kola and not defc.kola))) or false
      end,

      oncompleted = function ()
        defences.got("kola")
      end,

      noeffect = function ()
        dict.kola.herb.oncompleted ()
      end,

      eatcure = {"kola", "quartz"},
      onstart = function ()
        eat(dict.kola.herb)
      end,

      empty = function()
        defences.got("kola")
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not pflags.k then
          defences.lost("kola")
        end
      end
    }
  },
  mass = {
    gamename = "density",
    salve = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].mass and not defc.mass) or (conf.keepup and defkeepup[defs.mode].mass and not defc.mass))) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        defences.got("mass")
      end,

      -- sometimes a salve cure can get misgiagnosed on a death (from a previous apply)
      noeffect = function() end,
      empty = function() end,

      applycure = {"mass", "density"},
      actions = {"apply mass to body", "apply mass", "apply density to body", "apply density"},
      onstart = function ()
        apply(dict.mass.salve, " to body")
      end,
    },
  },
  caloric = {
    salve = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].caloric and not defc.caloric) or (conf.keepup and defkeepup[defs.mode].caloric and not defc.caloric))) or false
      end,

      oncompleted = function ()
        lostbal_salve()
        defences.got("caloric")
      end,

      noeffect = function ()
        lostbal_salve()
      end,

      -- called from shivering or frozen cure
      gotcaloricdef = function (hypothermia)
        if not hypothermia then removeaff({"frozen", "shivering"}) end
        dict.caloric.salve.oncompleted ()
      end,

      applycure = {"caloric", "exothermic"},
      actions = {"apply caloric to body", "apply caloric", "apply exothermic to body", "apply exothermic"},
      onstart = function ()
        apply(dict.caloric.salve, " to body")
      end,
    },
    gone = {
      oncompleted = function(aff)
        defences.lost("caloric")

        if aff and aff == "unknownany" then
          dict.unknownany.count = dict.unknownany.count - 1
          if dict.unknownany.count <= 0 then
            removeaff("unknownany")
            dict.unknownany.count = 0
          end
        elseif aff and aff == "unknownmental" then
          dict.unknownmental.count = dict.unknownmental.count - 1
          if dict.unknownmental.count <= 0 then
            removeaff("unknownmental")
            dict.unknownmental.count = 0
          end
        end
      end
    }
  },
  blind = {
    gamename = "blindness",
    onservereignore = function()
      -- no blind skill: ignore serverside if it's not to be deffed up atm
      -- with blind skill: ignore serverside can use skill, or if it's not to be deffed up atm
      return
        not ((sys.deffing and defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind))
    end,
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not affs.scalded and
        ((sys.deffing and defdefup[defs.mode].blind and not defc.blind) or (conf.keepup and defkeepup[defs.mode].blind and not defc.blind)) and not doingaction"waitingonblind") or false
      end,

      oncompleted = function ()
        defences.got("blind")
        lostbal_herb()
      end,

      noeffect = function ()
        dict.blind.herb.oncompleted()
      end,

      eatcure = {"bayberry", "arsenic"},
      onstart = function ()
        eat(dict.blind.herb)
      end,

      empty = function()
        defences.got("blind")
        lostbal_herb()
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not pflags.b then
          defences.lost("blind")
        end
      end
    }
  },
  waitingonblind = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        defences.got("blind")
      end,

      onstart = function ()
      end
    }
  },
  deaf = {
    gamename = "deafness",
    onservereignore = function()
      -- no deaf skill: ignore serverside if it's not to be deffed up atm
      -- with deaf skill: ignore serverside can use skill, or if it's not to be deffed up atm
      return
        not ((sys.deffing and defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf))
    end,
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.deaf and
         ((sys.deffing and defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf)) and not doingaction("waitingondeaf")) or false
      end,

      oncompleted = function ()
        doaction(dict.waitingondeaf.waitingfor)
        lostbal_herb()
      end,

      eatcure = {"hawthorn", "calamine"},
      onstart = function ()
        eat(dict.deaf.herb)
      end,

      empty = function()
        dict.deaf.herb.oncompleted()
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not pflags.d then
          defences.lost("deaf")
        end
      end
    }
  },
  waitingondeaf = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        defences.got("deaf")
      end,

      onstart = function ()
      end
    }
  },


-- balance-related defences
  lyre = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.lyre and ((sys.deffing and defdefup[defs.mode].lyre) or (conf.keepup and defkeepup[defs.mode].lyre)) and not will_take_balance() and not conf.lyre_step and not doingaction("lyre") and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got("lyre")

        if conf.lyre and not conf.paused then conf.paused = true; raiseEvent("svo config changed", "paused") end
      end,

      ontimeout = function()
        if conf.paused and not defc.lyre then
          echof("Lyre strum didn't happen - unpausing.")
          conf.paused = false; raiseEvent("svo config changed", "paused")
          make_gnomes_work()
        end
      end,

      onkill = function()
        if conf.paused and not defc.lyre then
          echof("Lyre strum cancelled - unpausing.")
          conf.paused = false; raiseEvent("svo config changed", "paused")
        end
      end,

      action = "strum lyre",
      onstart = function ()
        sys.sendonceonly = true
        -- small fix to make 'lyc' work and be in-order (as well as use batching)
        local send = send
        -- record in systemscommands, so it doesn't get killed later on in the controller and loop
        if conf.batch then send = function(what, ...) sendc(what, ...) sk.systemscommands[what] = true end end

        if not conf.lyrecmd then
          send("strum lyre", conf.commandecho)
        else
          send(tostring(conf.lyrecmd), conf.commandecho)
        end
        sys.sendonceonly = false

        if conf.lyre and not conf.paused then conf.paused = true; raiseEvent("svo config changed", "paused") end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost("lyre")

        -- as a special case for handling the following scenario:
        --[[(focus)
          Your prismatic barrier dissolves into nothing.
          You focus your mind intently on curing your mental maladies.
          Food is no longer repulsive to you. (7.548s)
          H: 3294 (50%), M: 4911 (89%) 28725e, 10294w 89.3% ex|cdk- 19:24:04.719(sip health|eat bayberry|outr bayberry|eat
          irid|outr irid)(+324h, 5.0%, -291m, 5.3%)
          You begin to weave a melody of magical, heart-rending beauty and a beautiful barrier of prismatic light surrounds you.
          (p) H: 3294 (50%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:04.897
          Your prismatic barrier dissolves into nothing.
          You take a drink from a purple heartwood vial.
          The elixir heals and soothes you.
          H: 4767 (73%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:05.247(+1473h, 22.7%)
          You eat some bayberry bark.
          Your eyes dim as you lose your sight.
        ]]
        -- we want to kill lyre going up when it goes down and you're off balance, because you won't get it up off-bal

        -- but don't kill it if it is in lifevision - meaning we're going to get it:
        --[[
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
          (x) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}
          You have recovered equilibrium. (3.887s)
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
        ]]

        if not (bals.balance and bals.equilibrium) and actions.lyre_physical and not lifevision.l.lyre_physical then killaction(dict.lyre.physical) end

        -- unpause should we lose the lyre def for some reason - but not while we're doing lyc
        -- since we'll lose the lyre def and it'll come up right away
        if conf.lyre and conf.paused and not actions.lyre_physical then conf.paused = false; raiseEvent("svo config changed", "paused") end
      end,
    }
  },
  breath = {
    gamename = "heldbreath",
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceless_act = true,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].breath and not defc.breath) or (conf.keepup and defkeepup[defs.mode].breath and not defc.breath)) and not doingaction("breath") and not codepaste.balanceful_defs_codepaste() and not affs.aeon and not affs.asthma) or false
      end,

      oncompleted = function ()
        defences.got("breath")
      end,

      action = "hold breath",
      onstart = function ()
        if conf.gagbreath and not sys.sync then
          send("hold breath", false)
        else
          send("hold breath", conf.commandecho) end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost("breath")
      end,
    }
  },
  dragonform = {
    physical = {
      aspriority = 0,
      spriority = 0,
      unpauselater = false,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].dragonform and not defc.dragonform) or (conf.keepup and defkeepup[defs.mode].dragonform and not defc.dragonform)) and not doingaction("waitingfordragonform") and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        doaction(dict.waitingfordragonform.waitingfor)
      end,

      alreadyhave = function ()
        dict.waitingfordragonform.waitingfor.oncompleted()
      end,

      actions = {"dragonform", "dragonform red", "dragonform black", "dragonform silver", "dragonform gold", "dragonform blue", "dragonform green"},
      onstart = function ()
      -- user commands catching needs this check
        if not (bals.balance and bals.equilibrium) then return end

        send("dragonform", conf.commandecho)

        if not conf.paused then
          dict.dragonform.physical.unpauselater = true
          conf.paused = true; raiseEvent("svo config changed", "paused")
          echo"\n" echof("Temporarily pausing for dragonform.")
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost("dragonform")
        dict.dragonbreath.gone.oncompleted()
        dict.dragonarmour.gone.oncompleted()
        signals.dragonform:emit()
      end,
    }
  },
  waitingfordragonform = {
    spriority = 0,
    waitingfor = {
      customwait = 20,

      oncompleted = function ()
        defences.got("dragonform")
        dict.riding.gone.oncompleted()

        -- strip class defences that don't stay through dragon
        for def, deft in defs_data:iter() do
          local skillset = deft.type
          if skillset ~= "general" and skillset ~= "enchantment" and skillset ~= "dragoncraft" and not deft.staysindragon and defc[def] then
            defences.lost(def)
          end
        end

        -- lifevision, via artefact, has to be removed as well

        signals.dragonform:emit()

        if conf.paused and dict.dragonform.physical.unpauselater then
          conf.paused = false; raiseEvent("svo config changed", "paused")

          echo"\n"
          if math.random(1, 20) == 1 then
            echof("ROOOAR!")
          else
            echof("Obtained dragonform, unpausing.")
          end
        end
        dict.dragonform.physical.unpauselater = false
      end,

      cancelled = function ()
        signals.dragonform:emit()
        if conf.paused and dict.dragonform.physical.unpauselater then
          conf.paused = false; raiseEvent("svo config changed", "paused")
          echo"\n" echof("Unpausing.")
        end
        dict.dragonform.physical.unpauselater = false
      end,

      ontimeout = function()
        dict.waitingfordragonform.waitingfor.cancelled()
      end,

      onstart = function() end
    }
  },
  dragonbreath = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceless_act = true,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].dragonbreath and not defc.dragonbreath) or (conf.keepup and defkeepup[defs.mode].dragonbreath and not defc.dragonbreath)) and not codepaste.balanceful_defs_codepaste() and not doingaction("dragonbreath") and not doingaction("waitingfordragonbreath") and defc.dragonform and not dict.dragonbreath.blocked and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function (def)
        if def then defences.got("dragonbreath")
        else doaction(dict.waitingfordragonbreath.waitingfor) end
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        dict.dragonbreath.blocked = true
        tempTimer(3, function () dict.dragonbreath.blocked = false; make_gnomes_work() end)
      end,

      alreadygot = function ()
        defences.got("dragonbreath")
      end,

      onstart = function ()
        send("summon "..(conf.dragonbreath and conf.dragonbreath or "unknown"), conf.commandecho)
      end
    },
    gone = {
      oncompleted = function()
        defences.lost("dragonbreath")
      end
    }
  },
  waitingfordragonbreath = {
    spriority = 0,
    waitingfor = {
      customwait = 2,

      onstart = function() end,

      oncompleted = function ()
        defences.got("dragonbreath")
      end
    }
  },
  dragonarmour = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].dragonarmour and not defc.dragonarmour) or (conf.keepup and defkeepup[defs.mode].dragonarmour and not defc.dragonarmour)) and not codepaste.balanceful_defs_codepaste() and defc.dragonform) or false
      end,

      oncompleted = function ()
        defences.got("dragonarmour")
      end,

      action = "dragonarmour on",
      onstart = function ()
        send("dragonarmour on", conf.commandecho)
      end
    },
    gone = {
      oncompleted = function()
        defences.lost("dragonarmour")
      end
    }
  },
  selfishness = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (
          ((sys.deffing and defdefup[defs.mode].selfishness and not defc.selfishness)
            or (not sys.deffing and conf.keepup and ((defkeepup[defs.mode].selfishness and not defc.selfishness) or (not defkeepup[defs.mode].selfishness and defc.selfishness))))
          and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got("selfishness")
      end,

      onstart = function ()
        if (sys.deffing and defdefup[defs.mode].selfishness and not defc.selfishness) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].selfishness and not defc.selfishness) then
          send("selfishness", conf.commandecho)
        else
          send("generosity", conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost("selfishness")

        -- if we've done sl off, _gone gets added, so _physical gets readded by action clear - kill physical here for that not to happen
        if actions.selfishness_physical then
          killaction(dict.selfishness.physical)
        end
      end,
    }
  },
  riding = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (
          ((sys.deffing and defdefup[defs.mode].riding and not defc.riding)
            or (not sys.deffing and conf.keepup and ((defkeepup[defs.mode].riding and not defc.riding) or (not defkeepup[defs.mode].riding and defc.riding))))
          and not codepaste.balanceful_defs_codepaste() and not defc.dragonform and not affs.hamstring and (not affs.prone or doingaction"prone") and not affs.crippledleftarm and not affs.crippledrightarm and not affs.mangledleftarm and not affs.mangledrightarm and not affs.mutilatedleftarm and not affs.mutilatedrightarm and not affs.unknowncrippledleg and not affs.parestolegs and not doingaction"riding" and not affs.pinshot and not affs.paralysis) or false
      end,

      oncompleted = function ()
        if (not sys.deffing and conf.keepup and not defkeepup[defs.mode].riding and (defc.riding == true or defc.riding == nil)) then
          dict.riding.gone.oncompleted()
        else
          defences.got("riding")
        end

        if bals.balance and not conf.freevault then
          config.set("freevault", "yep", true)
        elseif not bals.balance and conf.freevault then
          config.set("freevault", "nope", true)
        end
      end,

      alreadyon = function ()
        defences.got("riding")
      end,

      dragonform = function ()
        defences.got("dragonform")
        signals.dragonform:emit()
      end,

      hastring = function ()
        dict.hamstring.aff.oncompleted()
      end,

      dismount = function ()
        defences.lost("riding")
        dict.block.gone.oncompleted()
      end,

      onstart = function ()
        if (sys.deffing and defdefup[defs.mode].riding and not defc.riding) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].riding and not defc.riding) then
          send(string.format("%s %s", tostring(conf.ridingskill), tostring(conf.ridingsteed)), conf.commandecho)
        else
          send("dismount", conf.commandecho)
          if sys.sync or tostring(conf.ridingsteed) == "giraffe" then return end
          if conf.steedfollow then send(string.format("order %s follow me", tostring(conf.ridingsteed), conf.commandecho)) end
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost("riding")
        dict.block.gone.oncompleted()
      end,
    }
  },
  meditate = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].meditate and not defc.meditate) or (conf.keepup and defkeepup[defs.mode].meditate and not defc.meditate)) and not codepaste.balanceful_defs_codepaste() and not doingaction'meditate' and (stats.currentwillpower < stats.maxwillpower or stats.currentmana < stats.maxmana)) or false
      end,

      oncompleted = function ()
        defences.got("meditate")
      end,

      actions = {"med", "meditate"},
      onstart = function ()
        send("meditate", conf.commandecho)
      end
    }
  },

satiation = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.satiation and ((sys.deffing and defdefup[defs.mode].satiation) or (conf.keepup and defkeepup[defs.mode].satiation)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("satiation")
        end,

        action = "satiation",
        onstart = function ()
          send("satiation", conf.commandecho)
        end
      }
    },  mindseye = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.mindseye and ((sys.deffing and defdefup[defs.mode].mindseye) or (conf.keepup and defkeepup[defs.mode].mindseye)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got("mindseye")

        -- check if we need to re-classify deaf
        if (defc.deaf or affs.deafaff) and (defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye then
          defences.got("deaf")
          removeaff("deafaff")
        elseif (defc.deaf or affs.deafaff) then
          defences.lost("deaf")
          addaff(dict.deafaff)
        end

        -- check if we need to re-classify blind
        if (defc.blind or affs.blindaff) and (defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)
         then
          defences.got("blind")
          removeaff("blindaff")
        elseif (defc.blind or affs.blindaff) then
          defences.lost("blind")
          addaff(dict.blindaff)
        end
      end,

      action = "touch mindseye",
      onstart = function ()
        send("touch mindseye", conf.commandecho)
      end
    }
  },
  metawake = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.metawake and ((sys.deffing and defdefup[defs.mode].metawake) or (conf.keepup and defkeepup[defs.mode].metawake)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not doingaction'metawake' and not affs.lullaby) or false
      end,

      oncompleted = function ()
        defences.got("metawake")
      end,

      action = "metawake on",
      onstart = function ()
        send("metawake on", conf.commandecho)
      end
    }
  },
treewatch = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.treewatch and ((sys.deffing and defdefup[defs.mode].treewatch) or (conf.keepup and defkeepup[defs.mode].treewatch)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'treewatch') or false
        end,

        oncompleted = function ()
          defences.got("treewatch")
        end,

        action = "treewatch on",
        onstart = function ()
          send("treewatch on", conf.commandecho)
        end
      }
    },skywatch = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.skywatch and ((sys.deffing and defdefup[defs.mode].skywatch) or (conf.keepup and defkeepup[defs.mode].skywatch)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'skywatch') or false
        end,

        oncompleted = function ()
          defences.got("skywatch")
        end,

        action = "skywatch on",
        onstart = function ()
          send("skywatch on", conf.commandecho)
        end
      }
    },groundwatch = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.groundwatch and ((sys.deffing and defdefup[defs.mode].groundwatch) or (conf.keepup and defkeepup[defs.mode].groundwatch)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'groundwatch') or false
        end,

        oncompleted = function ()
          defences.got("groundwatch")
        end,

        action = "groundwatch on",
        onstart = function ()
          send("groundwatch on", conf.commandecho)
        end
      }
    },telesense = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.telesense and ((sys.deffing and defdefup[defs.mode].telesense) or (conf.keepup and defkeepup[defs.mode].telesense)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'telesense') or false
        end,

        oncompleted = function ()
          defences.got("telesense")
        end,

        action = "telesense on",
        onstart = function ()
          send("telesense on", conf.commandecho)
        end
      }
    },softfocus = {
      gamename = 'softfocusing',      physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.softfocus and ((sys.deffing and defdefup[defs.mode].softfocus) or (conf.keepup and defkeepup[defs.mode].softfocus)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'softfocus') or false
        end,

        oncompleted = function ()
          defences.got("softfocus")
        end,

        action = "softfocus on",
        onstart = function ()
          send("softfocus on", conf.commandecho)
        end
      }
    },vigilance = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.vigilance and ((sys.deffing and defdefup[defs.mode].vigilance) or (conf.keepup and defkeepup[defs.mode].vigilance)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'vigilance') or false
        end,

        oncompleted = function ()
          defences.got("vigilance")
        end,

        action = "vigilance on",
        onstart = function ()
          send("vigilance on", conf.commandecho)
        end
      }
    },magicresist = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.magicresist and ((sys.deffing and defdefup[defs.mode].magicresist) or (conf.keepup and defkeepup[defs.mode].magicresist)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'magicresist') or false
        end,

        oncompleted = function ()
          defences.got("magicresist")
        end,

        action = "activate magic resistance",
        onstart = function ()
          send("activate magic resistance", conf.commandecho)
        end
      }
    },fireresist = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.fireresist and ((sys.deffing and defdefup[defs.mode].fireresist) or (conf.keepup and defkeepup[defs.mode].fireresist)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'fireresist') or false
        end,

        oncompleted = function ()
          defences.got("fireresist")
        end,

        action = "activate fire resistance",
        onstart = function ()
          send("activate fire resistance", conf.commandecho)
        end
      }
    },coldresist = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.coldresist and ((sys.deffing and defdefup[defs.mode].coldresist) or (conf.keepup and defkeepup[defs.mode].coldresist)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'coldresist') or false
        end,

        oncompleted = function ()
          defences.got("coldresist")
        end,

        action = "activate cold resistance",
        onstart = function ()
          send("activate cold resistance", conf.commandecho)
        end
      }
    },electricresist = {
            physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.electricresist and ((sys.deffing and defdefup[defs.mode].electricresist) or (conf.keepup and defkeepup[defs.mode].electricresist)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'electricresist') or false
        end,

        oncompleted = function ()
          defences.got("electricresist")
        end,

        action = "activate electric resistance",
        onstart = function ()
          send("activate electric resistance", conf.commandecho)
        end
      }
    },alertness = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.alertness and ((sys.deffing and defdefup[defs.mode].alertness) or (conf.keepup and defkeepup[defs.mode].alertness)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("alertness")
        end,

        action = "alertness on",
        onstart = function ()
          send("alertness on", conf.commandecho)
        end
      }
    },bell = {
      gamename = 'belltattoo',      physical = {
        balanceless_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.bell and ((sys.deffing and defdefup[defs.mode].bell) or (conf.keepup and defkeepup[defs.mode].bell)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and not doingaction'bell') or false
        end,

        oncompleted = function ()
          defences.got("bell")
        end,

        action = "touch bell",
        onstart = function ()
          send("touch bell", conf.commandecho)
        end
      }
    },hypersight = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.hypersight and ((sys.deffing and defdefup[defs.mode].hypersight) or (conf.keepup and defkeepup[defs.mode].hypersight)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("hypersight")
        end,

        action = "hypersight on",
        onstart = function ()
          send("hypersight on", conf.commandecho)
        end
      }
    },  cloak = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.cloak and ((sys.deffing and defdefup[defs.mode].cloak) or (conf.keepup and defkeepup[defs.mode].cloak)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got("cloak")
      end,

      action = "touch cloak",
      onstart = function ()
        send("touch cloak", conf.commandecho)
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not pflags.c then
          defences.lost("cloak")
        end
      end
    }
  },
curseward = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.curseward and ((sys.deffing and defdefup[defs.mode].curseward) or (conf.keepup and defkeepup[defs.mode].curseward)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("curseward")
        end,

        action = "curseward",
        onstart = function ()
          send("curseward", conf.commandecho)
        end
      }
    },clinging = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.clinging and ((sys.deffing and defdefup[defs.mode].clinging) or (conf.keepup and defkeepup[defs.mode].clinging)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("clinging")
        end,

        action = "cling",
        onstart = function ()
          send("cling", conf.commandecho)
        end
      }
    },
  nightsight = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.nightsight and ((sys.deffing and defdefup[defs.mode].nightsight) or (conf.keepup and defkeepup[defs.mode].nightsight)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone and not doingaction'nightsight'
        ) or false
      end,

      oncompleted = function ()
        defences.got("nightsight")
      end,

      action = "nightsight on",
      onstart = function ()
        send("nightsight on", conf.commandecho)
      end
    },
  },
  shield = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].shield and not defc.shield) or (conf.keepup and defkeepup[defs.mode].shield and not defc.shield)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not (affs.mangledleftarm and affs.mangledlrightarm) and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got("shield")
        if defkeepup[defs.mode].shield and conf.oldts then
          defs.keepup("shield", false)
        end
      end,

      actions = {"touch shield", "angel aura"},
      onstart = function ()
        send("touch shield", conf.commandecho)
      end
    },
    gone = {
      oncompleted = function()
        defences.lost("shield")
      end
    }
  },

-- skillset-specific defences

putrefaction = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.putrefaction and ((sys.deffing and defdefup[defs.mode].putrefaction) or (conf.keepup and defkeepup[defs.mode].putrefaction)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("putrefaction")
        end,

        action = "putrefaction",
        onstart = function ()
          send("putrefaction", conf.commandecho)
        end
      }
    },shroud = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.shroud and ((sys.deffing and defdefup[defs.mode].shroud) or (conf.keepup and defkeepup[defs.mode].shroud)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("shroud")
        end,

        action = "shroud",
        onstart = function ()
          send("shroud", conf.commandecho)
        end
      }
    },vengeance = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.vengeance and ((sys.deffing and defdefup[defs.mode].vengeance) or (conf.keepup and defkeepup[defs.mode].vengeance)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("vengeance")
        end,

        action = "vengeance on",
        onstart = function ()
          send("vengeance on", conf.commandecho)
        end
      }
    },deathaura = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.deathaura and ((sys.deffing and defdefup[defs.mode].deathaura) or (conf.keepup and defkeepup[defs.mode].deathaura)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("deathaura")
        end,

        action = "deathaura on",
        onstart = function ()
          send("deathaura on", conf.commandecho)
        end
      }
    },soulcage = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.soulcage and ((sys.deffing and defdefup[defs.mode].soulcage) or (conf.keepup and defkeepup[defs.mode].soulcage)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("soulcage")
        end,

        action = "soulcage activate",
        onstart = function ()
          send("soulcage activate", conf.commandecho)
        end
      }
    },  lifevision = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.lifevision and ((sys.deffing and defdefup[defs.mode].lifevision) or (conf.keepup and defkeepup[defs.mode].lifevision)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone and stats.currentmana >= 600) or false
      end,

      oncompleted = function ()
        defences.got("lifevision")
      end,

      action = "lifevision",
      onstart = function ()
        send("lifevision", conf.commandecho)
      end
    }
  },














  baalzadeen = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        if (not defc.baalzadeen and ((sys.deffing and defdefup[defs.mode].baalzadeen) or (conf.keepup and defkeepup[defs.mode].baalzadeen)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) then

          if (stats.mp >= 100) then
             return true
           elseif not sk.gettingfullstats then
             fullstats(true)
             echof("Getting fullstats for Baalzadeen summoning...")
           end
        end
      end,

      oncompleted = function ()
        defences.got("baalzadeen")
      end,

      action = "summon baalzadeen",
      onstart = function ()
        send("summon baalzadeen", conf.commandecho)
      end
    }
  },
  armour = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.armour and ((sys.deffing and defdefup[defs.mode].armour) or (conf.keepup and defkeepup[defs.mode].armour)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.baalzadeen) or false
      end,

      oncompleted = function ()
        defences.got("armour")
      end,

      action = "demon armour",
      onstart = function ()
        send("demon armour", conf.commandecho)
      end
    }
  },
  syphon = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.syphon and ((sys.deffing and defdefup[defs.mode].syphon) or (conf.keepup and defkeepup[defs.mode].syphon)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.baalzadeen) or false
      end,

      oncompleted = function ()
        defences.got("syphon")
      end,

      action = "demon syphon",
      onstart = function ()
        send("demon syphon", conf.commandecho)
      end
    }
  },
  mask = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.mask and ((sys.deffing and defdefup[defs.mode].mask) or (conf.keepup and defkeepup[defs.mode].mask)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.baalzadeen) or false
      end,

      oncompleted = function ()
        defences.got("mask")
      end,

      action = "mask",
      onstart = function ()
        send("mask", conf.commandecho)
      end
    }
  },
daegger = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        undeffable = true, 
        isadvisable = function ()
          return (not defc.daegger and ((sys.deffing and defdefup[defs.mode].daegger) or (conf.keepup and defkeepup[defs.mode].daegger)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("daegger")
        end,

        action = "summon daegger",
        onstart = function ()
          send("summon daegger", conf.commandecho)
        end
      }
    },pentagram = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        undeffable = true, 
        isadvisable = function ()
          return (not defc.pentagram and ((sys.deffing and defdefup[defs.mode].pentagram) or (conf.keepup and defkeepup[defs.mode].pentagram)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("pentagram")
        end,

        action = "carve pentagram",
        onstart = function ()
          send("carve pentagram", conf.commandecho)
        end
      }
    },

truestare = {
            physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        
        isadvisable = function ()
          return (not defc.truestare and ((sys.deffing and defdefup[defs.mode].truestare) or (conf.keepup and defkeepup[defs.mode].truestare)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("truestare")
        end,

        action = "truestare",
        onstart = function ()
          send("truestare", conf.commandecho)
        end
      }
    },
















-- override groves lyre, as druids can get 2 types of lyre (groves and nightingale)

}

-- finds the lowest missing priority num for given balance
local function find_lowest_async(balance)
  local data = make_prio_table(balance)
  local t = {}

  for k,_ in pairs(data) do
    t[#t+1] = k
  end

  table.sort(t)

  local function contains(value)
    for _, v in ipairs(t) do
      if v == value then return true end
    end
    return false
  end

  for i = 1, table.maxn(t) do
    if not contains(i) then return i end
  end

  return table.maxn(t)+1
end

local function find_lowest_sync()
  local data = make_sync_prio_table("%s%s")
  local t = {}

  for k,_ in pairs(data) do
    t[#t+1] = k
  end

  table.sort(t)
  local function contains(value)
    for _, v in ipairs(t) do
      if v == value then return true end
    end
    return false
  end

  for i = 1, table.maxn(t) do
    if not contains(i) then return i end
  end

  return table.maxn(t)+1
end

local function dict_setup()
  dict_balanceful  = {}
  dict_balanceless = {}

  -- defence shortlists
  dict_herb      = {}
  dict_misc      = {}
  dict_misc_def  = {}
  dict_purgative = {}
  dict_salve_def = {}
  dict_smoke_def = {}

  local unassigned_actions      = {}
  local unassigned_sync_actions = {}

  for i,j in pairs(dict) do
    for k,l in pairs(j) do
      if type(l) == "table" then
        if not l.name then l.name = i .. "_" .. k end
        if not l.balance then l.balance = k end
        if not l.action_name then l.action_name = i end
        if l.aspriority == 0 then
          unassigned_actions[k] = unassigned_actions[k] or {}
          unassigned_actions[k][#unassigned_actions[k]+1] = i
        end
        if l.spriority == 0 then
          unassigned_sync_actions[k] = unassigned_sync_actions[k] or {}
          unassigned_sync_actions[k][#unassigned_sync_actions[k]+1] = i
        end

        -- if it's a def, create the gone handler as well so lifevision will watch it
        if not j.gone and l.def then
          j.gone = {
            name = i .. "_gone",
            balance = "gone",
            action_name = i,

            oncompleted = function ()
              defences.lost(i)
            end
          }
        end
      end
    end

    if not j.name then j.name = i end
    if j.physical and j.physical.balanceless_act and not j.physical.def then dict_balanceless[i] = {p = dict[i]} end
    if j.physical and j.physical.balanceful_act and not j.physical.def then dict_balanceful[i] = {p = dict[i]} end

    if j.purgative and j.purgative.def then
      dict_purgative[i] = {p = dict[i]} end

    -- balanceful and balanceless moved to a signal for dragonform!

    if j.misc and j.misc.def then
      dict_misc_def[i] = {p = dict[i]} end

    if j.smoke and j.smoke.def then
      dict_smoke_def[i] = {p = dict[i]} end

    if j.salve and j.salve.def then
      dict_salve_def[i] = {p = dict[i]} end

    if j.misc and not j.misc.def then
      dict_misc[i] = {p = dict[i]} end

    if j.herb and j.herb.def then
      dict_herb[i] = {p = dict[i]} end

    if j.herb and not j.herb.noeffect then
      j.herb.noeffect = function()
        lostbal_herb(true)
      end
    end

    -- mickey steals balance and gives illness
    if j.herb and not j.herb.mickey then
      j.herb.mickey = function()
        lostbal_herb(false, true)
        addaff(dict.illness)
      end
    end

    if j.focus and not j.focus.offbalance then
      j.focus.offbalance = function()
        lostbal_focus()
      end
    end
    if j.salve and not j.salve.offbalance then
      j.salve.offbalance = function()
        lostbal_salve()
      end
    end
    if j.herb and not j.herb.offbalance then
      j.herb.offbalance = function()
        lostbal_herb()
      end
    end
    if j.smoke and not j.smoke.offbalance then
      j.smoke.offbalance = function()
        lostbal_smoke()
      end
    end

    if j.focus and not j.focus.nomana then
      j.focus.nomana = function ()
        if not actions.nomana_waitingfor and stats.currentmana ~= 0 then
          echof("Seems we're out of mana.")
          doaction(dict.nomana.waitingfor)
        end
      end
    end

    if not j.sw then j.sw = createStopWatch() end
  end -- went through the dict list once at this point

  for balancename, list in pairs(unassigned_actions) do
    if #list > 0 then
      -- shift up by # all actions for that balance to make room @ bottom
      for i,j in pairs(dict) do
        for balance,l in pairs(j) do
          if balance == balancename and type(l) == "table" and l.aspriority and l.aspriority ~= 0 then
            l.aspriority = l.aspriority + #list
          end
        end
      end

      -- now setup the low id's
      for i, actionname in ipairs(list) do
        dict[actionname][balancename].aspriority = i
      end
    end
  end

  local totalcount = 0
  for _, list in pairs(unassigned_sync_actions) do
    totalcount = totalcount + #list
  end

  for balancename, list in pairs(unassigned_sync_actions) do
    if totalcount > 0 then
      -- shift up by # all actions for that balance to make room @ bottom
      for i,j in pairs(dict) do
        for balance,l in pairs(j) do
          if type(l) == "table" and l.spriority and l.spriority ~= 0 then
            l.spriority = l.spriority + totalcount
          end
        end
      end

      -- now setup the low id's
      for i, actionname in ipairs(list) do
        dict[actionname][balancename].spriority = i
      end
    end
  end

  -- we don't want stuff in dict.lovers.map!
  dict.lovers.map = {}
end
dict_setup() -- call once now to auto-setup missing dict() functions, and later on prio import to sort out the 0's.

local function dict_validate()
  -- basic theory is to create table keys for each table within dict.#,
  -- store the dupe aspriority values inside in key-pair as well, and report
  -- what we got.
  local data = {}
  local dupes = {}
  local sync_dupes = {}
  local key = false

  -- check async ones first
  for i,j in pairs(dict) do
    for k,l in pairs(j) do
      if type(l) == "table" and l.aspriority then
        local balance = k:split("_")[1]
        if not data[balance] then data[balance] = {} dupes[balance] = {} end
        key = containsbyname(data[balance], l.aspriority)
          if key then
          -- store the new dupe that we found
          dupes[balance][(k:split("_")[2] and k:split("_")[2] .. " for " or "") .. i] = l.aspriority
          -- and store the previous one that we had already!
          dupes[balance][(key.balance:split("_")[2] and key.balance:split("_")[2] .. " for " or "") .. key.action_name] = l.aspriority
        end
        data[balance][l] = l.aspriority

      end
    end
  end

  -- if we got something, complain
  for i,j in pairs(dupes) do
    if next(j) then
        echof("Meh, problem. The following actions in %s balance have the same priorities: %s", i, oneconcatwithval(j))
    end
  end

  -- clear table for next use, don't re-make to not force rehashes
  for k in pairs(data) do
    data[k] = nil
  end
  for k in pairs(dupes) do
    dupes[k] = nil
  end

  -- check sync ones
  for i,j in pairs(dict) do
    for k,l in pairs(j) do
      if type(l) == "table" and l.spriority then
        local balance = l.name
        local key = containsbyname(data, l.spriority)
        if key then
          dupes[balance] = l.spriority
          dupes[key] = l.spriority
        end
        data[balance] = l.spriority

      end
    end
  end

  -- if we got something, complain
  if not next(dupes) then return end

  -- sort them first before complaining
  local sorted_dupes = {}
    -- stuff into table
  for i,j in pairs(dupes) do
    sorted_dupes[#sorted_dupes+1] = {name = i, prio = j}
  end

    -- sort table
  table.sort(sorted_dupes, function(a,b) return a.prio < b.prio end)

  local function a(tbl)
    assert(type(tbl) == "table")
    local result = {}
    for i,j in pairs(tbl) do
      result[#result+1] = j.name .. "(" .. j.prio .. ")"
    end

    return table.concat(result, ", ")
  end

    -- complaining time
  echof("Meh, problem. The following actions in sync mode have the same priorities: %s", a(sorted_dupes))
end

signals.dragonform:connect(function ()
  dict_balanceful_def = {}
  dict_balanceless_def = {}

  if not defc.dragonform then
    for i,j in pairs(dict) do
      if j.physical and j.physical.balanceful_act and j.physical.def then
        dict_balanceful_def[i] = {p = dict[i]} end

      if j.physical and j.physical.balanceless_act and j.physical.def then
        dict_balanceless_def[i] = {p = dict[i]} end
    end
  else
    for i,j in pairs(dict) do
      if j.physical and j.physical.balanceful_act and j.physical.def and defs_data[i] and (defs_data[i].type == "general" or defs_data[i].type == "dragoncraft" or defs_data[i].availableindragon) then
        dict_balanceful_def[i] = {p = dict[i]} end

      if j.physical and j.physical.balanceless_act and j.physical.def and defs_data[i] and (defs_data[i].type == "general" or defs_data[i].type == "dragoncraft" or defs_data[i].availableindragon) then
        dict_balanceless_def[i] = {p = dict[i]} end
    end

    -- special case for nightsight and monks: they have it
  end

end)
signals.systemstart:connect(function () signals.dragonform:emit() end)
signals.gmcpcharstatus:connect(function ()
  if gmcp.Char.Status.race == "Dragon" then
    defences.got("dragonform")
  else
    defences.lost("dragonform")
  end

  signals.dragonform:emit()
end)

make_prio_table = function (filterbalance)
  local data = {}

  for action,balances in pairs(dict) do
    for k,l in pairs(balances) do
      if k:sub(1, #filterbalance) == filterbalance and type(l) == "table" and l.aspriority then
        if #k ~= #filterbalance then
          data[l.aspriority] = k:sub(#filterbalance+2) .. " for " .. action
        else
          data[l.aspriority] = action
        end
      end
    end
  end

  return data
end

make_sync_prio_table = function(format)
  local data, type, sformat = {}, type, string.format
  for i,j in pairs(dict) do
    for k,l in pairs(j) do
      if type(l) == "table" and l.spriority then
        data[l.spriority] = sformat(format, i, k)
      end
    end
  end

  return data
end

-- func gets passed the action name to operate on, needs to return true for it to be added
make_prio_tablef = function (filterbalance, func)
  local data = {}

  for action, balances in pairs(dict) do
    for balance, l in pairs(balances) do
      if balance == filterbalance and type(l) == "table" and l.aspriority and (not func or func(action)) then
        data[l.aspriority] = action
      end
    end
  end

  return data
end

-- func gets passed the action name to operate on
-- skipbals is a key-value table, where a key is a balance to ignore
make_sync_prio_tablef = function(format, func, skipbals)
  local data, type, sformat = {}, type, string.format
  for action, balances in pairs(dict) do
    for balance, balancedata in pairs(balances) do
      if type(balancedata) == "table" and not skipbals[balance] and balancedata.spriority and (not func or func(action)) then
        data[balancedata.spriority] = sformat(format, action, balance)
      end
    end
  end

  return data
end

clear_balance_prios = function(balance)
  for i,j in pairs(dict) do
    for k,l in pairs(j) do
      if k == balance and type(l) == "table" and l.aspriority then
        l.aspriority = 0
      end
    end
  end
end

clear_sync_prios = function()
  for i,j in pairs(dict) do
    for k,l in pairs(j) do
      if type(l) == "table" and l.spriority then
        l.spriority = 0
      end
    end
  end
end

-- register various handlers
signals.curedwith_focus:connect(function (what)
  dict.unknownmental.focus[what] ()
end)

sk.check_retardation = function (...)
  if affs.retardation then
    removeaff("retardation")
  end
end


signals.newroom:connect(function()
  if defc.block then dict.block.gone.oncompleted() end
  if defc.eavesdrop then defences.lost("eavesdrop") end
  if defc.lyre then defences.lost("lyre") end
end)

signals.newroom:connect(sk.check_retardation)
signals.newroom:block(sk.check_retardation)

-- reset impale
signals.newroom:connect(function()
  if not next(affs) then return end

  local removables = {"impale"}
  local escaped = {}
  for i = 1, #removables do
    if affs[removables[i]] then
      escaped[#escaped+1] = removables[i]
      removeaff(removables[i])
    end
  end

  if #escaped > 0 then
    tempTimer(0, function()
      if stats.currenthealth > 0 then
        tempTimer(0, function()
          if not find_until_last_paragraph("You scrabble futilely at the ground as", "substring") then
            echof("Woo! We escaped from %s.", concatand(escaped))
          end
        end)
      end
    end)
  end
end)

signals.systemstart:connect(function()
  sys.input_to_actions = {}

  for action, actiont in pairs(dict) do
    for balance, balancet in pairs(actiont) do
      -- ignore "check*" actions, as they are only useful when used by the system,
      -- and they can override actions that could be done by the user
      if type(balancet) == "table" and not action:find("^check") then
        if type(balancet.sipcure) == "string" then
          sys.input_to_actions["drink "..balancet.sipcure] = balancet
          sys.input_to_actions["sip "..balancet.sipcure] = balancet
        elseif type(balancet.sipcure) == "table" then
          for _, potion in ipairs(balancet.sipcure) do
            sys.input_to_actions["drink "..potion] = balancet
            sys.input_to_actions["sip "..potion] = balancet
          end

        elseif type(balancet.eatcure) == "string" then
          sys.input_to_actions["eat "..balancet.eatcure] = balancet
        elseif type(balancet.eatcure) == "table" then
          for _, thing in ipairs(balancet.eatcure) do
            sys.input_to_actions["eat "..thing] = balancet
          end

        elseif type(balancet.smokecure) == "string" then
          sys.input_to_actions["smoke "..balancet.smokecure] = balancet
          sys.input_to_actions["puff "..balancet.smokecure] = balancet
        elseif type(balancet.smokecure) == "table" then
          for _, thing in ipairs(balancet.smokecure) do
            sys.input_to_actions["smoke "..thing] = balancet
            sys.input_to_actions["puff "..thing] = balancet
          end
        end

        -- add action separately, as sileris has both eatcure and action
        if balancet.action then
          sys.input_to_actions[balancet.action] = balancet
        elseif balancet.actions then
          for _, action in pairs(balancet.actions) do
            sys.input_to_actions[action] = balancet
          end
        end
      end
    end
  end

end)


-- validate stuffs on our own
-- for i,j in pairs(dict) do
--  for k,l in pairs(j) do
--   if type(l) == "table" and k == "focus" then
--     echof("%s %s is focusable", i, k)
--   end
--   end
-- end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.


-- misc functions
function errorf(...)
  error(string.format(...))
end

function echon(...)
  local function wrapper(...) decho(string.format(...)) end
  local status, result = pcall(wrapper, ...)
  if not status then error(result, 2) end
  echo("\n")
end

function contains(t, value)
  assert(type(t) == "table", "svo.contains wants a table!")

  for k, v in pairs(t) do
    if v == value then
      return k
    end
  end

  return false
end


function sk.checking_herb_ai()
  return (doingaction"checkparalysis" or doingaction"checkasthma" or doingaction"checkimpatience") and true or false
end

-- balances
bals = bals or {
  herb = true, sip = true, moss = true,
  purgative = true, salve = true,
  balance = true, equilibrium = true, focus = true,
  tree = true, leftarm = "unset", rightarm = "unset",
  dragonheal = true, smoke = true,
}
-- new incoming balances that are tracked between the lines and the prompt
newbals = {}

-- checks

-- sip check
local healthchecks = {
  healhealth = {p = dict.healhealth},
  healmana = {p = dict.healmana}
}

-- build a table of all the things we need to do with their priority numbers,
-- sort it, and do the topmost thing.
check_sip = function(sync_mode)
  -- can we even sip?
  if not bals.sip or usingbal("sip") or affs.stun or affs.unconsciousness or affs.sleep or affs.anorexia then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.sip and j.p.sip.isadvisable() and not ignore[i] then
        prios[i] = (not sync_mode) and j.p.sip.aspriority or j.p.sip.spriority
      end
    end
  end

  check(affs)
  check(healthchecks)

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    doaction(dict[getHighestKey(prios)].sip) else
    return dict[getHighestKey(prios)].sip end
end

-- purgative check: needs to be asynced as well
check_purgative = function(sync_mode)
  -- can we even sip?
  if not bals.purgative or usingbal("purgative") or affs.stun or affs.unconsciousness or affs.sleep or affs.anorexia then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    local gotsomething = false
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.purgative and j.p.purgative.isadvisable() and not ignore[i]
      then

      prios[i] = (not sync_mode) and j.p.purgative.aspriority or j.p.purgative.spriority
      gotsomething = true
      end
    end

    return gotsomething
  end

  check(affs)

  if sys.deffing or conf.keepup then
    check(dict_purgative)
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    doaction(dict[getHighestKey(prios)].purgative) else
    return dict[getHighestKey(prios)].purgative end
end


-- salve check
check_salve = function(sync_mode)
  -- can we even use salves?
  if not bals.salve or usingbal("salve") or
    affs.sleep or affs.stun or affs.unconsciousness or affs.slickness then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.salve and j.p.salve.isadvisable() and not ignore[i]
      then
        prios[i] = (not sync_mode) and j.p.salve.aspriority or j.p.salve.spriority
      end
    end
  end

  check(affs)
  if sys.deffing or conf.keepup then check(dict_salve_def) end

  -- have nada?
  if not next(prios) then return false end

  -- otherwise, do the highest!
  if not sync_mode then
    doaction(dict[getHighestKey(prios)].salve) else
    return dict[getHighestKey(prios)].salve end
end

-- herb check

-- build a table of all the things we need to do with their priority numbers,
-- sort it, and do the topmost thing.
check_herb = function(sync_mode)
  -- can we even eat?
  if not bals.herb or usingbal("herb") or affs.sleep
    or affs.stun or affs.unconsciousness or sacid or affs.anorexia
    or (conf.aillusion and conf.waitherbai and sk.checking_herb_ai()) then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check (what)
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.herb and j.p.herb.isadvisable() and not ignore[i]
        -- make sure that we can outrift things, or if we can't, we have the herb in our inventory
        and (sys.canoutr or sk.can_eat_for(j.p.herb))
        then
          prios[i] = (not sync_mode) and j.p.herb.aspriority or j.p.herb.spriority
      end
    end
  end

  check(affs)
  if sys.deffing or conf.keepup then check(dict_herb) end

  -- have nada?
  if not next(prios) then return false end

  -- otherwise, do the highest!
  if not sync_mode then
    doaction(dict[getHighestKey(prios)].herb) else
    return dict[getHighestKey(prios)].herb end
end

-- misc check

-- build a table of all the things we need to do with their priority numbers,
-- sort it, and do the topmost thing.

-- this is just in case we're checking amnesia only
local amnesias = {
  amnesia = {p = dict.amnesia},
  fear    = {p = dict.fear},
}
check_misc = function(sync_mode, onlyamnesia)
  -- we -don't- check for sleep here, but a bit lower down - so waking can be on a misc
  if affs.stun or affs.unconsciousness then
    return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.misc and j.p.misc.isadvisable() and not ignore[i] and not doingaction (i) and (not affs.sleep or j.p.misc.action_name == "sleep")
      then
        prios[i] = (not sync_mode) and j.p.misc.aspriority or j.p.misc.spriority
      end
    end
  end

  if not onlyamnesia then
    check(affs)
    check(dict_misc)
    if sys.deffing or conf.keepup then check(dict_misc_def) end
  else
    check(amnesias)
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest! Also go down the list in priorities in case you need to dontbatch
  if not sync_mode then
    local set = index_map(prios)

    local highest, lowest = getBoundary(prios)

    local dontbatch
    for i = highest, lowest, -1 do
      if set[i] then
        if not dict[set[i]].misc.dontbatch or not dontbatch then
          doaction(dict[set[i]].misc)

          if dict[set[i]].misc.dontbatch then dontbatch = true end
        end
      end
    end
  else
    -- otherwise, do the highest!
    return dict[getHighestKey(prios)].misc
  end
end

local check_for_asthma = {
  checkasthma = {p = dict.checkasthma}
}
check_smoke = function(sync_mode)
  if not bals.smoke or affs.stun or affs.unconsciousness or affs.sleep or affs.asthma or affs.mucous then
    return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.smoke and j.p.smoke.isadvisable() and not ignore[i] and not doingaction(i)
      then
        prios[i] = (not sync_mode) and j.p.smoke.aspriority or j.p.smoke.spriority
      end
    end
  end

  check(affs)
  if affsp.asthma then check(check_for_asthma) end
  if sys.deffing or conf.keepup then check(dict_smoke_def) end

  -- have nada?
  if not next(prios) then return end

  if not sync_mode then
    local set = index_map(prios)

    local highest, lowest = getBoundary(prios)
    for i = highest, lowest, -1 do
      if set[i] then
        doaction(dict[set[i]].smoke)
      end
    end
  else
    -- otherwise, do the highest!
    return dict[getHighestKey(prios)].smoke
  end
end

check_moss = function(sync_mode)
  -- can we even sip?
  if not conf.moss or usingbal("moss") or affs.stun or affs.unconsciousness or not bals.moss
    or affs.sleep or affs.anorexia then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.moss and j.p.moss.isadvisable() and not ignore[i] then
        prios[i] = (not sync_mode) and j.p.moss.aspriority or j.p.moss.spriority
      end
    end
  end

  if not conf.secondarymoss then check(healthchecks) end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    doaction(dict[getHighestKey(prios)].moss) else
    return dict[getHighestKey(prios)].moss end
end

check_focus = function(sync_mode)
  -- can we even focus?
  if not next(affs) or usingbal("focus") or affs.stun or affs.unconsciousness or not bals.focus
    or affs.sleep or not can_usemana() or not conf.focus or stats.currentwillpower <= 75
    or affs.impatience or affs.inquisition or (affs.cadmus and not conf.focuswithcadmus) then
      return
  end


  -- get all prios in the list
  local prios = {}
  for i, j in pairs(affs) do
    if not (conf.serverside and serverignore[i]) and j.p.focus and (not affs.cadmus or (conf.focuswithcadmus and me.cadmusaffs[i])) and j.p.focus.isadvisable() and not ignore[i]
        then
        prios[i] = (not sync_mode) and j.p.focus.aspriority or j.p.focus.spriority
    end
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    doaction(dict[getHighestKey(prios)].focus) else
    return dict[getHighestKey(prios)].focus end
end


-- lifevision system

-- if something was added here, that means it was validated via other
-- means already - all we need to do now is to check if we had lifevision
-- catch the line or no.

-- other_action means do something else than default when done
-- arg is the argument to pass either to the default action
-- lineguard is how many lines this should be across - ineffective with vconfig batch
function lifevision.add(what, other_action, arg, lineguard)
  lifevision.l:set(what.name, {
    p = what,
    other_action = other_action,
    arg = arg
  })

  if lineguard and (not sys.lineguard or sys.lineguard > lineguard) then -- remember the smallest one, because if we have two conflicts, the smallest one is most valid
    sys.lineguard = lineguard
  end


  if not sys.sync then return end
  if actions[what.name] and what.balance ~= "aff" and what.balance ~= "gone" and color_table[conf.slowcurecolour] then
    selectCurrentLine()
    fg(conf.slowcurecolour)
    resetFormat()
    deselect()
  end
end

-- special: adds something where required, ie, first position in the queue
-- was necessary to have blackout be above everything else so stun AI doesn't slow it down 'till next prompt
function lifevision.addcust(what, where, other_action, arg)
  assert(what, "svo.lifevision.addcust wants an argument")
  lifevision.l:insert(where, what.name, {
    p = what,
    other_action = other_action,
    arg = arg
  })
end

-- returns the current lineguard that's set or nil
function lifevision.getlineguard()
  return sys.lineguard
end

function lifevision.clearlineguard()
  sys.lineguard = nil
end

local function run_through_actions()
  for i,j in lifevision.l:iter() do
    if not sk.stopprocessing then
      actionfinished(j.p, j.other_action, j.arg)
    else
      actionclear(j.p)
    end
  end
end

function lifevision.validate()
  -- take a line off the paragraph_length if the game's curing went off, as it is a "meta" message and shouldn't be counted
  local paragraph_length = paragraph_length
  if sk.sawcuring() then paragraph_length = paragraph_length - 1 end

  -- batch needs to disable lineguard, as commands come at once then. Plus, illusions aren't as prevalent anymore since serverside curing is completely immune to them
  if sys.flawedillusion or (not conf.batch and sys.lineguard and paragraph_length > sys.lineguard) then
    if sys.not_illusion then
      debugf("cancelled illusion")
      run_through_actions()

      moveCursor(0, getLineNumber()-1)
      moveCursor(#getCurrentLine(), getLineNumber())
      insertLink(" (!i)", '', (type(sys.not_illusion) == "string" and sys.not_illusion or "Cancelled detected 'illusion' due to script override."))
      sys.not_illusion = false
    else
      debugf("got an illusion")

      for i,j in lifevision.l:iter() do
        actionclear(j.p)
      end

      if sys.lineguard and not sys.flawedillusion then
        debugf("lifevision.validate: paragraph_length %d, sys.lineguard %d", paragraph_length, sys.lineguard)
        moveCursor(0, getLineNumber()-1)
        moveCursor(#getCurrentLine(), getLineNumber())
        insertLink(" (i)", '', "Ignored this whole illusion because the line(s) present need to be in their own.")
        moveCursorEnd()
      end
    end
    sys.flawedillusion, me.haveillusion = false, false
  else
    run_through_actions()
  end
  lifevision.l = pl.OrderedMap()
  sk.stopprocessing = nil
  sys.lineguard = false
end

checkanyaffs = function (...)
  local t = {...}
  for i=1,#t do
    local j = t[i]

    if affs[j.name] then
    return j end
  end
end

-- balanceful check
check_balanceful_acts = function(sync_mode)
  if affs.sleep or affs.stun or affs.unconsciousness or not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm
  then return end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.physical.balanceful_act and j.p.physical.isadvisable() and not ignore[i] then
        prios[i] = (not sync_mode) and j.p.physical.aspriority or j.p.physical.spriority
      end
    end
  end

  check(dict_balanceful)

  if sys.deffing or conf.keepup then
    check(dict_balanceful_def)
  end

  -- have nada?
  if not next(prios) then return false end

  -- otherwise, do the highest!
  if not sync_mode then
    doaction(dict[getHighestKey(prios)].physical) else
    return dict[getHighestKey(prios)].physical end

  return true
end

-- balanceless check
check_balanceless_acts = function(sync_mode)
  if affs.sleep or affs.stun or affs.unconsciousness or not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm
   then return end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    local gotsomething = false

    for i, j in pairs(what) do
      if not (conf.serverside and serverignore[i]) and j.p.physical.balanceless_act and j.p.physical.isadvisable() and not ignore[i] then
        prios[i] = (not sync_mode) and j.p.physical.aspriority or j.p.physical.spriority
        gotsomething = true
      end
    end

    return gotsomething
  end

  check(dict_balanceless)

  if sys.deffing or conf.keepup then
    check(dict_balanceless_def)
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    local set = index_map(prios)

    local highest, lowest = getBoundary(prios)
    for i = highest, lowest, -1 do
      if set[i] then
        doaction(dict[set[i]].physical)
      end
    end
  else
    return dict[getHighestKey(prios)].physical
  end

  return true
end

local balanceless = balanceless or {}
local balanceful = balanceful or {}

function sk.balance_controller()
  if sys.balanceid == sys.balancetick then return end

  if not (bals.balance and bals.equilibrium) or (affs.webbed or affs.bound or affs.transfixed or affs.roped or affs.impale or affs.paralysis or affs.sleep) then return end

  -- loop through all balanceless functions
  for k, f in pairs(balanceless) do
    f()
  end

-- loop through balanceful actions until we get one that takes bal or eq
  local r
  for k,f in pairs(balanceful) do
    r = f()
    if r then
      if sys.actiontimeoutid then killTimer(sys.actiontimeoutid) end
      if type(r) == "number" then
        sys.actiontimeoutid = tempTimer(r, function () sys.balancetick = sys.balancetick + 1; make_gnomes_work() end)
      elseif conf.lag and conf.lag == 4 then
        -- 24 does it right away!
        sys.actiontimeoutid = tempTimer(60*60*23, function () sys.balancetick = sys.balancetick + 1; make_gnomes_work() end)
      else
        sys.actiontimeoutid = tempTimer(sys.actiontimeout, function () sys.balancetick = sys.balancetick + 1; make_gnomes_work() end)
      end

      sys.balanceid = sys.balancetick
      break
    end
  end
end

function addbalanceless(name, func)
  assert(name and func, "svo.addbalanceless: both name and function are required")
  assert(type(func) == 'function', "svo.addbalanceless: function needs to be an actual function, while you gave it a "..type(func))

  balanceless[name] = func
end

function removebalanceless(name)
  balanceless[name] = nil
end

function addbalanceful(name, func)
  assert(name and func, "svo.addbalanceful: both name and function are required")
  assert(type(func) == "function", "svo.addbalanceful: second argument has to be a function (you gave it a "..type(func)..")")

  balanceful[name] = func
end

function removebalanceful(name)
  balanceful[name] = nil
end

function clearbalanceful()
  balanceful = {}
  addbalanceful("svo check do", sk.check_do)
  raiseEvent("svo balanceful ready")
end

function clearbalanceless()
  balanceless = {}
  addbalanceless("svo check dofree", sk.check_dofree)
  raiseEvent("svo balanceless ready")
end

tempTimer(0, function ()
  raiseEvent("svo balanceless ready")
  raiseEvent("svo balanceful ready")
end)

-- svo Got prompt
-- DO WORK!

-- utils
local function find_highest_action(tbl)
  local result
  local highest = 0
  for _,j in pairs(tbl) do
    if j.spriority > highest then
      highest = j.spriority
      result = j
    end
  end

  return result
end

local workload = {check_salve, check_focus, check_sip, check_purgative,
            check_smoke, check_herb, check_moss, check_misc,
            check_balanceless_acts, check_balanceful_acts}

-- real functions
local function work_slaves_work()
  -- in async, ask each bal to do its action

  check_misc(false, true) -- amnesia & fear only

  check_focus()
  check_salve()

  check_sip()
  check_purgative()
  check_smoke()
  check_herb()

  check_misc() -- fails for amnesia, but works for Priest Healing...

  check_moss()

  check_balanceless_acts()

  -- if the system didn't use bal, let it be used for other things.
  if not check_balanceful_acts() and not will_take_balance() then sk.balance_controller() end

  -- serverside prios: eat, apply, smoke, focus
end

make_gnomes_work_async = function()
  if conf.paused then return end

  signals.sysdatasendrequest:block(cnrl.processusercommand)

  if conf.commandecho and (conf.commandechotype == "fancy" or conf.commandechotype == "fancynewline") then
    send = fancysend

    -- delay expandAlias execution, used in dor, to after batch completes
    local oldexpandAlias = expandAlias
    if conf.batch then
      expandAlias = function(command, show)
        tempTimer(0, function()
          oldexpandAlias(command, (show and true or false)) -- see https://bugs.launchpad.net/mudlet/+bug/1456794
        end)
      end
    end

    work_slaves_work()
    -- commands are echoed by fancysendall() in onpromptr() in case of a prompt from the game, otherwise echo them right away if from a forced make_gnomes_work()
    if not sk.processing_prompt then fancysendall() end
    send = oldsend

    if conf.batch then
      expandAlias = oldexpandAlias
    end
  else
    work_slaves_work()
  end

  signals.sysdatasendrequest:unblock(cnrl.processusercommand)
end

make_gnomes_work_sync = function()
  sk.syncdebug = false
  if conf.paused or sacid then return end

  signals.sysdatasendrequest:block(cnrl.processusercommand)

  -- if we're already doing an action that is not of an "waitingfor" type, don't do anything!
  -- logic: if next returns nil,
  local result
  for balance,actions in pairs(bals_in_use) do
    if balance ~= "waitingfor" and balance ~= "gone" and balance ~= "aff" and next(actions) then result = select(2, next(actions)) break end
  end
  if result then
    sk.syncdebug = string.format("[%s]: Currently doing: %s", getTimestamp(getLineCount()):trim(), result.name)

    signals.sysdatasendrequest:unblock(cnrl.processusercommand)
    return
  end

  sk.gnomes_are_working = true

  local action_list = {}
  result = false

  --... check for all bals.
  -- in sync, only return values
  for i,j in pairs(workload) do
    result = j(true)
    if result then action_list[result.name] = result end
  end

  local actions = pl.tablex.keys(action_list)
  table.sort(actions, function(a,b)
    return action_list[a].spriority > action_list[b].spriority
  end)

  sk.syncdebug = string.format('[%s]: Feasible actions we\'re currently considering doing (in order): %s', getTimestamp(getLineCount()):trim(), (not next(action_list) and '(none)' or concatand(actions)))

  -- nothing to do =)
  if not next(action_list) then
    sk.gnomes_are_working = false

    signals.sysdatasendrequest:unblock(cnrl.processusercommand)
    return
  end

  if conf.commandecho and conf.commandechotype == "fancy" then
    send = fancysend
    local oldbatch = conf.batch
    conf.batch = false
    doaction(find_highest_action(action_list))
    -- commands are echoed by fancysendall() in onpromptr() in case of a prompt from the game, otherwise echo them right away if from a forced make_gnomes_work()
    if not sk.processing_prompt then fancysendall() end
    send = oldsend
    conf.batch = oldbatch
  else
    doaction(find_highest_action(action_list))
  end
  sk.gnomes_are_working = false

  signals.sysdatasendrequest:unblock(cnrl.processusercommand)
end

-- default is async
signals.aeony:connect(function()
  if sys.sync then
    make_gnomes_work = make_gnomes_work_sync
  else
    make_gnomes_work = make_gnomes_work_async
  end
end)
sk.checkaeony()
signals.aeony:emit()

function send_in_the_gnomes()
  -- at first, deal with lifevision.
  lifevision.validate()
  signals.after_lifevision_processing:emit()

  make_gnomes_work()
end

function update_rift_view()
  local status, msg = pcall(function () mm_create_riftlabel() end)

  if not status then error(msg) end
end

-- retrieve all lines until the last prompt, not including it
function sk.getuntilprompt()
  -- lastpromptnumber would include the prompt, -1 doesn't
  return getLines(lastpromptnumber+1, getLastLineNumber("main"))
end

function sk.makewarnings()
  sk.warnings = {
    lowwillpower = {
      time = 30,
      msg = "Warning: your <253,63,73>willpower is too low"..getDefaultColor().."! Need to regen some - otherwise you can't fight well (no clot, focus, and so on)."
    },
    somewhatreavable = {
      time = 10,
      msg = "Warning: you have two humours - an Alchemists <253,63,73>Reave"..getDefaultColor().." will take 10s",
    },
    nearlyreavable = {
      time = 5,
      msg = "Warning: you have three humours - an Alchemists <253,63,73>Reave"..getDefaultColor().." will take 8s",
    },
    reavable = {
      time = 5,
      msg = "Warning: you have all four humours - an Alchemists <253,63,73>Reave"..getDefaultColor().." will only take 4s",
    },
    dismemberable = {
      time = 5,
      msg = "Warning: you're bound and impaled - you can be instakilled! (dismember)"
    },
    cantclotmana = {
      time = 10,
      msg = "Going temporarily pause clotting your mana bleeding, your health is below corruptedhealthmin"
    },
    golemdestroyable = {
      time = 5,
      msg = "Warning: your flesh is melting - you can be instakilled! (golem destroy)"
    },
    pulpable = {
      time = 5,
      msg = "Warning: prone and serious concussion - you can be installed! (pulp)"
    },
    badaeon = {
      time = 5,
      msg = function()
        echof("Warning: your aeon situation is looking bad, you might want to %swalk out%s",
          (not conf.blockcommands and '' or "tsc off and "),
          (conf.org == "Ashtan" and " and ask for an empress") or
          (conf.org == "Targossas" and " and ask for a deliver") or
          (conf.org == "Cyrene" and " and ask for a deliver") or
          ""
        )
      end
    }
  }

  if conf.curemethod == "transonly" then
    sk.warnings.noelmid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>cinnabar"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.novalerianid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>realgar"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>malachite"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>realgar"..getDefaultColor().." pipe and it's empty! Don't chase balance for a bit",
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>realgar"..getDefaultColor().." pipe, it's empty, but can't due to blocking afflictions :(",
    }
  elseif conf.curemethod == "preferconc" then
    sk.warnings.noelmid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>elm"..getDefaultColor().."/<31,31,153>cinnabar"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.novalerianid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>valerian"..getDefaultColor().."/<31,31,153>realgar"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>skullcap"..getDefaultColor().."/<31,31,153>malachite"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>valerian"..getDefaultColor().."/<31,31,153>realgar"..getDefaultColor().." pipe and it's empty! Don't chase balance for a bit",
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>valerian"..getDefaultColor().."/<31,31,153>realgar"..getDefaultColor().." pipe, it's empty, but can't due to blocking afflictions :(",
    }
  elseif conf.curemethod == "prefertrans" then
    sk.warnings.noelmid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>cinnabar"..getDefaultColor().."/<31,31,153>elm"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.novalerianid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>realgar"..getDefaultColor().."/<31,31,153>valerian"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>malachite"..getDefaultColor().."/<31,31,153>skullcap"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>realgar"..getDefaultColor().."/<31,31,153>valerian"..getDefaultColor().." pipe and it's empty! Don't chase balance for a bit",
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>realgar"..getDefaultColor().."/<31,31,153>valerian"..getDefaultColor().." pipe, it's empty, but can't due to blocking afflictions :(",
    }
  else
    sk.warnings.noelmid = {
        time = 20,
        msg = "Warning: need to use your <31,31,153>elm"..getDefaultColor().." pipe and you don't have one!",
      }
    sk.warnings.novalerianid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>valerian"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = "Warning: need to use your <31,31,153>skullcap"..getDefaultColor().." pipe and you don't have one!",
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>valerian"..getDefaultColor().." pipe and it's empty! Don't chase balance for a bit",
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = "Warning: need to refill your <31,31,153>valerian"..getDefaultColor().." pipe, it's empty, but can't due to blocking afflictions :(",
    }
  end
end

signals.systemstart:add_post_emit(sk.makewarnings)
signals.orgchanged:add_post_emit(sk.makewarnings)
signals.curemethodchanged:connect(sk.makewarnings)

sk.warn = function (what)
  if sk.warnings[what].warned then return end

  tempTimer(sk.warnings[what].time, function() sk.warnings[what].warned = false end)
  sk.warnings[what].warned = true

  moveCursorEnd("main")
  echo("\n")

  if type(sk.warnings[what].msg) == 'function' then
    sk.warnings[what].msg()
  else echof(sk.warnings[what].msg) end

  echo("\n")
end

sk.retardation_count = 0
function sk.retardation_symptom()
  if (affs.retardation or affs.aeon or affsp.retardation or affsp.aeon or affsp.truename) then return end

  sk.retardation_count = sk.retardation_count + 1
  if sk.retardation_count >= 4 then
    if not affs.blackout then
      if not conf.aillusion then
        valid.simpleretardation()
        echo"\n" echof("auto-detected retardation.")
      else
        checkaction(dict.checkslows.aff, true)
        lifevision.add(actions.checkslows_aff.p, nil, "retardation")
        echo"\n" echof("Maybe we're in retardation - checking it.")
      end
    else
      valid.simpleunknownany(conf.unknownany)
      echo"\n" echof("auto-detection aeon or retardation (going to diagnose to check which)")
    end
    sk.retardation_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 3, function ()
    sk.retardation_count = sk.retardation_count - 1
    if sk.retardation_count < 0 then sk.retardation_count = 0 end
  end)
end

sk.stupidity_count = 0
function sk.stupidity_symptom()

  if conf.serverside then return end

  if affs.stupidity then return end

  sk.stupidity_count = sk.stupidity_count + 1

  if sk.stupidity_count >= 3 then
    valid.simplestupidity()
    echo"\n" echof("auto-detected stupidity.")
    sk.stupidity_count = 0
    return
  end

  tempTimer(syncdelay() + 2, function ()
    sk.stupidity_count = sk.stupidity_count - 1
    if sk.stupidity_count < 0 then sk.stupidity_count = 0 end
  end)
end

sk.illness_constitution_count = 0
function sk.illness_constitution_symptom()
  if not defc.constitution then return end
  if conf.serverside then return end

  if affs.illness_constitution then return end

  sk.illness_constitution_count = sk.illness_constitution_count + 1

  if sk.illness_constitution_count >= 2 then
    valid.simplehypochondria()

    echo"\n" echof("auto-detected hypochondria.")

    sk.illness_constitution_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 3, function ()
    sk.illness_constitution_count = sk.illness_constitution_count - 1
    if sk.illness_constitution_count < 0 then sk.illness_constitution_count = 0 end
  end)
end

sk.transfixed_count = 0
function sk.transfixed_symptom()
  if affs.transfixed then return end
  if conf.serverside then return end

  if affs.transfixed then return end

  sk.transfixed_count = sk.transfixed_count + 1

  if sk.transfixed_count >= 2 then
    valid.simpletransfixed()

    -- supress echo when got hit with it before ai went off
    if not affsp.transfixed then
      echo"\n" echof("auto-detected transfix.")
    end
    sk.transfixed_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 3, function ()
    sk.transfixed_count = sk.transfixed_count - 1
    if sk.transfixed_count < 0 then sk.transfixed_count = 0 end
  end)
end

sk.stun_count = 0
function sk.stun_symptom()
  if affs.stun then return end

  sk.stun_count = sk.stun_count + 1

  if sk.stun_count >= 3 then
    valid.simplestun()
    echo"\n" echof("auto-detected stun.")
    sk.stun_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.stun_count = sk.stun_count - 1
    if sk.stun_count < 0 then sk.stun_count = 0 end
  end)
end

sk.impale_count = 0
function sk.impale_symptom()
  if conf.serverside then return end

  if affs.impale then return end

  sk.impale_count = sk.impale_count + 1

  if sk.impale_count >= 2 then
    valid.simpleimpale()
    echo"\n" echof("auto-detected impale.")
    sk.impale_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.impale_count = sk.impale_count - 1
    if sk.impale_count < 0 then sk.impale_count = 0 end
  end)
end

sk.aeon_count = 0
function sk.aeon_symptom()
  if affs.aeon then return end

  sk.aeon_count = sk.aeon_count + 1

  if sk.aeon_count >= 2 then
    valid.simpleaeon()
    defs.lost_speed()
    echo"\n" echof("auto-detected aeon.")
    sk.aeon_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.aeon_count = sk.aeon_count - 1
    if sk.aeon_count < 0 then sk.aeon_count = 0 end
  end)
end

sk.paralysis_count = 0
function sk.paralysis_symptom()
  if conf.serverside then return end

  if affs.paralysis then return end

  sk.paralysis_count = sk.paralysis_count + 1

  if sk.paralysis_count >= 2 then
    valid.simpleparalysis()
    echo"\n" echof("auto-detected paralysis.")
    sk.paralysis_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.paralysis_count = sk.paralysis_count - 1
    if sk.paralysis_count < 0 then sk.paralysis_count = 0 end
  end)
end

sk.haemophilia_count = 0
function sk.haemophilia_symptom()
 if affs.haemophilia then return end

  sk.haemophilia_count = sk.haemophilia_count + 1

  if sk.haemophilia_count >= 2 then
    valid.simplehaemophilia()
    echo"\n" echof("haemophilia seems to be real.")
    sk.haemophilia_count = 0
    return
  end

  -- special # 1 - so haemophilia illusions 'can't' happen within 1s
  tempTimer(syncdelay() + 1, function ()
    sk.haemophilia_count = sk.haemophilia_count - 1
    if sk.haemophilia_count < 0 then sk.haemophilia_count = 0 end
  end)
end

sk.webbed_count = 0
function sk.webbed_symptom()
  if conf.serverside then return end

  if affs.webbed then return end

  sk.webbed_count = sk.webbed_count + 1
  if sk.webbed_count >= 2 then
    valid.simplewebbed()
    echo"\n" echof("auto-detected web.")
    sk.webbed_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.webbed_count = sk.webbed_count - 1
    if sk.webbed_count < 0 then sk.webbed_count = 0 end
  end)
end

sk.roped_count = 0
function sk.roped_symptom()
  if conf.serverside then return end

  if affs.roped then return end

  sk.roped_count = sk.roped_count + 1

  if sk.roped_count >= 2 then
    valid.simpleroped()
    echo"\n" echof("auto-detected roped.")
    sk.roped_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.roped_count = sk.roped_count - 1
    if sk.roped_count < 0 then sk.roped_count = 0 end
  end)
end


sk.impaled_count = 0
function sk.impaled_symptom()
  if conf.serverside then return end

  if affs.impale then return end

  sk.impaled_count = sk.impaled_count + 1

  if sk.impaled_count >= 2 then
    valid.simpleimpale()
    echo"\n" echof("auto-detected impale.")
    sk.impaled_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.impaled_count = sk.impaled_count - 1
    if sk.impaled_count < 0 then sk.impaled_count = 0 end
  end)
end


sk.hypochondria_count = 0
function sk.hypochondria_symptom()
  if find_until_last_paragraph(line, "exact") or affs.hypochondria then return end

  sk.hypochondria_count = sk.hypochondria_count + 1

  if sk.hypochondria_count >= 3 then
    valid.simplehypochondria()
    sk.hypochondria_count = 0
  end

  tempTimer(12, function ()
    sk.hypochondria_count = sk.hypochondria_count - 1
    if sk.hypochondria_count < 0 then sk.hypochondria_count = 0 end
  end)
end

sk.unparryable_count = 0
function sk.unparryable_symptom()
  if conf.aillusion and paragraph_length ~= 1 and not find_until_last_paragraph("Your scabbard does not contain your blade, Warrior.", "exact") and not find_until_last_paragraph("You have not positioned a scabbard on your hip, Warrior.", "exact") then
    ignore_illusion("not first") return
  elseif affs.unparryable then return end

  sk.unparryable_count = sk.unparryable_count + 1

  if sk.unparryable_count >= 2 then
    sk.cant_parry()
    sk.unparryable_count = 0
    return
  end

  tempTimer(syncdelay() + sys.wait * 2, function ()
    sk.unparryable_count = sk.unparryable_count - 1
    if sk.unparryable_count < 0 then sk.unparryable_count = 0 end
  end)
end

updateaffcount = function (which)
  affl[which.name].count = which.count

  raiseEvent("svo updated aff", which.name, "count", which.count)
end

local function update_eventaffs()
  -- adds an affliction for the system to be tracking (ie - you are afflicted with it)
  -- does not mess with aff.<affliction>s table if the aff is already registered
  addaff = function (new)
  if not new then debugf("no new, log: %s", debug.traceback()) end
    if affs[new.name] then return end

    local name = new.name

    affs[name] = {
      p = new,
      sw = new.sw or createStopWatch()
    }
    startStopWatch(affs[name].sw)

    -- call the onadded handler if any
    if dict[name].onadded then dict[name].onadded() end

    if not affl[name] then
      affl[name] = { sw = affs[name].sw }
      signals.svogotaff:emit(name)
      raiseEvent("svo got aff", name)
    end
  end

  -- removeaff
  removeaff = function (old)
    if type(old) == "table" then
      for _,aff in pairs(old) do
        removeaff(aff)
      end
      return
    end

    if not affs[old] then return end

    if affl[old] then
      affl[old] = nil
      signals.svolostaff:emit(old)
      raiseEvent("svo lost aff", old)
    end

    -- removeaff can be called on affs that don't exist, that's valid
    local sw = (affs[old] and affs[old].sw or nil)
    affs[old] = nil

    -- call the onremoved handler if any. Should be called after affs is cleaned, because scripts here reply on the 'current' state
    if dict[old].onremoved then
      dict[old].onremoved()
    end

    if conf.showafftimes and sw then
      echoafftime(stopStopWatch(sw), old)
    end
  end
end
signals.systemstart:connect(update_eventaffs)

-- externally available as svo.prompttrigger
sk.onpromptfuncs = {}
function sk.onprompt_beforeaction_add(name, what)
  sk.onpromptfuncs[name] = what
end

sk.onprompt_beforeaction_do = function()
  for name, func in pairs(sk.onpromptfuncs) do
    local s,m = pcall(func)
    if not s then
      echoLink("(e!)", "echo([[The problem was: "..tostring(name).." prompttrigger failed to work: "..string.format("%q", m).."]])", 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw if this isn\'t your own function.')
    end
  end
  sk.onpromptfuncs = {}
end
signals.after_lifevision_processing:connect(sk.onprompt_beforeaction_do)

-- externally available as svo.aiprompt
sk.onpromptaifuncs = {}
function sk.onprompt_beforelifevision_add(name, what)
  sk.onpromptaifuncs[name] = what
end

sk.onprompt_beforelifevision_do = function()
  for name, func in pairs(sk.onpromptaifuncs) do
    local s,m = pcall(func)
    if not s then
      echoLink("(e!)", "echo([[The problem was: "..tostring(name).." aiprompt failed to work: "..string.format("%q", m).."]])", 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw if this isn\'t your own function.')
    end
  end
  sk.onpromptaifuncs = {}
end
signals.before_prompt_processing:connect(sk.onprompt_beforelifevision_do)

lostbal_tree = function()
  if bals.tree then tempTimer(0, [[raiseEvent("svo lost balance", "tree")]]) end
  bals.tree = false
  startbalancewatch("tree")
  if sys.treetimer then killTimer(sys.treetimer) end
  -- if conf.treebalance is set, use that - otherwise use the defaults as setup by conf.efficiency + hardcoded numbers
  local timeout
  if not conf.treebalance or conf.treebalance == 0 then
    timeout = conf.efficiency and (16+getping()) or (40+getping())
  else
    timeout = conf.treebalance
  end
  if affs.ninkharsag then timeout = timeout + 10 end

  sys.treetimer = tempTimer(timeout, [[svo.bals.tree = true;
    svo.echof("Can touch tree again.")
    svo.showprompt()
    raiseEvent("svo got balance", "tree")]])
end

lostbal_focus = function()
  if not bals.focus then return end

  bals.focus = false
  startbalancewatch("focus")
  sk.focustick = sk.focustick + 1
  local oldfocustick = sk.focustick

  -- respect conf.ai_resetfocusbal while setting a minimum of 8s
  local timeout = conf.ai_resetfocusbal
  if affs.rixil then
    if conf.ai_resetfocusbal < 5 then
      timeout = conf.ai_resetfocusbal + 5
    else
      timeout = 8
    end
  end

  tempTimer(timeout, function ()
    if not bals.focus and sk.focustick == oldfocustick then
      bals.focus = true
      make_gnomes_work()
      raiseEvent("svo got balance", "focus")
    end
  end)

  raiseEvent("svo lost balance", "focus")
end

lostbal_shrugging = function()
  if not bals.shrugging then return end

  bals.shrugging = false
  startbalancewatch("shrugging")
  sk.shruggingtick = sk.shruggingtick + 1
  local oldshruggingtick = sk.shruggingtick

  tempTimer(10+getping(), function ()
    if not bals.shrugging and sk.shruggingtick == oldshruggingtick then
      bals.shrugging = true
      make_gnomes_work()
      raiseEvent("svo got balance", "shrugging")
    end
  end)

  raiseEvent("svo lost balance", "shrugging")
end

lostbal_fitness = function()
  if not bals.fitness then return end

  bals.fitness = false
  startbalancewatch("fitness")
  sk.fitnesstick = sk.fitnesstick + 1
  local oldfitnesstick = sk.fitnesstick

  -- takes 9s to recover
  tempTimer(15+getping(), function ()
    if not bals.fitness and sk.fitnesstick == oldfitnesstick then
      bals.fitness = true
      make_gnomes_work()
      raiseEvent("svo got balance", "fitness")
    end
  end)

  raiseEvent("svo lost balance", "fitness")
end

lostbal_rage = function()
  if not bals.rage then return end

  bals.rage = false
  startbalancewatch("rage")
  sk.ragetick = sk.ragetick + 1
  local oldragetick = sk.ragetick

  -- takes 9s to recover
  tempTimer(15+getping(), function ()
    if not bals.rage and sk.ragetick == oldragetick then
      bals.rage = true
      make_gnomes_work()
      raiseEvent("svo got balance", "rage")
    end
  end)

  raiseEvent("svo lost balance", "rage")
end

lostbal_voice = function()
  if not bals.voice then return end

  bals.voice = false
  startbalancewatch("voice")
  sk.voicetick = sk.voicetick + 1
  local oldvoicetick = sk.voicetick

  tempTimer(10+getping(), function ()
    if not bals.voice and sk.voicetick == oldvoicetick then
      bals.voice = true
      make_gnomes_work()
      raiseEvent("svo got balance", "voice")
    end
  end)

  raiseEvent("svo lost balance", "voice")
end

lostbal_sip = function()
  bals.sip = false
  startbalancewatch("sip")
  sk.siptick = sk.siptick + 1
  local oldsiptick = sk.siptick

  -- multiply by 2 if we have addiction
  local lostbalance = conf.ai_resetsipbal
  if affs.addiction then lostbalance = lostbalance * 2 end
  -- add .5s for earth disrupt delaying it
  if affs.earthdisrupt then lostbalance = lostbalance + 0.5 end

  tempTimer(lostbalance, function ()
    if not bals.sip and sk.siptick == oldsiptick then
      bals.sip = true
      make_gnomes_work()
      raiseEvent("svo got balance", "sip")
    end
  end)

  raiseEvent("svo lost balance", "sip")
end

lostbal_herb = function(noeffect, mickey)
  bals.herb = false
  startbalancewatch("herb")
  sk.herbtick = sk.herbtick + 1
  local oldherbtick = sk.herbtick

  tempTimer(conf.ai_resetherbbal, function ()
    if not bals.herb and sk.herbtick == oldherbtick then
      bals.herb = true
      make_gnomes_work()
      raiseEvent("svo got balance", "herb")
    end
  end)

  watch["bal_herb"] = watch["bal_herb"] or createStopWatch()
  startStopWatch(watch["bal_herb"])

  -- voided gives us the balance quick enough
  if (affs.voided and noeffect) then raiseEvent("svo lost balance", "herb") return end

  watch.herb_block = watch.herb_block or createStopWatch()
  startStopWatch(watch.herb_block)

  if sk.blockherbbal then killTimer(sk.blockherbbal) end
  -- mickey steals bal for .8s
  sk.blockherbbal = tempTimer((mickey and .5 or conf.ai_minherbbal), function ()
    sk.blockherbbal = nil
  end)

  raiseEvent("svo lost balance", "herb")
end

lostbal_salve = function()
  bals.salve = false
  startbalancewatch("salve")
  sk.salvetick = sk.salvetick + 1
  local oldsalvetick = sk.salvetick

  tempTimer(conf.ai_resetsalvebal, function ()
    if not bals.salve and sk.salvetick == oldsalvetick then
      bals.salve = true
      make_gnomes_work()
      raiseEvent("svo got balance", "salve")
    end
  end)

  raiseEvent("svo lost balance", "salve")
end

lostbal_moss = function()
  bals.moss = false
  startbalancewatch("moss")
  sk.mosstick = sk.mosstick + 1
  local oldmosstick = sk.mosstick

  tempTimer(conf.ai_resetmossbal, function ()
    if not bals.moss and sk.mosstick == oldmosstick then
      bals.moss = true
      make_gnomes_work()
      raiseEvent("svo got balance", "moss")
    end
  end)

  raiseEvent("svo lost balance", "moss")
end

lostbal_purgative = function()
  bals.purgative = false
  startbalancewatch("purgative")
  sk.purgativetick = sk.purgativetick + 1
  local oldpurgativetick = sk.purgativetick

  tempTimer(conf.ai_resetpurgativebal, function ()
    if not bals.purgative and sk.purgativetick == oldpurgativetick then
      bals.purgative = true
      make_gnomes_work()
      raiseEvent("svo got balance", "purgative")
    end
  end)

  raiseEvent("svo lost balance", "purgative")
end

lostbal_smoke = function()
  bals.smoke = false
  startbalancewatch("smoke")
  sk.smoketick = sk.smoketick + 1
  local oldsmoketick = sk.smoketick

  tempTimer(conf.ai_resetsmokebal, function ()
    if not bals.smoke and sk.smoketick == oldsmoketick then
      bals.smoke = true
      make_gnomes_work()
      raiseEvent("svo got balance", "smoke")
    end
  end)

  watch["bal_smoke"] = watch["bal_smoke"] or createStopWatch()
  startStopWatch(watch["bal_smoke"])

  raiseEvent("svo lost balance", "smoke")
end

lostbal_dragonheal = function()
  bals.dragonheal = false
  startbalancewatch("dragonheal")
  sk.dragonhealtick = sk.dragonhealtick + 1
  local olddragonhealtick = sk.dragonhealtick

  -- dragonheal bal is quite long, add a bit of variation on it
  tempTimer(conf.ai_resetdragonhealbal+getping(), function ()
    if not bals.dragonheal and sk.dragonhealtick == olddragonhealtick then
      bals.dragonheal = true
      make_gnomes_work()
      raiseEvent("svo got balance", "dragonheal")
    end
  end)

  raiseEvent("svo lost balance", "dragonheal")
end


function sk.doingstuff_inslowmode()
  local result
  for balance,actions in pairs(bals_in_use) do
    if balance ~= "waitingfor" and balance ~= "gone" and balance ~= "aff" and next(actions) then result = select(2, next(actions)) break end
  end
  if result then return true end
end

function sk.checkwillpower()
  if stats.currentwillpower <= 1000 and not sk.lowwillpower then
    sk.lowwillpower = true
    sk.warn("lowwillpower")

    can_usemana = function()
      return (stats.currentmana > sys.manause and stats.currentwillpower >= 100 and not doingaction ("nomana"))
    end

  -- amounts differ so we don't toggle often
  elseif stats.currentwillpower > 1500 and sk.lowwillpower then
    sk.lowwillpower = false

    can_usemana = function()
      return (stats.currentmana > sys.manause and not doingaction ("nomana"))
    end
  end
end

sk.limbnames = {
  rightarm = true,
  leftarm = true,
  leftleg = true,
  rightleg = true,
  torso = true,
  head = true
}


function sk.increase_lagconf()
  -- don't go above 3, 4 is reserved for do really
  if conf.lag >= 3 then return end

  if sk.lag_tickedonce and not sk.increasedlag then
    conf.lag = conf.lag+1
    echo"\n" echof("auto-increased the lag tolerance level to %d.", conf.lag)
    raiseEvent("svo config changed", "lag")
    sk.increasedlag = true
    cnrl.update_wait()

    if sys.reset_laglevel then killTimer(sys.reset_laglevel) end
    sys.reset_laglevel = tempTimer(30, function ()
      if not wait_tbl[conf.lag-1] then return end

      local variance = getNetworkLatency()*2+getNetworkLatency()
      for i = 0, #wait_tbl do
        if variance <= wait_tbl[i].n then
          conf.lag = i
          cnrl.update_wait()
          echo"\n" echof("automatically reset lag tolerance down to %d.", conf.lag)
          raiseEvent("svo config changed", "lag")
          break
        end
      end
    end)
  else
    sk.lag_tickedonce = tempTimer(10, function () sk.lag_tickedonce = nil; sk.increasedlag = true end)
  end
end


signals.gmcpcharitemslist:connect(function ()
  if not gmcp.Char.Items.List.location then echof("(GMCP problem) location field is missing from Achaea's response.") return end
  if not sk.inring or gmcp.Char.Items.List.location ~= "inv" then return end

  local hadsomething = {}
  for _, t in pairs(gmcp.Char.Items.List.items) do
    if t.attrib and t.attrib:find("r", 1, true) then

      -- see if we can optimize groupables with 'inr all <type>', making it easier count as well: handle groups first
      if t.name and t.name:find("a group of", 1, true) then
        -- function to scan plurals table
        local check = function(value,input) return input:find("a group of "..value) end

        -- check herbs table
        local found_plural = next(pl.tablex.map(check, rift.herbs_plural, t.name or ""))
        -- check other riftable items table
        found_plural = found_plural or next(pl.tablex.map(check, rift.items_plural, t.name or ""))

        if found_plural and not hadsomething[found_plural] then
          sendc("inr all "..found_plural, false)
          hadsomething[found_plural] = true
        elseif not found_plural and not hadsomething[t.id] then
          sendc("inr "..t.id, false)
          hadsomething[t.id] = true
        end

      -- singular herb items that we know of
      elseif t.name and rift.herbs_singular[t.name] and not hadsomething[rift.herbs_singular[t.name]] then
        hadsomething[rift.herbs_singular[t.name]] = true
        sendc("inr all "..rift.herbs_singular[t.name], false)

      -- singular non-herb items
      elseif t.name and rift.items_singular[t.name] and not hadsomething[rift.items_singular[t.name]] then
        hadsomething[rift.items_singular[t.name]] = true
        sendc("inr all "..rift.items_singular[t.name], false)

      -- all the rest
      elseif not rift.items_singular[t.name] and not rift.herbs_singular[t.name] and not hadsomething[t.id] and t.attrib and t.attrib:find("r", 1, true) then
        sendc("inr "..t.id, true)
        hadsomething[t.id] = true
      end
    end
  end

  sk.inring = nil
  if next(hadsomething) then
    echof("Stuffing everything away...")
  else
    echof("There's nothing to stuff away.")
  end
end)

signals.gmcpcharitemslist:connect(function()
  if not sk.retrieving_herbs or gmcp.Char.Items.List.location ~= "room" then return end

  for _, t in pairs(gmcp.Char.Items.List.items) do
    if rift.herbs_singular[t.name] then
      doaddfree("get "..t.id)
    end

    -- tally up rift.herbs_plural items
    for k,l in pairs(rift.herbs_plural) do
      local result = t.name:match(l)
      if result then
        for i = 1, tonumber(result) do -- getting group # only gets 1 item, have to repeatedly cycle it
          doaddfree("get "..t.id)
        end
      end
    end
  end

  sk.retrieving_herbs = nil
end)

for _, herb in ipairs{"elm", "valerian", "skullcap"} do
  sk[herb.."_smokepuff"] = function ()
    if not conf.arena then
      pipes[herb].puffs = pipes[herb].puffs - 1
      if pipes[herb].puffs < 0 then pipes[herb].puffs = 0 end
    end

    if herb == "valerian" then
      signals.after_lifevision_processing:unblock(cnrl.checkwarning)
    end

    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    setFgColor(unpack(getDefaultColorNums))
    insertText(string.format(" (%s %s left)", pipes[herb].puffs, pipes[herb].filledwith))
    resetFormat()
    moveCursorEnd()
  end
end


function sk.enable_single_prompt()
  if bottomprompt then bottomprompt:show() end
  bottomprompt = Geyser.MiniConsole:new({
    name="bottomprompt",
    x=0, y="100%",
    width="98%", height="1c",
    fontSize = conf.singlepromptsize or 11
  })
  bottomprompt:setFontSize(conf.singlepromptsize or 11)

  function bottomprompt:reposition()
     local width,height = calcFontSize(conf.singlepromptsize or 11)

     if not bottom_border or bottom_border ~= height then
       bottom_border = height
       tempTimer(0, function() setBorderBottom(height) end)
     end

     local x,y,w,h = self:get_x(), self:get_y(), self:get_width(), self:get_height()
     moveWindow(self.name, self:get_x(), self:get_y()-(height+(height/3)))
     resizeWindow(self.name, self:get_width(), self:get_height())
  end
  setBackgroundColor("bottomprompt",0,0,0,255)
  bottomprompt:reposition()

  if moveprompt then killTrigger(moveprompt) end
  -- moveprompt = tempRegexTrigger('^', [[
  --   if not isPrompt() then return end
  --   selectCurrentLine()
  --   copy()
  --   clearWindow("bottomprompt")
  --   paste("bottomprompt")
  --   if svo.conf.singlepromptblank then
  --     replace("")
  --   elseif not svo.conf.singlepromptkeep then deleteLine() end
  --   deselect()
  -- ]])
end

function sk.showstatchanges()
  local t = sk.statchanges
  if #t > 0 then
    if conf.singleprompt then
      moveCursor(0, getLineNumber()-1)
      moveCursor(#getCurrentLine(), getLineNumber())
      dinsertText(' <192,192,192>('..table.concat(t, ", ")..'<192,192,192>) ')
    else
      decho('<192,192,192>('..table.concat(t, ", ")..'<192,192,192>) ')
    end

    resetFormat()
    if conf.singleprompt then moveCursorEnd() end
  end
end

-- logic: if something we are wielding does not show up unparryables, then we can wield
function sk.have_parryable()
  me.unparryables = me.unparryables or {}

  for _, item in pairs(me.wielded) do
    if not me.unparryables[item.name] then return true end
  end
end

function sk.cant_parry()
  local t = {}
  me.unparryables = me.unparryables or {}
  for _, item in pairs(me.wielded) do
    if not me.unparryables[item.name] then
      t[#t+1] = item.name
      me.unparryables[item.name] = true
    end
  end

  if #t > 0 then
    echo'\n'

    local lines = {
      "Oh, looks like we can't parry with %s.",
      "Doesn't look like we can parry with %s.",
      "Oops. Can't parry with %s.",
      "And %s won't fly, either.",
      "And %s won't work, either."
    }

    echof(lines[math.random(#lines)], table.concat(t, ' or '))
  end
end

signals.newroom:connect(function ()
  -- don't get tricked by dementia, which does send false gmcp
  -- nor by hidden dementia
  if affs.dementia or affs.unknownany or affs.unknownmental or not conf.autoarena then return end

  local t = sk.arena_areas

  local area = atcp.RoomArea or gmcp.Room.Info.area

  if t[area] and not conf.arena then
    conf.arena = true
    raiseEvent("svo config changed", "arena")
    prompttrigger("arena echo", function()
      local echos = {"Arena mode enabled. Good luck!", "Beat 'em up! Arena mode enabled.", "Arena mode on.", "Arena mode enabled. Kill them all!"}
      itf(echos[math.random(#echos)]..'\n')
    end)
  elseif conf.arena and not t[area] then
    conf.arena = false
    raiseEvent("svo config changed", "arena`")
    tempTimer(0, function()
      local echos = {"Arena mode disabled."}
      echof(echos[math.random(#echos)]..'\n')

      -- the game resets armbals quietly
      if not bals.rightarm then bals.rightarm = true end
      if not bals.leftarm then bals.leftarm = true end
    end)
  end
end)

-- this will get connected on load
sk.check_burrow_pause = function()
  local roomname = _G.gmcp.Room.Info.name

  if not conf.paused and roomname == "Surrounded by dirt" then sk.paused_for_burrow = true; svo.app("on")
  elseif sk.paused_for_burrow and conf.paused and roomname ~= "Surrounded by dirt" and stats.currenthealth > 0 then svo.app("off")
  end
end

function sk.check_shipmode()
  -- failsafe for disabling captain control - since there are a few ways in which you can lose it without an explicit line.
  if conf.shipmode and gmcp.Room.Info.environment ~= "Vessel" then
    config.set("shipmode", "off", true)
  end
end

function balanceful_used()
  return (sys.balanceid == sys.balancetick) and true or false
end

-- getNetworkLatency, with a cap
function getping(cap)
  local cap = cap or .500
  local lat = getNetworkLatency()

  return (lat < cap) and lat or cap
end

-- returns true if a curing command was seen in this paragraph
function sk.sawcuring()
  -- don't search the buffer, but set a flag, because people could be gagging the line and buffer search will thus fail
  return sk.sawcuringcommand and true or false
end

function sk.sawqueueing()
  return sk.sawqueueingcommand and true or false
end

function amiwielding(what)
  for id, item in pairs(svo.me.wielded) do
    if item.name:find("%f[%a]"..what.."%f[%A]") then return true end
  end

  return false
end

function sk.sendqueuecmd(...)
  local args = {...}
  for i = 1, #args do
    local what = args[i]
    if type(what) == "string" then
      -- flush the buffer if it'll overflow how many chars we can send
      if sk.sendqueuel + #what + 1 >= sk.achaea_command_max_length then
        sk.dosendqueue()
      end

      sk.sendqueue[#sk.sendqueue+1] = what
      sk.sendqueuel = sk.sendqueuel + #what + 1 -- +1 for the separator
      if not sk.sendcuringtimer then
        sk.sendcuringtimer = tempTimer(0, sk.dosendqueue)
      end
    end
  end
end

function sendcuring(what)
  what = "curing "..what

  sk.sendqueuecmd(what)
end

-- public function
sendc = sk.sendqueuecmd

function sk.dosendqueue()
  if sk.sendcuringtimer then killTimer(sk.sendcuringtimer) end

  if #sk.sendqueue <= 1 then
    send(sk.sendqueue[1] or '', false)
  elseif conf.commandseparator and conf.commandseparator ~= '' and #sk.sendqueue <= 10 then
    send(table.concat(sk.sendqueue, conf.commandseparator), false)
  elseif #sk.sendqueue <= 9 then
    send("9multicmd {"..table.concat(sk.sendqueue, "}{").."}", false)
  else
    local text = table.concat(sk.sendqueue, "/")
    sendAll("setalias multicmd "..text, "multicmd", false)
  end

  sk.sendqueue = {}
  sk.sendqueuel = 18 -- 'setalias multicmd ' is 24 characters
  sk.sendcuringtimer = nil
end

function sk.setup9multicmd()
  send("setalias 9multicmd %1/%2/%3/%4/%5/%6/%7/%8/%9", false)
end
signals.charname:connect(sk.setup9multicmd)
signals.gmcpcharname:connect(sk.setup9multicmd)

svo["9multicmd_cleared"] = function()
  send("setalias 9multicmd %1/%2/%3/%4/%5/%6/%7/%8/%9")

  echo("\n")
  echof("Oy! I need that! This is for vconfig batch to work.")

  reenabled9multi = tempTimer(5, function() reenabled9multi = nil end)
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

local oldhealth, oldmana = 0, 0
me.healthchange, me.manachange = 0, 0
local function calculatestatchanges()
  local t = {}
  local stats = stats

  me.healthchange = 0
  me.manachange = 0
  if oldhealth > stats.currenthealth then
    me.healthchange = stats.currenthealth - oldhealth

    if conf.showchanges then
      if conf.changestype == "full" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128> Health", me.healthchange)
      elseif conf.changestype == "short" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128>h", me.healthchange)
      elseif conf.changestype == "fullpercent" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128> Health, %.1f%%", me.healthchange, 100/stats.maxhealth*me.healthchange*-1)
      elseif conf.changestype == "shortpercent" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128>h, %.1f%%", me.healthchange, 100/stats.maxhealth*me.healthchange*-1)
      end
    end

  elseif oldhealth < stats.currenthealth then
    me.healthchange = stats.currenthealth - oldhealth

    if conf.showchanges then
      if conf.changestype == "full" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128> Health", me.healthchange)
      elseif conf.changestype == "short" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128>h", me.healthchange)
      elseif conf.changestype == "fullpercent" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128> Health, %.1f%%", me.healthchange, 100/stats.maxhealth*me.healthchange)
      elseif conf.changestype == "shortpercent" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128>h, %.1f%%", me.healthchange, 100/stats.maxhealth*me.healthchange)
      end
    end
  end

  if oldmana > stats.currentmana then
    me.manachange = stats.currentmana - oldmana

    if conf.showchanges then
      if conf.changestype == "full" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128> Mana", me.manachange)
      elseif conf.changestype == "short" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128>m", me.manachange)
      elseif conf.changestype == "fullpercent" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128> Mana, %.1f%%", me.manachange, 100/stats.maxmana*me.manachange*-1)
      elseif conf.changestype == "shortpercent" then
        t[#t+1] = string.format("<255,0,0>%d<128,128,128>m, %.1f%%", me.manachange, 100/stats.maxmana*me.manachange*-1)
      end
    end

  elseif oldmana < stats.currentmana then
    me.manachange = stats.currentmana - oldmana

    if conf.showchanges then
      if conf.changestype == "full" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128> Mana", me.manachange)
      elseif conf.changestype == "short" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128>m", me.manachange)
      elseif conf.changestype == "fullpercent" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128> Mana, %.1f%%", me.manachange, 100/stats.maxmana*me.manachange)
      elseif conf.changestype == "shortpercent" then
        t[#t+1] = string.format("<0,255,0>+%d<128,128,128>m, %.1f%%", me.manachange, 100/stats.maxmana*me.manachange)
      end
    end
  end

  -- update the public old values
  me.oldhealth, me.oldmana = oldhealth, oldmana

  -- update oldhealth, oldmana to current values
  oldhealth, oldmana = stats.currenthealth, stats.currentmana

  -- store away changed for showing later, as the custom prompt that follows overrides
  sk.statchanges = t
end

local blackout_flag
function blackout()
  blackout_flag = true
end

local function checkblackout()
  if blackout_flag and not affs.blackout then
    valid.simpleblackout()
  elseif not blackout_flag and affs.blackout and getCurrentLine() ~= "" then
    if actions.touchtree_misc then
      lifevision.add(actions.touchtree_misc.p, nil, "blackout")
    else
      checkaction(dict.blackout.waitingfor, true)
      lifevision.add(actions.blackout_waitingfor.p)
    end
  end

  blackout_flag = false
end

function valid.setup_prompt()
  if line == "-" or line:find("^%-%d+%-$") or line == " Vote-" then
    -- bals.balance = true
    -- bals.equilibrium = true
    bals.rightarm = "unset"
    bals.leftarm = "unset"
  else
    bals.balance = false
    bals.equilibrium = false
    pflags = {}
  end
end

local function check_promptflags()
  local pflags = svo.pflags

  if pflags.b and not defc.blind and not affs.blindaff then
    if ((defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)
     ) then
      defences.got("blind")
    else
      addaff(dict.blindaff)
    end
  elseif not pflags.b and (defc.blind or affs.blindaff) then
    removeaff("blindaff")
    defences.lost("blind")
  end

  if pflags.d and not defc.deaf and not affs.deafaff then
    if ((defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye) then
      defences.got("deaf")
    else
      addaff(dict.deafaff)
    end
  elseif not pflags.d and (defc.deaf or affs.deafaff) then
    removeaff("deafaff")
    defences.lost("deaf")
  end

  if pflags.k and not defc.kola then
    defences.got("kola")
  elseif not pflags.k and defc.kola then
    defences.lost("kola")
  end

  if pflags.c and not defc.cloak then
    defences.got("cloak")
  elseif not pflags.c and defc.cloak then
    defences.lost("cloak")
  end



  if pflags.at then defences.got("blackwind") else defences.lost("blackwind") end



  local oldgametarget, oldgametargethp = me.gametarget, me.gametargethp
  me.gametarget, me.gametargethp = line:match("%[(.-)%](%d+)%%")
  if me.gametargethp then me.gametargethp = tonumber(me.gametargethp) end
  if oldgametarget ~= me.gametarget then
    raiseEvent("svo gametarget changed", me.gametarget)
  end
  if oldgametargethp ~= me.gametargethp then
    raiseEvent("svo gametargethp changed", me.gametarget, me.gametargethp)
  end


  me.servertime = line:match("-s(%d+:%d+:%d+%.%d+)")
end

function onprompt()
  raiseEvent("svo before the prompt")
  sk.processing_prompt = true
  sk.systemscommands = {}

  promptcount = promptcount + 1

  checkblackout()
  check_promptflags()

  sys.lagcount = 0
  prompt_stats()
  calculatestatchanges()

  local s,m = pcall(signals.before_prompt_processing.emit, signals.before_prompt_processing)
  if not s then
    echoLink("(e!)", [[svo.echof("The problem was: stuff before the actual work failed (]]..tostring(m)..[[)")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end

  send_in_the_gnomes()

  if conf.showchanges and not conf.commandecho or (conf.commandecho and conf.commandechotype == 'fancynewline') then
    sk.showstatchanges()
  end

  local s,m = pcall(signals.after_prompt_processing.emit, signals.after_prompt_processing)
  if not s then
    debugf(m)
    echoLink("(e!)", string.format("svo.echof([[The problem was: stuff after the actual work failed (%q)]])", m), 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end

  if conf.showchanges and conf.commandecho and conf.commandechotype ~= 'fancynewline' then sk.showstatchanges() end
  if sys.deffing then defupfinish() end

  -- show system commands
  fancysendall()

  -- send off all batched commands
  sk.dosendqueue()

  local currentlinenumber = getLastLineNumber("main")
  lastpromptnumber = currentlinenumber
  -- record the time of the latest prompt we've seen - doing so is okay because we aren't using the current time, but retrieving the already calculated time from Mudlet
  -- using this, we can then find which was the most recent prompt line. Sometimes another line will share the time with the prompt, but the prompt will always be latest
  lastprompttime = getTimestamp(currentlinenumber)
  paragraph_length = 0
  sk.processing_prompt = false
  raiseEvent("svo done with prompt")
end

signals.after_prompt_processing:connect(function ()
  -- svo prompt pipeline - deals with the custom and singleprompts. This is done before onprompt()

  -- move the real prompt over for later use.
  moveCursorEnd()
  if selectString( getCurrentLine(), 1 ) ~= -1 then
    copy()
    moveCursorEnd("svo_prompt")
    paste("svo_prompt")
  end

  -- stats are updated in a pre-emit of before_prompt_processing; available to the customprompt here
  if affs.blackout or innews then return end

  -- replace w/ customprompt if necessary
  if conf.customprompt then
    selectString(line, 1)
    replace("")
  end

  -- prefix an orange '?:' if we don't know the exact stats
  if affs.recklessness or affs.blackout then
    local currentline = getLineCount()
    moveCursor("main", 0, currentline)
    deselect()
    setFgColor(255, 102, 0)
    insertText("?:")
    deselect(); resetFormat()
    moveCursorEnd()
  end

  if sys.sync then
    local currentline = getLineCount()
    deselect()
    moveCursor("main", 0, currentline)
    setFgColor(255, 0, 0)
    insertText("(")
    moveCursor("main", 1, currentline)

    -- you're overriding the system, green
    if sacid then
      setFgColor(0,255,0)
    -- system is doing something, red
    elseif sk.doingstuff_inslowmode() then
      setFgColor(255,0,0)
    -- system isn't doing anything and you aren't overriding, blue
    else
      setFgColor(0,0,255)
    end

    if sacid then
      insertLink("a", 'svo.echof[[You\'re currently overriding the system]]', 'You were overriding the system at this point', true)
    elseif sk.syncdebug then
      insertLink("a", 'svo.echof[['..sk.syncdebug..']]', 'Click to see actions we were considering doing at this point', true)
    else
      insertText("a")
    end

    moveCursor("main", 2, currentline)
    setFgColor(255, 0, 0)
    insertText(")")
    moveCursor("main", 3, currentline)
    setFgColor(0,0,0)
    insertText(" ")
    moveCursorEnd()
    resetFormat()
  end

  if conf.paused then
    moveCursor("main", 0, getLineCount())
    cinsertText("<a_red>(<a_darkgrey>p<a_red>)<black> ")
  end

  if conf.customprompt then
    cecho(cp.display() or "")
  end

  -- then do singleprompt business
  if conf.singleprompt then
    selectString(getCurrentLine(), 1)
    copy()
    clearWindow("bottomprompt")
    bottomprompt:paste()

    if conf.singlepromptblank then
      replace("")
    elseif not conf.singlepromptkeep then
      deleteLine()
    end

    deselect()
  end
end)

signals.gmcpcharname:connect(function()
  innews = nil
  sk.logged_in = true
end)

signals.gmcpcharstatus:connect(function()
  sys.charname = gmcp.Char.Status.name
  me.name = gmcp.Char.Status.name
end)

local old500num = 0
local old500p = false


function prio_makefirst(action, balance)
  assert(action and dict[action], "svo.prio_makefirst: " .. (action and action or "nil") .. " isn't a valid action.")

  local act = dict[action]

  -- find if it's only one available
  if not balance then
    local count = table.size(act)
    if act.aff then count = count - 1 end
    if act.waitingfor then count = count - 1 end

    assert(count == 1, "svo.prio_makefirst: " .. action .. " uses more than one balance, which one do you want to move?")
    local balance = false
    for k,j in pairs(act) do
      if k ~= "aff" and k ~= "waitingfor" then balance = k end
    end
  end

  assert(act[balance] and act[balance] ~= "aff" and act[balance] ~= "waitingfor", "svo.prio_makefirst: " .. action .. " doesn't use the " .. (balance and balance or "nil") .. " balance.")

  local beforestate = sk.getbeforestateprios()

  -- at this point, we both have the act and balance we want to move up.
  -- logic: move to 500, remember the original val. when we have to move back,
  -- we'll swap it to the original val.
  prio_undofirst()

  old500num = act[balance].spriority
  old500p = act[balance]
  act[balance].spriority = 500

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

function prio_undofirst()
  if not old500p then return end

  local beforestate = sk.getbeforestateprios()

  old500p.spriority = old500num
  old500p, old500num = false

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

function prio_slowswap(what, arg3, echoback, callback, ...)
  local sendf; if echoback then sendf = echof else sendf = errorf end
  local what, balance = what:match("(%w+)_(%w+)")
  local balance2
  if not tonumber(arg3) then
    assert(balance and balance2, "What balances do you want to use for swapping?", sendf)
    arg3, balance2 = arg3:match("(%w+)_(%w+)")
  end

  local beforestate = sk.getbeforestateprios()

  if tonumber(arg3) then -- swap to a #
    local name, balance2 = prio.getslowaction(tonumber(arg3))
    if not name then -- see if we have anyone in that # already
      dict[what][balance].spriority = arg3
      if echoback then
        echof("%s is now at %d.", what, arg3)
      end
    else -- if we do have someone at that #, swap them
      dict[what][balance].spriority, dict[name][balance2].spriority =
      dict[name][balance2].spriority, dict[what][balance].spriority
      if echoback then echof("%s is now > %s.", what, name) end
      if echoback then echof("<0,255,0>%s (%s) <255,255,255>> <0,255,0>%s (%s)", what, balance, name, balance2) end
    end
  else -- swap one action_balance with another action_balance
    if dict[what][balance].spriority < dict[arg3][balance2].spriority then
      dict[what][balance].spriority, dict[arg3][balance2].spriority =
      dict[arg3][balance2].spriority, dict[what][balance].spriority
      if echoback then echof("%s is now > %s.", what, arg3) end
      if echoback then echof("<0,255,0>%s (%s) <255,255,255>> <0,255,0>%s (%s)", arg3, balance2, what, balance) end
    elseif echoback then
      echof("%s is already > %s.", what, arg3)
    end
  end

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)

  if callback and type(callback) == "function" then callback(...) end
end

function prio_swap(what, balance, arg2, arg3, echoback, callback, ...)
  local sendf; if echoback then sendf = echof else sendf = errorf end
  assert(what and dict[what] and balance and dict[what][balance] and balance ~= "aff" and balance ~= "waitingfor", "what item and balance do you want to swap?", sendf)

  local function swaptwo(what, name, balance, ...)
    if dict[what][balance].aspriority < dict[name][balance].aspriority then
      dict[what][balance].aspriority, dict[name][balance].aspriority =
      dict[name][balance].aspriority, dict[what][balance].aspriority
      if echoback then echof("<0,255,0>%s <255,255,255>> <0,255,0>%s%s in %s balance", what, name, getDefaultColor(), balance) end
    elseif dict[what][balance].aspriority > dict[name][balance].aspriority then
      dict[what][balance].aspriority, dict[name][balance].aspriority =
      dict[name][balance].aspriority, dict[what][balance].aspriority
      if echoback then echof("<0,255,0>%s <255,255,255>> <0,255,0>%s%s in %s balance", name, what, getDefaultColor(), balance) end
    end

    if callback and type(callback) == "function" then callback(...) end
  end

  local beforestate = sk.getbeforestateprios()

  -- we want our 'what' to be at this arg2 number, swap what was there with its previous position
  if not arg3 then

    assert(tonumber(arg2), "what number do you want to swap " .. what .. " with?", sendf)
    local to_num = tonumber(arg2)
    local name = prio.getaction(to_num, balance)

    -- swapping two affs
    if name then
      swaptwo(what, name, balance, ...)

    -- or just setting one aff
    else
      dict[what][balance].aspriority = to_num
      if echoback then
        echof("%s is now at %d.", what, to_num)
      end
    end

    local afterstate = sk.getafterstateprios()
    sk.notifypriodiffs(beforestate, afterstate)

    return
  end

  -- we want to swap two affs
  assert(dict[arg2] and dict[arg2][arg3], "what balance of "..arg2.." do you want to swap with?", sendf)
  swaptwo(what, arg2, arg3, ...)

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

prompt_stats = function ()
  local s,m = pcall(function()
    if not (gmcp and gmcp.Char and gmcp.Char.Vitals) then
        if not conf.paused then
          conf.paused = true
          echo"\n" echof("Paused the system - please enable GMCP for it in Mudlet settings!") showprompt()
          raiseEvent("svo config changed", "paused")
        end
      return
    end

    local temp = {
      maxhealth = stats.maxhealth or 0,
      maxmana = stats.maxmana or 0,
    }

    local stats = stats
    local vitals = gmcp.Char.Vitals
    local sformat = string.format


    stats.currenthealth, stats.maxhealth,
    stats.currentmana, stats.maxmana,
    stats.currentendurance, stats.maxendurance,
    stats.currentwillpower, stats.maxwillpower
     =
        vitals.hp, vitals.maxhp,
        vitals.mp, vitals.maxmp,
        vitals.ep, vitals.maxep,
        vitals.wp, vitals.maxwp

    stats.nextlevel = gmcp.Char.Vitals.nl or 0
    stats.xprank = gmcp.Char.Status.xprank or 0

    stats.hp = sformat("%.1f", (100/stats.maxhealth)*stats.currenthealth)
    stats.mp = sformat("%.1f", (100/stats.maxmana)*stats.currentmana)
    stats.wp = sformat("%.1f", (100/stats.maxwillpower)*stats.currentwillpower)
    stats.ed = sformat("%.1f", (100/stats.maxendurance)*stats.currentendurance)

    for i,j in pairs(stats) do
      stats[i] = tonumber(j) or 0
    end

    if (stats.currentwillpower <= 1000 and not (stats.currenthealth == 0 and stats.currentmana == 0)) or sk.lowwillpower then
      sk.checkwillpower()
    end

    if (affs.blackout and not ((lifevision.l.touchtree_misc and lifevision.l.touchtree_misc.arg == "blackout") or lifevision.l.blackout_waitingfor)) or (affs.recklessness and not actions.recklessness_focus and not actions.recklessness_herb) then
      local assumestats = conf.assumestats/100
      stats.currenthealth, stats.currentmana =
        math.floor(stats.maxhealth * assumestats), math.floor(stats.maxmana * assumestats)
    end

    -- see what max values changed, update other info accordingly
    if temp.maxhealth ~= stats.maxhealth then
      signals.changed_maxhealth:emit(temp.maxhealth, stats.maxhealth)
    end
    if temp.maxmana ~= stats.maxmana then
      signals.changed_maxmana:emit(temp.maxmana, stats.maxmana)
    end
  end)

  if not s then
    echoLink("(e!)", [[echo("The problem was: prompt vitals function failed - (]]..tostring(m)..[[). Maybe the system isn't installed yet?")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end
end


function QQ()
  signals.quit:emit()
end

savesettings = QQ

-- add in blackout only, otherwise go off the prompt - this allows for time tracking
function goteq()
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end

  if sys.misseddisrupt then killTimer(sys.misseddisrupt); sys.misseddisrupt = nil end
  sys.extended_eq = nil

  if affs.blackout and not bals.equilibrium then bals.equilibrium = true; raiseEvent("svo got balance", "equilibrium") end
end

function gotbalance()
  if affs.blackout then bals.balance = true end
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end

  -- FIXME
  if affs.blackout and not bals.balance then bals.balance = true; raiseEvent("svo got balance", "balance") end
end

function gotarmbalance()
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end
end

signals["svo lost balance"]:connect(function(balance)
  if balance ~= "equilibrium" or not conf.noeqtimeout or conf.noeqtimeout == 0 or conf.serverside then return end

  if sys.misseddisrupt then killTimer(sys.misseddisrupt) end
  sys.misseddisrupt = tempTimer(conf.noeqtimeout, function()
    if not bals.equilibrium and not sys.extended_eq and not innews and not affs.disrupt then
      addaff(dict.disrupt)
      if not me.passive_eqloss then
        echof("didn't get eq back in %ss - assuming disrupt", tostring(conf.noeqtimeout))
      else
        echof("didn't get eq back in %ss - assuming disrupt and confusion", tostring(conf.noeqtimeout))
        addaff(dict.confusion)
      end

      make_gnomes_work()
    end
  end)
end)


-- set a flag that we shouldn't assume disrupt on long-eq actions
function extended_eq()
  sys.extended_eq = true
end

function cnrl.update_siphealth()
  if conf.siphealth then sys.siphealth                   = math.floor(stats.maxhealth * (conf.siphealth/100)) end
  if conf.mosshealth then sys.mosshealth                 = math.floor(stats.maxhealth * (conf.mosshealth/100)) end
  if conf.transmuteamount then sys.transmuteamount       = math.floor(stats.maxhealth * (conf.transmuteamount/100)) end
  if conf.corruptedhealthmin then sys.corruptedhealthmin = math.floor(stats.maxhealth * (conf.corruptedhealthmin/100)) end
end
signals.changed_maxhealth:connect(cnrl.update_siphealth)

function cnrl.update_sipmana()
  if conf.sipmana then sys.sipmana = math.floor(stats.maxmana * (conf.sipmana/100)) end
  if conf.mossmana then sys.mossmana = math.floor(stats.maxmana * (conf.mossmana/100)) end

  sys.manause = math.floor(stats.maxmana * (conf.manause/100))
end
signals.changed_maxmana:connect(cnrl.update_sipmana)


function cnrl.update_wait()
  sys.wait = wait_tbl[conf.lag].n
end

can_usemana = function()
  return stats.currentmana > sys.manause and
    not doingaction ("nomana") -- pseudo-tracking for blackout and recklessness
    and (stats.wp or 0) > 1
end


cnrl.warnids = {}

-- tbl: {initialmsg = "", prefixwarning = "", startin = 0, duration = 0}
function givewarning(tbl)
  checkaction(dict.givewarning.happened, true)

  if conf.aillusion then
    lifevision.add(actions.givewarning_happened.p, nil, tbl, 1)
  else
    lifevision.add(actions.givewarning_happened.p, nil, tbl)
  end
end
function givewarning_multi(tbl)
  checkaction(dict.givewarning.happened, true)
  lifevision.add(actions.givewarning_happened.p, nil, tbl)
end

prefixwarning = function ()
  local deselect, echo, setFgColor = deselect, echo, setFgColor

  if conf.warningtype == "right" then
    local currentline = getCurrentLine()
    deselect()
    echo(string.rep(" ", conf.screenwidth - #currentline - #cnrl.warning-3))
    setFgColor(0, 050, 200)
    echo("(")
    setFgColor(128, 128, 128)
    echo(cnrl.warning)
    setFgColor(0, 050, 200)
    echo(")")
    moveCursorEnd()
    resetFormat()
  else
    local currentline = getLineCount()
    deselect()
    moveCursor("main", 0, currentline)
    setFgColor(0, 050, 200)
    insertText("(")
    moveCursor("main", 1, currentline)
    setFgColor(128, 128, 128)
    insertText(cnrl.warning)
    moveCursor("main", 1+#cnrl.warning, currentline)
    setFgColor(0, 050, 200)
    insertText(")")
    moveCursor("main", 2+#cnrl.warning, currentline)
    setFgColor(0,0,0)
    insertText(" ")
    moveCursorEnd()
    resetFormat()
  end
end

cnrl.lockdata = {
  ["soft"] = function () return (affs.slickness and affs.anorexia and affs.asthma) end,
  ["venom"] = function () return (affs.slickness and affs.anorexia and affs.asthma and affs.paralysis) end,
  ["hard"] = function () return (affs.slickness and affs.anorexia and affs.asthma and (affs.impatience or (not svo.can_usemana() or not svo.conf.focus))) end,
  ["dragon"] = function () return (defc.dragonform and affs.slickness and affs.anorexia and affs.asthma and (affs.impatience or (not svo.can_usemana() or not svo.conf.focus)) and affs.recklessness and affs.weakness) end,
  ["stain"] = function() return (affs.stain and affs.slickness and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm)) and pipes.valerian.puffs == 0) end,
  ["rift"] = function() return ((affs.asthma and (rift.invcontents.kelp == 0 and rift.invcontents.aurum == 0)) and affs.slickness and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))) end,
  ["rift 2"] = function() return (affs.asthma and affs.slickness and affs.anorexia and (affs.paralysis or (affs.disrupt and not bals.equilibrium)) and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))) end,
  ["slow"] = function () return (affs.asthma and affs.slickness and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm)) and (affs.mildconcussion or affs.seriousconcussion) and affs.aeon) end,
  ["true"] = function () return (affs.slickness and affs.anorexia and affs.asthma and affs.paralysis and affs.impatience and affs.disrupt and affs.confusion) end
}

--[[ cnrl.checkwarning gets unblocked whenever we receive an aff that is
      included in any of the locks. If you have a lock, it enables the
      cnrl.checkgreen flag, and unblocks dowarning, which allows powercure
      to run and do it's thing. Post processing, cnrl.dolockwarning is run,
      notifying the user on the prompt of any locks (and if any of them
      are in the process of being cured, highlight the lock name in green).

      When we don't have a lock, checkwarning disables itself, the flag,
      and dowarning]]

cnrl.warnings = {}
cnrl.checkwarning = function ()
  cnrl.warnings = {}
  me.locks = {}
  local t = cnrl.warnings
  for lock, func in pairs(cnrl.lockdata) do
    if func() then t[#t+1] = lock; me.locks[lock] = true end
  end

  if not cnrl.checkgreen and #t > 0 then
    signals.after_prompt_processing:unblock(cnrl.dolockwarning)
    cnrl.checkgreen = true
  elseif cnrl.checkgreen and #t == 0 then
    cnrl.checkgreen = false
    signals.after_lifevision_processing:block(cnrl.checkwarning)
    signals.after_prompt_processing:block(cnrl.dolockwarning)
  end
end
signals.after_lifevision_processing:connect(cnrl.checkwarning)
signals.after_lifevision_processing:block(cnrl.checkwarning)

cnrl.dolockwarning = function ()
  local t = cnrl.warnings
  if #t == 1 then
    cecho("<red>(<grey>lock: <orange>" .. t[1].."<red>)")
  elseif #t > 1 then
    cecho("<red>(<grey>locks: <orange>" .. concatand(t).."<red>)")
  else
    -- no more warnings? stop checking for them. Failsafe, we should never get here normally.
    cnrl.checkgreen = false
    signals.after_lifevision_processing:block(cnrl.checkwarning)
    signals.after_prompt_processing:block(cnrl.dolockwarning)
  end
end
signals.after_prompt_processing:connect(cnrl.dolockwarning)
signals.after_prompt_processing:block(cnrl.dolockwarning)

function cnrl.processcommand(what)
  if not sys.sync or conf.send_bypass then return end

  if conf.blockcommands
  -- and the system is doing something right now...
  and sk.doingstuff_inslowmode()
  -- and this command right here is from you, not the system. Ignore commands starting with 'curing'
  -- though, as those are for serverside and aren't affected
  and not sk.gnomes_are_working and not what:lower():find("^curing") then
    denyCurrentSend()
    if math.random(1,5) == 1 then
      echof("denying <79,92,88>%s%s. Lemme finish!", what, getDefaultColor())
    elseif math.random(1,10) == 1 then
      echof("denying <79,92,88>%s%s. Use tsc to toggle deny mode.", what, getDefaultColor())
    else
      echof("denying <79,92,88>%s%s.", what, getDefaultColor()) end
    return
  elseif not conf.blockcommands and not sk.gnomes_are_working then -- override mode, command from you, not the system

    -- kill old timer first
    if not sacid then echof("pausing curing for your commands.") end

    if sacid then killTimer(sacid) end
    sacid = tempTimer(syncdelay() + getNetworkLatency() + conf.sacdelay, function ()
      sacid = false
      if sys.sync then echof("resuming curing.") end
      make_gnomes_work()
    end)
  end

  -- retardation detection: works by setting a timer off a command, if the timer isn't already set
  -- then when the sluggish msg is seen, the timer is cleared.
  -- amnesia screws with it by hiding the sluggish msg itself!
  if not sk.sluggishtimer and not affs.amnesia and what ~= "" and not what:lower():find("^curing") then
    sk.sawsluggish = getLastLineNumber("main")
    local time = sys.wait + syncdelay() + getNetworkLatency()
    sk.sluggishtimer = tempTimer(time, function ()
      if type(sk.sawsluggish) == "number" and sk.sawsluggish ~= getLastLineNumber("main") and (affs.retardation or affsp.retardation) then
        if affs.retardation then echo"\n" echof("Retardation seems to have went away.") end
        removeaff("retardation")
      end

      sk.sluggishtimer = nil
    end)
  end
end

signals.sysdatasendrequest:connect(cnrl.processcommand)
signals.sysdatasendrequest:block(cnrl.processcommand)

-- parse things for acceptance. ideas to prevent looping: either debug.traceback() (very slow it turned out), or block/unblock handler when doing sys actions (solution used)
function cnrl.processusercommand(what, now)
  -- remove spaces, as some people may use spaces, ie "bedevil " instead of just "bedevil" which then confuses tracking
  what = what:trim()

  -- if this is a system command done outside of a cnrl.processusercommand block because of batching, catch it
  if sk.systemscommands[what] then debugf("igboring %s, it's actually a system command", what) return end

  -- debugf("sys.input_to_actions: %s", pl.pretty.write(pl.tablex.keys(sys.input_to_actions)))
  -- debugf("sk.systemscommands: %s", pl.pretty.write(sk.systemscommands))

  if not innews and (what == "qq" or what == "quit") then
    QQ()
    echof("Going into empty defs mode so pre-cache doesn't take anything out, and stuffing away all riftables...")
    defs.switch("empty")
    inra()
  elseif not innews and (what == "ir" or what == "info rift") then
    me.parsingrift = "all"
  elseif not innews and (what == "ir herb" or what == "ir plant") then -- missing info rift variants
    me.parsingrift = "herbs"
  elseif not innews and (what == "ir mineral") then
    me.parsingrift = "minerals"

  elseif sys.input_to_actions[what] then
    local function dostuff()
      killaction(sys.input_to_actions[what])
      local oldsend, oldsendc, oldsendAll = send, sendc, sendAll
      send = function() end
      sendc = function() end
      sendAll = function() end
      local s,m = pcall(doaction, sys.input_to_actions[what])
      if not s then
        echoLink("(e!)", [[svo.echof("The problem was: re-mapping commands to system actions failed: (]]..tostring(m)..[[)")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
      end
      send = oldsend
      sendc = oldsendc
      sendAll = oldsendAll
    end

    -- when 'now' is given, put it into queue right away - this is useful for capturing the game curing command
    if now then dostuff() else tempTimer(0, dostuff) end
  end
end
signals.sysdatasendrequest:connect(cnrl.processusercommand)

-- limited_around: don't show the full list, but only 13 elements around the center one
function printorder(balance, limited_around)
  -- translate the obvious 'balance' to 'physical'
  if balance == "balance" then balance = "physical" end
  local sendf; if echoback then sendf = echof else sendf = errorf end
  assert(type(balance) == "string", "svo.printorder: what balance do you want to print for?", sendf)

  -- get into table...
  local data = make_prio_table(balance)
  local orderly = {}

  -- get a sorted list of just the prios
  for i,j in pairs(data) do
    orderly[#orderly+1] = i
  end

  table.sort(orderly, function(a,b) return a>b end)

  -- locate where the center of the list is, if we need it
  local center
  if limited_around then
    local counter = 1
    for _, j in pairs(orderly) do
      if j == limited_around then center = counter break end
      counter = counter +1
    end
  end

  echof("%s balance priority list (<112,112,112>clear gaps%s):", balance:title(), getDefaultColor())
  if selectString("clear gaps", 1) ~= -1 then
    setLink("svo.prio.cleargaps('"..balance.."', true)", "Clear all gaps in the "..balance.." balance")
  end

  if not limited_around then
    echof("Stuff at the top will be cured first, if it's possible to cure it.")
  end

  local list = prio.getsortedlist(balance)
  local affs, defs = sk.splitdefs(balance, list)
  local raffs, rdefs = {}, {}
  for i = 1, #affs do raffs[affs[i]] = i end
  for i = 1, #defs do rdefs[defs[i]] = i end

  if limited_around then
    echofn("(")
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("...", "svo.printorder('"..balance.."')", "Click to view the full "..balance.." priority list", true)
    setUnderline(false)
    echo(")\n")
  end

  local function echoserver(j, raffs, rdefs, balance, ssprioamount)
    if raffs[data[j]] then
      return string.format("ss aff %"..ssprioamount.."s", (raffs[data[j]] <= 25 and raffs[data[j]] or "25"))
    elseif rdefs[data[j]] then
      return string.format("ss def %"..ssprioamount.."s", (rdefs[data[j]] <= 25 and rdefs[data[j]] or "25"))
    elseif dict[data[j]][balance].def then
      return "ss def"..(' '):rep(ssprioamount).."-"
    elseif dict[data[j]][balance].aff then
      return "ss aff"..(' '):rep(ssprioamount).."-"
    else
      return "ss    "..(' '):rep(ssprioamount).."-"
    end
  end

  local counter = 1
  local intlen = intlen
  local prioamount = intlen(table.size(orderly))
  local ssprioamount = intlen(table.size(raffs) and table.size(raffs) or table.size(rdefs))
  for i,j in pairs(orderly) do
    if not limited_around or not (counter > (center+6) or counter < (center-6)) then
      setFgColor(255,147,107) echo"  "
      echoLink("^^", 'svo.prio_swap("'..data[j]..'", "'..balance..'", '..(j+1)..', nil, false, svo.printorder, "'..balance..'", '..(j+1)..')', 'shuffle '..data[j]..' up', true)
      echo(" ")
      setFgColor(148,148,255)
      echoLink("vv", 'svo.prio_swap("'..data[j]..'", "'..balance..'", '..(j-1)..', nil, false, svo.printorder, "'..balance..'", '..(j-1)..')', 'shuffle '..data[j]..' down', true)
      setFgColor(112,112,112)
      -- focus balance can't have 'priority'
      if not conf.serverside or balance == "focus" then
        echo(string.format(" (%s) "..(' '):rep(prioamount - intlen(j)).."%s", j, data[j]))
      else
        -- defs not on defup/keepup won't have a priority
        echo(string.format(" (svo %"..prioamount.."s|%s) %s", j, echoserver(j, raffs, rdefs, balance, ssprioamount), data[j]))
      end
      echo("\n")
      resetFormat()
    end

    counter = counter + 1
  end

  showprompt()
end

function printordersync(limited_around)
  -- step 1: get into table...
  local data = make_sync_prio_table("%s (%s)")
  local orderly = {}

  for i,j in pairs(data) do
    orderly[#orderly+1] = i
  end

  table.sort(orderly, function(a,b) return a>b end)

  echof("aeon/retardation priority list (clear gaps):", balance)
  if selectString("clear gaps", 1) ~= -1 then
    setFgColor(112,112,112)
    setLink("svo.prio.cleargaps('slowcuring', true)", "Clear all gaps in the aeon/retardation priority")
    resetFormat()
  end

  -- locate where the center of the list is, if we need it
  local center
  if limited_around then
    local counter = 1
    for _, j in pairs(orderly) do
      if j == limited_around then center = counter break end
      counter = counter +1
    end
  end

  if not limited_around then
    echof("Stuff at the top will be cured first, if it's possible to cure it.")
  end

  if limited_around then
    echofn("(")
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("...", "svo.printordersync()", "Click to view the full aeon/retardation priority list", true)
    setUnderline(false)
    echo(")\n")
  end

  local counter = 1
  for i,j in pairs(orderly) do
    if not limited_around or not (counter > (center+6) or counter < (center-6)) then
      setFgColor(255,147,107) echo"  "
      echoLink("^^", 'svo.prio_slowswap("'..string.format("%s_%s", string.match(data[j], "(%w+) %((%w+)%)"))..'", '..(j+1)..', false, svo.printordersync, '..(j+1)..')', 'shuffle '..data[j]..' up', true)
      echo(" ")
      setFgColor(148,148,255)
      echoLink("vv", 'svo.prio_slowswap("'..string.format("%s_%s", string.match(data[j], "(%w+) %((%w+)%)"))..'", '..(j-1)..', false, svo.printordersync, '..(j-1)..')', 'shuffle '..data[j]..' up', true)
      setFgColor(112,112,112)
      echo(" (" .. j..") "..data[j])
      echo("\n")
      resetFormat()
    end

    counter = counter + 1
  end

  showprompt()
end


signals.systemstart:connect(function()
  _G.svo.removeaff = function (which)
    assert(type(which) == "string", "svo.removeaff: what aff would you like to remove? name must be a string")
    assert(dict[which] and dict[which].aff, "svo.removeaff: "..which.." isn't a known aff name")

    local removed = false
    if lifevision.l[which.."_aff"] then
      lifevision.l:set(which.."_aff", nil)
      removed = true
    end

    if affs[which] then
      if dict[which].gone then
        dict[which].gone.oncompleted()
      else
        removeaff(which)
      end

      removed = true
    end

    signals.after_lifevision_processing:unblock(cnrl.checkwarning)
    sk.checkaeony()
    signals.aeony:emit()

    return removed
  end

  _G.svo.removeafflevel = function (which, amount, keep)
    assert(type(which) == "string", "svo.removeafflevel: what aff would you like to remove? name must be a string")
    assert(dict[which] and dict[which].aff, "svo.removeafflevel: "..which.." isn't a known aff name")

    local removed = false
    if lifevision.l[which.."_aff"] then
      lifevision.l:set(which.."_aff", nil)
      removed = true
    end

    if affs[which] then
      if dict[which].gone then
        dict[which].gone.general_cure(amount or 1, not keep)
      else
        removeaff(which)
      end

      removed = true
    end

    signals.after_lifevision_processing:unblock(cnrl.checkwarning)
    sk.checkaeony()
    signals.aeony:emit()

    return removed
  end

  _G.svo.addaff = function (which)
    assert(type(which) == "string", "svo.addaff: what aff would you like to add? name must be a string")
    assert(dict[which] and dict[which].aff, "svo.addaff: "..which.." isn't a known aff name")

    if affs[which] then
      return false
    else
      if dict[which].aff and dict[which].aff.forced then
        dict[which].aff.forced()
      elseif dict[which].aff then
        dict[which].aff.oncompleted()
      else
        addaff(dict[which])
      end

      signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      sk.checkaeony()
      signals.aeony:emit()
      codepaste.badaeon()

      return true
    end
  end
end)

function sk.check_fullstats()
  if stats.currenthealth >= stats.maxhealth and stats.currentmana >= stats.maxmana and not affs.recklessness then
    sk.gettingfullstats = false
    signals.after_prompt_processing:disconnect(sk.check_fullstats)
    tempTimer(0, function() echof("We're fully healed up now.") showprompt() end)
    raiseEvent("svo got fullstats")

    if sk.fullstatsunignorehp then
      sk.fullstatsunignorehp = nil
      serverignore.healhealth = true
    end

    if sk.fullstatsunignoremp then
      sk.fullstatsunignoremp = nil
      serverignore.healmana = true
    end

    if type(sk.fullstatscallback) == "function" then
      local s,m = pcall(sk.fullstatscallback)
      if not s then echof("Your fullstats function had a problem:\n  %s", m) end
    elseif type(sk.fullstatscallback) == "string" then
      local s,m = pcall(loadstring(sk.fullstatscallback))
      if not s then echof("Your fullstats code had a problem:\n  %s", m) end
    end
    sk.fullstatscallback = nil
  end
end


function fullstats(newstatus, callback, echoback)
  if newstatus then
    if stats.currenthealth >= stats.maxhealth and stats.currentmana >= stats.maxmana then
      if echoback then echof("We're already completely healthy.") end
      raiseEvent("svo got fullstats")

      if newstatus and type(callback) == "function" then
        local s,m = pcall(callback)
        if not s then echof("Your fullstats function had a problem:\n  %s", m) end
      elseif newstatus and type(callback) == "string" then
        local s,m = pcall(loadstring(callback))
        if not s then echof("Your fullstats code had a problem:\n  %s", m) end
      end
      return
    else

      sk.gettingfullstats = true

      -- if serverside is on, take healhealth off ignore (if it's there) and let it sip up
      if conf.serverside then
        if serverignore.healhealth then
          sk.fullstatsunignorehp = true
          serverignore.healhealth = nil
        end

        if serverignore.healmana then
          sk.fullstatsunignoremp = true
          serverignore.healmana = nil
        end
      end

      signals.after_prompt_processing:connect(sk.check_fullstats)
      sk.fullstatscallback = callback
      if echoback then echof("Healing up to full stats.") end
      raiseEvent("svo started fullstats")
      make_gnomes_work()
    end
  elseif not newstatus then
    sk.gettingfullstats = false
    signals.after_prompt_processing:disconnect(sk.check_fullstats)
    if echoback then echof("Resumed normal health/mana healing.") end
    raiseEvent("svo stopped fullstats")
  end
end

prompttrigger = function (name, func)
  assert(name, "svo.prompttrigger: the name needs to be provided")
  assert(type(func) == "function" or type(func) == "nil", "svo.prompttrigger: the second argument needs to be a Lua function or nil")

  sk.onprompt_beforeaction_add(name, func)
end

aiprompt = function (name, func)
  sk.onprompt_beforelifevision_add(name, func)
end

function lyre_step()
  if not (bals.balance and bals.equilibrium) then echof("Don't have balance+eq.") return end

  if not conf.lyre then config.set("lyre", "on", true) end

  if sys.sync then sk.gnomes_are_working = true end
  conf.paused = false
  raiseEvent("svo config changed", "paused")

  conf.lyre_step = true
  make_gnomes_work()

  if not actions.lyre_physical then
    doaction(dict.lyre.physical)
  end
  conf.lyre_step = false

  if sys.sync then sk.gnomes_are_working = false end
end

-- register doaction after system load, so doaction internally is defined by then
signals.systemstart:connect(function()
  _G.svo.doaction = function(which, balance)
    assert(dict[which], "svo.doaction: "..which.." action doesn't exist. See 'vshow ignorelist' for a list of them.")
    assert(dict[which][balance], "svo.doaction: "..which.." doesn't have a "..balance.. " balance.")

    doaction(dict[which][balance])
  end
end)

-- capture the incoming values for gmcp balance and eq
signals.gmcpcharvitals:connect(function()
  newbals.balance     = gmcp.Char.Vitals.bal == "1" and true or false
  newbals.equilibrium = gmcp.Char.Vitals.eq == "1" and true or false
end)

-- feed the curing systems curing command through the system, so it can track actions
-- don't raise a systadasendrequest because that would trigger command deny/override
function curingcommand(command)
  sk.sawcuringcommand = true
  cnrl.processusercommand(command:lower(), true)
  prompttrigger("clear curing command", function() sk.sawcuringcommand = false end)

  if conf.gagservercuring then deleteLine() end
end

-- same as curingcommand, but for actions via queue
function queuecommand(command)
  sk.sawqueueingcommand = true
  cnrl.processusercommand(command:lower(), true)

  prompttrigger("clear queueing command", function() sk.sawqueueingcommand = false end)
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

-- action system
actions = pl.OrderedMap()

 -- a map of balances, with a map of actions in each
actions_performed = actions_performed or {}
bals_in_use       = bals_in_use or {}

-- ie:
-- doaction(dict.healhealth.sip)
doaction = function(act)
  assert(act, "svo.doaction requires an argument")
  --it'll be in format of dict.what.#somebalance
  -- add to a table, create timers and store id's in there
  -- if ai is on, enable the relevant triggers <- maybe we should do
  -- it in dict action.

  local expirein =
    affs.seriousconcussion and sys.sync
    and (syncdelay()+.3) -- w/ aeon, waits 1.3s and etc, w/o aeon - 0.3s and etc..
    or ((act.customwait or (act.customwaitf and act.customwaitf()) or 0) + sys.wait) + syncdelay()


  local timerid = tempTimer(expirein,
    function ()
      actions:set(act.name, nil)  -- remove from actions list

      if bals_in_use[act.balance] then -- it should always be there, even after reset - but a failsafe is in place anyway
        bals_in_use[act.balance][act.name] = nil
      end
      actions_performed[act.action_name] = nil

      -- there might be a case where actions_performed was being taken up by another action, like a cure, that was overwritten by an aff now. This needs to be rectified back.
      for bal, _ in pairs(bals_in_use) do
        if actions[act.action_name.."_"..bal] then
          actions_performed[act.action_name] = bals_in_use[bal][act.action_name.."_"..bal]

        end
      end

      -- don't need to pause the system itself as all actions timing out will come to this, ie build up, get disabled until next prompt
      sys.lagcount = sys.lagcount + 1
      if sys.lagcount < (sys.lagcountmax+1) then
        if act.ontimeout then act.ontimeout() end

        -- if we have a stupidity counted and we timed out, then stupidity might be real
        if sk.stupidity_count and sk.stupidity_count > 0 and not affs.stupidity then
          addaff(dict.stupidity)
          echof("I suspect we've got stupidity.")
        end

        make_gnomes_work()
      elseif sys.lagcount == (sys.lagcountmax+1) and not conf.paused then
        echof("Warning, lag detected (while doing/curing %s)", act.action_name)
        sk.increase_lagconf()
      end
    end
  )

  -- act.name is a single string of action + balance - ie, bleeding_misc (cure) or bleeding_aff (affliction)
  actions:set(act.name, {
    timerid = timerid,
    completed = function (other_action, arg)
      killTimer(timerid)
      act[other_action or "oncompleted"](arg)

      if act.balance == "focus" then signals.curedwith_focus:emit(other_action or "oncompleted") end
    end,
    p = act
  })


  bals_in_use[act.balance] = bals_in_use[act.balance] or {}
  bals_in_use[act.balance][act.name] = act
  -- ie, bleeding
  actions_performed[act.action_name] = act

  -- lastly, do it! :)

  local s,m = pcall(act.onstart)
  if not s then
    echoLink("(e!)", [[echo("The problem was: ]]..tostring(act.action_name)..[[ failed to start (]]..tostring(m)..[[). If this is curing-related, please include that your curemethod is set to ]]..tostring(conf.curemethod)..[[")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  else
    -- action started successfully - start the stopwatch for it. It's accessible via actions.action_balance.p.actionwatch
    act.actionwatch = act.actionwatch or createStopWatch()
    startStopWatch(act.actionwatch)
  end

end

-- if input is true, then add to the queue regardless
-- otherwise if it's output from us, only add if we got anti-illusion
--   off.
-- input determines if we should force insert
checkaction = function (act, input)
  -- if doesnt exist in table, and we got ai off, make one up
  if not actions[act.name] and ((not conf.aillusion and input ~= false) or input) then


    actions:set(act.name, {
      completed = function (other_action, arg)
        act[other_action or "oncompleted"](arg)
        if act.balance == "focus" then signals.curedwith_focus:emit(other_action or "oncompleted") end
      end,
      p = act,
    })

    bals_in_use[act.balance] = bals_in_use[act.balance] or {}
    bals_in_use[act.balance][act.name] = act
    actions_performed[act.action_name] = act
  end
end

-- checks if any of the actions are being done, returns one if true;
-- does not create new ever
checkany = function (...)
  local t = {...}

  for i=1,#t do
    local j = t[i]
    if actions[j.name] then
      return j
    end
  end
end

findbybal = function (balance)
  return bals_in_use[balance] and select(2, next(bals_in_use[balance]))
end

-- checks if any of the physical actions being done right now are expected to consume balance
will_take_balance = function()
  bals_in_use.physical = bals_in_use.physical or {}
  for action, data in pairs(bals_in_use.physical) do
    if data.balanceful_act then return true end
  end
end

codepaste.balanceful_codepaste = will_take_balance

findbybals = function(balances)
  local t = {}

  for _, bal in ipairs(balances) do
    if bals_in_use[bal] then
      for _, act in pairs(bals_in_use[bal]) do
        t[act.name] = act
      end
    end
  end

  if next(t) then return t end
end

-- for illusions/actions that need to be cancelled
actionclear = function(act)

  actions:set(act.name, nil)
  if bals_in_use[act.balance] then -- it should always be there, even after reset - but a failsafe is in place anyway
    bals_in_use[act.balance][act.name] = nil
  end
  actions_performed[act.action_name] = nil

  -- there might be a case where actions_performed was being taken up by another action, like a cure, that was overwritten by an aff now. This needs to be rectified back.
  for bal, _ in pairs(bals_in_use) do
    if actions[act.action_name.."_"..bal] then
      actions_performed[act.action_name] = bals_in_use[bal][act.action_name.."_"..bal]

    end
  end

  if act.oncancel then
    local s,m = pcall(act.oncancel)
    if not s then
      echoLink("(e!)", [[echo("The problem was: ]]..tostring(act.action_name)..[[ failed to cancel (]]..tostring(m)..[[). If this is curing-related, please include that your curemethod is set to ]]..tostring(conf.curemethod)..[[")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
    end
  end
end

actionfinished = function(act, other_action, arg)
  assert(act, "svo.actionfinished wants an argument")
  if not act.name or not actions[act.name] or not actions[act.name].completed then echo("(e!)")

    return
  end


  local result, msg = pcall(actions[act.name].completed, other_action, arg)

  if not result then
    echoLink("(e!)", [[svo.echof("The problem was: ]]..tostring(act.action_name)..[[ failed to complete: ]]..msg..[[")]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end

  actions:set(act.name, nil)
  if bals_in_use[act.balance] then -- it should always be there, even after reset - but a failsafe is in place anyway
    bals_in_use[act.balance][act.name] = nil
  end
  actions_performed[act.action_name] = nil


  -- there might be a case where actions_performed was being taken up by another action, like a cure, that was overwritten by an aff now. This needs to be rectified back.
  for bal, _ in pairs(bals_in_use) do
    if actions[act.action_name.."_"..bal] then
      actions_performed[act.action_name] = bals_in_use[bal][act.action_name.."_"..bal]

    end
  end

  -- slow curing? kick the next action into going then
  if sys.sync then tempTimer(0, function() make_gnomes_work() end) end
end

-- needs the dict+balance, ie: killaction (dict.icing.waitingfor)
killaction = function (act)

  assert(act, "svo.killaction wants an argument")

  if not actions[act.name] then return end

  if act.onkill then act.onkill() end

  if actions[act.name].timerid then
    killTimer(actions[act.name].timerid)
  end
  actions:set(act.name, nil)

  if bals_in_use[act.balance] then -- it should always be there, even after reset - but a failsafe is in place anyway
    bals_in_use[act.balance][act.name] = nil
  end
  actions_performed[act.action_name] = nil


  -- there might be a case where actions_performed was being taken up by another action, like a cure, that was overwritten by an aff now. This needs to be rectified back.
  for bal, _ in pairs(bals_in_use) do
    if actions[act.action_name.."_"..bal] then
      actions_performed[act.action_name] = bals_in_use[bal][act.action_name.."_"..bal]

    end
  end

  if lifevision.l[act.name] then
    lifevision.l:set(act.name, nil)
  end

  -- slow curing? kick the next action into going then
  if sys.sync then tempTimer(0, function() make_gnomes_work() end) end
end

usingbal = function (which)
  return (bals_in_use[which] and next(bals_in_use[which])) and true or false
end

-- public function
usingbalance = usingbal

-- slight problem with this - it uses the short name, without the balance/action - so some misc things such as sleep, which can happen at once, are a problem. workaround is to combine doingaction with usingbal in there.
doingaction = function (which)
  assert(which, "svo.doingaction wants an argument")

  return actions_performed[which] and true or false
end

-- public function
-- fixme: allow for action_balance
doing = doingaction

-- String -> Action/Aff/Nil
-- returns true if we currently have or will register (after this prompt and no illusions) an affliction
haveorwill = function (aff)
  return actions[aff.."_aff"] or affs[aff]
end

-- string -> boolean
-- returns true if the given string in the format of actionname_balance exists
valid_sync_action = function(name)
  local actionname, balance = name:match("^(%w+)_(%w+)$")
  if not (actionname and balance) then return false, "actionname is in invalid format; it should be as 'actionname_balance'" end

  if not dict[actionname] then return false, "action "..actionname.." doesn't exist" end
  if not dict[actionname][balance] then return false, actionname.." doesn't operate on the "..balance.." balance" end

  return true, actionname, balance
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

pl.dir.makepath(getMudletHomeDir() .. "/svo/pipes")

me.pipes = me.pipes or {}

pipes.valerian = pipes.valerian or
  {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = "valerian", filledwith2 = "valerian", maxpuffs = 10, maxpuffs2 = 10}
me.pipes.valerian = pipes.valerian

pipes.elm = pipes.elm or
{lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = "elm", filledwith2 = "elm", maxpuffs = 10, maxpuffs2 = 10}
me.pipes.elm = pipes.elm

pipes.skullcap = pipes.skullcap or
{lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = "skullcap", filledwith2 = "skullcap", maxpuffs = 10, maxpuffs2 = 10}
me.pipes.skullcap = pipes.skullcap

pipes.pnames = {"valerian", "skullcap", "elm"}

pipes.expectations = {"valerian", "skullcap", "elm"}

pipes.empties = {}

function lastlit (which)
  for i = 1, #pipes.expectations do
    local v = pipes.expectations[i]
    if v == which then
      table.remove(pipes.expectations, i)
      pipes.expectations[#pipes.expectations+1] = which
      return
    end
  end
end

function pipeout()
  local what = pipes.expectations[1]
  pipes[what].lit = false
  table.remove(pipes.expectations, 1)
  pipes.expectations[#pipes.expectations+1] = what
end

function pipestart()
  local oldvalerianmaxpuffs, oldelmmaxpuffs, oldskullcapmaxpuffs = pipes.valerian.maxpuffs, pipes.elm.maxpuffs, pipes.skullcap.maxpuffs
  local oldvalerianmaxpuffs2, oldelmmaxpuffs2, oldskullcapmaxpuffs2 = pipes.valerian.maxpuffs2, pipes.elm.maxpuffs2, pipes.skullcap.maxpuffs2

  pipes.valerian = {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = "valerian", filledwith2 = "valerian", maxpuffs = oldvalerianmaxpuffs, maxpuffs2 = oldvalerianmaxpuffs2}
  me.pipes.valerian = pipes.valerian

  pipes.elm = {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = "elm", filledwith2 = "elm", maxpuffs = oldelmmaxpuffs, maxpuffs2 = oldelmmaxpuffs2}
  me.pipes.elm = pipes.elm

  pipes.skullcap = {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = "skullcap", filledwith2 = "skullcap", maxpuffs = oldskullcapmaxpuffs, maxpuffs2 = oldskullcapmaxpuffs2}
  me.pipes.skullcap = pipes.skullcap
end

function parseplist()
  local pipenames = {
    ["slippery elm"]                = "elm",
    ["a valerian leaf"]             = "valerian",
    ["a skullcap flower"]           = "skullcap",
    ["a pinch of ground cinnabar"]  = "elm",
    ["a pinch of realgar crystals"] = "valerian",
    ["a pinch of ground malachite"] = "skullcap"
  }

  local short_names = {
    ["slippery elm"]                = "elm",
    ["a valerian leaf"]             = "valerian",
    ["a skullcap flower"]           = "skullcap",
    ["a pinch of ground cinnabar"]  = "cinnabar",
    ["a pinch of realgar crystals"] = "realgar",
    ["a pinch of ground malachite"] = "malachite"
  }

  local id     = tonumber(matches[3])
  local herb   = pipenames[matches[4]]
  local puffs  = tonumber(matches[5])
  local status = matches[2]

  if not (id and herb and puffs and status) then return end

  local filled,lit,arty,puffskey, maxpuffs
  if pipes[herb].id == 0 then
    pipes[herb].id = id
    firstpipe = true
    filled = "filledwith"
    lit = "lit"
    arty = "arty"
    puffskey = "puffs"
    maxpuffs = "maxpuffs"
  else
    pipes[herb].id2 = id
    firstpipe = false
    filled = "filledwith2"
    lit = "lit2"
    arty = "arty2"
    puffskey = "puffs2"
    maxpuffs = "maxpuffs2"
  end

  pipes[herb][arty] = false

  pipes[herb][filled] = short_names[matches[4]]

  if status == "out" then
    pipes[herb][lit] = false
  elseif status == "lit" then
    pipes[herb][lit] = true
   elseif status == "artf" then
    pipes[herb][arty] = true
  end

  pipes[herb][puffskey] = puffs

  -- assume it's a 20 puff pipe if the puffs we have atm is over 10 (bigger than normal)
  if puffs > 10 then
    pipes[herb][maxpuffs] = 20
    echo(" ")
    setFgColor(unpack(getDefaultColorNums))
    echo("(a 20-puff pipe)")
  end

  -- warn if relighting any pipes is on ignore, to make it more obvious - people tended to miss the original line
  if ignore["light"..herb] then
    decho(" "..getDefaultColor().."(")
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("re-enable lighting", 'svo.ignore.light'..herb..' = nil; svo.echof("Re-enabled lighting of the '..pipes[herb].filledwith..' pipe."); if not svo.conf.relight then svo.config.set("relight", "on", true) end', 'Re-lighting the '..pipes[herb].filledwith..' pipe was put on ignore because '..ignore["light"..herb].because..' - click the link to re-enable it', true)
    setUnderline(false)
    decho(getDefaultColor()..")")
  end
end

function parseplistempty()
  local id = tonumber(matches[3])
  local status = matches[2]
  if not (id and status) then return end

  -- save the data, to later assign the pipes to herbs
  pipes.empties[#pipes.empties+1] = {id = id, arty = (status == "artf" and true or false), status = status}
end

function parseplistend()
  -- fill up at least one of each first
  for id = 1, #pipes.pnames do
    local i = pipes.pnames[id]
    if pipes[i] and pipes[i].id == 0 and next(pipes.empties) then
      pipes[i].id = pipes.empties[#pipes.empties].id
      if pipes.empties[#pipes.empties].status == "Lit" then
        pipes[i].lit = true
      else
        pipes[i].lit = false
      end

      if pipes.empties[#pipes.empties].arty then
        pipes[i].arty = true
      end

      pipes.empties[#pipes.empties] = nil
    end
  end

  -- fill up secondary ones
  for id = 1, #pipes.pnames do
    local i = pipes.pnames[id]
    if pipes[i] and pipes[i].id2 == 0 and next(pipes.empties) then
      pipes[i].id2 = pipes.empties[#pipes.empties].id
      if pipes.empties[#pipes.empties].status2 == "Lit" then
        pipes[i].lit2 = true
      else
        pipes[i].lit2 = false
      end

      if pipes.empties[#pipes.empties].arty then
        pipes[i].arty2 = true
      end

      pipes.empties[#pipes.empties] = nil
    end
  end

  pipes.empties = {}
  signals.after_lifevision_processing:unblock(cnrl.checkwarning) -- check for stain lock
  make_gnomes_work()
end

-- assumes that we set some pipe to 0 already. This is used during install only
function pipe_assignid(newid)
  newid = tonumber(newid)
  for id = 1, #pipes.pnames do
    local i = pipes.pnames[id]
    if pipes[i].id == 0 then
      pipes[i].id = newid
      conf[i.."id"] = newid
      pipes[i].lit = false
      send("empty "..newid, false)
      raiseEvent("svo config changed", i.."id")
      return i
    elseif pipes[i].id2 == 0 then
      pipes[i].id2 = newid
      conf[i.."id2"] = newid
      pipes[i].lit2 = false
      send("empty "..newid, false)
      raiseEvent("svo config changed", i.."id2")
      return i
    end
  end
end

if lfs.attributes(getMudletHomeDir() .. "/svo/pipes/conf") then
  local ok = pcall(table.load, getMudletHomeDir() .. "/svo/pipes/conf", pipes)
  if ok then
    -- maxpuffs were added later on in the game, so make sure this field exists for upgrading systems
    pipes.elm.maxpuffs         = pipes.elm.maxpuffs or 10
    pipes.skullcap.maxpuffs    = pipes.skullcap.maxpuffs or 10
    pipes.valerian.maxpuffs    = pipes.valerian.maxpuffs or 10

    -- secondary pipes were added later on, so drop it in
    pipes.elm.maxpuffs2        = pipes.elm.maxpuffs2 or 10
    pipes.skullcap.maxpuffs2   = pipes.skullcap.maxpuffs2 or 10
    pipes.valerian.maxpuffs2   = pipes.valerian.maxpuffs2 or 10

    pipes.elm.lit2             = pipes.elm.lit2 or false
    pipes.skullcap.lit2        = pipes.skullcap.lit2 or false
    pipes.valerian.lit2        = pipes.valerian.lit2 or false

    pipes.elm.id2              = pipes.elm.id2 or 0
    pipes.skullcap.id2         = pipes.skullcap.id2 or 0
    pipes.valerian.id2         = pipes.valerian.id2 or 0

    pipes.elm.arty2            = pipes.elm.arty2 or false
    pipes.skullcap.arty2       = pipes.skullcap.arty2 or false
    pipes.valerian.arty2       = pipes.valerian.arty2 or false

    pipes.elm.puffs2           = pipes.elm.puffs2 or 0
    pipes.skullcap.puffs2      = pipes.skullcap.puffs2 or 0
    pipes.valerian.puffs2      = pipes.valerian.puffs2 or 0

    pipes.elm.filledwith2      = pipes.elm.filledwith2 or "elm"
    pipes.skullcap.filledwith2 = pipes.skullcap.filledwith2 or "skullcap"
    pipes.valerian.filledwith2 = pipes.valerian.filledwith2 or "valerian"

    me.pipes.elm               = pipes.elm
    me.pipes.skullcap          = pipes.skullcap
    me.pipes.valerian          = pipes.valerian
  end
end

signals.connected:connect(function ()
  if not pipes.valerian.arty then pipes.valerian.lit   = false end
  if not pipes.elm.arty then pipes.elm.lit             = false end
  if not pipes.skullcap.arty then pipes.skullcap.lit   = false end

  if not pipes.valerian.arty2 then pipes.valerian.lit2 = false end
  if not pipes.elm.arty2 then pipes.elm.lit2           = false end
  if not pipes.skullcap.arty2 then pipes.skullcap.lit2 = false end

  if not pipes.valerian.filledwith then pipes.valerian.filledwith   = "valerian" end
  if not pipes.elm.filledwith then pipes.elm.filledwith             = "elm" end
  if not pipes.skullcap.filledwith then pipes.skullcap.filledwith   = "skullcap" end

  if not pipes.valerian.filledwith2 then pipes.valerian.filledwith2 = "valerian" end
  if not pipes.elm.filledwith2 then pipes.elm.filledwith2           = "elm" end
  if not pipes.skullcap.filledwith2 then pipes.skullcap.filledwith2 = "skullcap" end
end)

signals.saveconfig:connect(function ()
  local s,m = table.save(getMudletHomeDir() .. "/svo/pipes/conf", pipes)
  if not s then
    echof("Couldn't save settings; %s", m)
  end
end)

-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

--[[  basic idea: if asked to eat something, and we a) don't have it (or not enough),
      or b) are in aeon and have it we outr it, and eat it

      otherwise just eat
  ]]
pl.dir.makepath(getMudletHomeDir() .. "/svo/rift+inv")

rift.riftcontents = {}
rift.invcontents = {}
me.riftcontents = rift.riftcontents
me.invcontents = rift.invcontents

rift.precache = {}
rift.precachedata = {}

rift.doprecache = false

rift.allherbs = {"ash", "bayberry", "bellwort", "bloodroot", "cohosh", "echinacea", "elm", "ginger", "ginseng", "goldenseal", "hawthorn", "kelp", "kola", "kuzu", "lobelia", "myrrh", "pear", "sileris", "skullcap", "valerian", "weed", "slipper", "irid", "ferrum", "stannum", "dolomite", "antimony", "bisemutum", "bellwort", "magnesium", "calamine", "malachite", "azurite", "plumbum", "realgar", "arsenic", "cohosh", "argentum", "calcite", "potash", "quicksilver", "kelp", "kola", "cinnabar", "cuprum", "aurum", "quartz", "gypsum"}
rift.herbsminerals = {"antimony", "argentum", "arsenic", "ash", "aurum", "azurite", "bayberry", "bellwort", "bisemutum", "bloodroot", "calamine", "calcite", "cinnabar", "cohosh", "cuprum", "dolomite", "echinacea", "elm", "ferrum", "ginger", "ginseng", "goldenseal", "gypsum", "hawthorn", "irid", "kelp", "kola", "lobelia", "magnesium", "malachite", "myrrh", "plumbum", "potash", "quartz", "quicksilver", "realgar", "sileris", "skullcap", "stannum", "valerian", "weed"}
rift.functionalherbs = {"slipper", "kuzu", "pear"}

rift.herblist = {"elm", "valerian", "ash", "bayberry", "bellwort", "bloodroot", "cohosh", "echinacea", "ginger", "ginseng", "goldenseal", "hawthorn", "kelp", "kola", "kuzu", "lobelia", "irid", "myrrh", "pear", "sileris", "skullcap", "slipper", "weed"}
rift.curativeherbs = {"ash", "bayberry", "bellwort", "bloodroot", "cohosh", "echinacea", "elm", "ginger", "ginseng", "goldenseal", "hawthorn", "irid", "kelp", "kola", "lobelia", "myrrh", "pear", "sileris", "skullcap", "valerian"}

rift.minerallist = {"ferrum", "stannum", "dolomite", "antimony", "bisemutum", "cuprum", "magnesium", "calamine", "malachite", "azurite", "plumbum", "realgar", "arsenic", "gypsum", "argentum", "calcite", "potash", "quicksilver", "aurum", "quartz", "cinnabar"}

me.herblist = rift.herblist
me.minerallist = rift.minerallist

rift.forestalvials = {"caloric", "epidermal", "frost", "health", "immunity", "levitation", "mana", "mass", "mending", "restoration", "speed", "venom"}

rift.resetriftcontents = function()
  for _, herb in ipairs(rift.allherbs) do
    rift.riftcontents[herb] = 0
  end

  myrift = rift.riftcontents
end

rift.resetinvcontents = function()
  for _, herb in ipairs(rift.allherbs) do
    rift.invcontents[herb] = 0
  end

  myinv = rift.invcontents
end

rift.resetriftcontents()
rift.resetinvcontents()

rift.herbs_plural = {
  elm        = "(%d+) slippery elms",
  valerian   = "(%d+) valerian leaves",
  ash        = "(%d+) pieces of prickly ash bark",
  bayberry   = "(%d+) pieces of bayberry bark",
  bellwort   = "(%d+) bellwort flowers",
  bloodroot  = "(%d+) bloodroot leaves",
  cohosh     = "(%d+) cohosh roots",
  echinacea  = "(%d+) echinacea roots",
  ginger     = "(%d+) ginger roots",
  ginseng    = "(%d+) ginseng roots",
  goldenseal = "(%d+) goldenseal roots",
  hawthorn   = "(%d+) hawthorn berries",
  kelp       = "(%d+) pieces of kelp",
  kola       = "(%d+) kola nuts",
  kuzu       = "(%d+) kuzu roots",
  lobelia    = "(%d+) lobelia seeds",
  irid       = "(%d+) pieces of irid moss",
  myrrh      = "(%d+) myrrh balls",
  pear       = "(%d+) prickly pears",
  sileris    = "(%d+) sileris berries",
  skullcap   = "(%d+) skullcap flowers",
  slipper    = "(%d+) lady's slipper roots",
  weed       = "(%d+) sprigs of cactus weed",

  ferrum      = "(%d+) ferrum flakes",
  stannum     = "(%d+) stannum flakes",
  dolomite    = "(%d+) dolomite grains",
  antimony    = "(%d+) antimony flakes",
  bisemutum   = "(%d+) bisemutum chips",
  cuprum      = "(%d+) cuprum flakes",
  magnesium   = "(%d+) magnesium chips",
  calamine    = "(%d+) calamine crystals",
  malachite   = "(%d+) pinches of ground malachite",
  azurite     = "(%d+) azurite motes",
  plumbum     = "(%d+) plumbum flakes",
  realgar     = "(%d+) pinches of ground realgar",
  arsenic     = "(%d+) arsenic pellets",
  gypsum      = "(%d+) gypsum crystals",
  argentum    = "(%d+) argentum flakes",
  calcite     = "(%d+) calcite motes",
  potash      = "(%d+) potash crystals",
  quicksilver = "(%d+) quicksilver droplets",
  aurum       = "(%d+) aurum flakes",
  quartz      = "(%d+) quartz grains",
  cinnabar    = "(%d+) pinches of ground cinnabar",
}

rift.herbs_singular = {
  ["some prickly ash bark"]  = 'ash',
  ["some bayberry bark"]     = 'bayberry',
  ["a bellwort flower"]      = 'bellwort',
  ["a bloodroot leaf"]       = 'bloodroot',
  ["a black cohosh root"]    = 'cohosh',
  ["an echinacea root"]      = 'echinacea',
  ["slippery elm"]           = 'elm',
  ["a ginger root"]          = 'ginger',
  ["a ginseng root"]         = 'ginseng',
  ["a goldenseal root"]      = 'goldenseal',
  ["a hawthorn berry"]       = 'hawthorn',
  ["a piece of kelp"]        = 'kelp',
  ["a kola nut"]             = 'kola',
  ["a kuzu root"]            = 'kuzu',
  ["a lobelia seed"]         = 'lobelia',
  ["some irid moss"]         = 'irid',
  ["a ball of myrrh gum"]    = 'myrrh',
  ["a prickly pear"]         = 'pear',
  ["a sileris berry"]        = 'sileris',
  ["a skullcap flower"]      = 'skullcap',
  ["a lady's slipper root"]  = 'slipper',
  ["a valerian leaf"]        = 'valerian',
  ["a sprig of cactus weed"] = 'weed',

  ["a ferrum flake"]              = 'ferrum',
  ["a stannum flake"]             = 'stannum',
  ["a dolomite grain"]            = 'dolomite',
  ["an antimony flake"]           = 'antimony',
  ["a bisemutum chip"]            = 'bisemutum',
  ["a cuprum flake"]              = 'cuprum',
  ["a magnesium chip"]            = 'magnesium',
  ["a calamine crystal"]          = 'calamine',
  ["a pinch of ground malachite"] = 'malachite',
  ["an azurite mote"]             = 'azurite',
  ["a plumbum flake"]             = 'plumbum',
  ["a pinch of realgar crystals"] = 'realgar',
  ["an arsenic pellet"]           = 'arsenic',
  ["a gypsum crystal"]            = 'gypsum',
  ["an argentum flake"]           = 'argentum',
  ["a calcite mote"]              = 'calcite',
  ["a potash crystal"]            = 'potash',
  ["a quicksilver droplet"]       = 'quicksilver',
  ["an aurum flake"]              = 'aurum',
  ["a quartz grain"]              = 'quartz',
  ["a pinch of ground cinnabar"]  = 'cinnabar',
}

-- outr line in Achaea uses some special naming - this is formatted for it
rift.herbs_singular_sansprefix = {
  ["prickly ash bark"]    = 'ash',
  ["bayberry bark"]       = 'bayberry',
  ["bellwort flower"]     = 'bellwort',
  ["bloodroot leaf"]      = 'bloodroot',
  ["black cohosh"]        = 'cohosh',
  ["echinacea"]           = 'echinacea',
  ["slippery elm"]        = 'elm',
  ["ginger root"]         = 'ginger',
  ["ginseng root"]        = 'ginseng',
  ["goldenseal root"]     = 'goldenseal',
  ["hawthorn berry"]      = 'hawthorn',
  ["kelp"]                = 'kelp',
  ["kola nut"]            = 'kola',
  ["kuzu root"]           = 'kuzu',
  ["lobelia seed"]        = 'lobelia',
  ["irid moss"]           = 'irid',
  ["myrrh gum"]           = 'myrrh',
  ["prickly pear"]        = 'pear',
  ["sileris"]             = 'sileris',
  ["skullcap"]            = 'skullcap',
  ["lady's slipper root"] = 'slipper',
  ["valerian"]            = 'valerian',
  ["weed"]                = 'weed',

  ["ferrum"]      = "ferrum",
  ["stannum"]     = "stannum",
  ["dolomite"]    = "dolomite",
  ["antimony"]    = "antimony",
  ["bisemutum"]   = "bisemutum",
  ["cuprum"]      = "cuprum",
  ["magnesium"]   = "magnesium",
  ["calamine"]    = "calamine",
  ["malachite"]   = "malachite",
  ["azurite"]     = "azurite",
  ["plumbum"]     = "plumbum",
  ["realgar"]     = "realgar",
  ["arsenic"]     = "arsenic",
  ["gypsum"]      = "gypsum",
  ["argentum"]    = "argentum",
  ["calcite"]     = "calcite",
  ["potash"]      = "potash",
  ["quicksilver"] = "quicksilver",
  ["aurum"]       = "aurum",
  ["quartz"]      = "quartz",
  ["cinnabar"]    = "cinnabar",
}

-- non-herb items - used in inra sorting. A space is used to accomodate the different materials without introducing complications in the code
rift.items_plural = {
  ["iron "]   = "(%d+) pinches of iron filings",
  ["silver "] = "(%d+) bars of silver",
  coal        = "(%d+) coal pieces",
  gold        = "(%d+) nuggets of gold",
  iron        = "(%d+) iron bars",
  lead        = "(%d+) lead beads",
  nodule      = "(%d+) nodules of copper",
  silver      = "(%d+) silver bars",
  tin         = "(%d+) chunks of tin",
  scales      = "(%d+) piles of fish scales",
  lacquer     = "(%d+) pots of lacquer",
  stone       = "(%d+) stones",
}

rift.items_singular = {
  ["a bar of silver"]        = "silver",
  ["a bead of lead"]         = "lead",
  ["a chunk of tin"]         = "tin",
  ["a nodule of copper"]     = "nodule",
  ["a piece of coal"]        = "coal",
  ["a small nugget of gold"] = "gold",
  ["an iron bar"]            = "iron",
  ["a pile of fish scales"]  = "scales",
  ["a small pot of lacquer"] = "lacquer",
  ["a block of stone"]       = "stone",
}

rift.herb_conversions = {
  ash        = "stannum",
  bayberry   = "arsenic",
  bellwort   = "cuprum",
  bloodroot  = "magnesium",
  cohosh     = "gypsum",
  echinacea  = "dolomite",
  elm        = "cinnabar",
  ginger     = "antimony",
  ginseng    = "ferrum",
  goldenseal = "plumbum",
  hawthorn   = "calamine",
  irid       = "potash",
  kelp       = "aurum",
  kola       = "quartz",
  lobelia    = "argentum",
  myrrh      = "bisemutum",
  pear       = "calcite",
  sileris    = "quicksilver",
  skullcap   = "azurite",
  valerian   = "realgar",
}

rift.vial_conversions = {
  caloric     = "exothermic",
  epidermal   = "sensory",
  frost       = "endothermia",
  health      = "vitality",
  immunity    = "antigen",
  levitation  = "hovering",
  mana        = "mentality",
  mass        = "density",
  mending     = "renewal",
  restoration = "reconstructive",
  speed       = "haste",
  venom       = "toxin",
}

function intlen(number)
  return number == 0 and 1 or math.floor(math.log10(number)+1)
end

rift.update_riftlabel = function()
  if not riftlabel or riftlabel.hidden then return end

  local count = 0
  local tbl = {}
  local columncount = svo.conf.riftlabelcolumns or 3
  local charwidth = 20

  for _, j in pairs(rift.herbsminerals) do
    count = count + 1

    tbl[#tbl+1] = string.format([[<font style="color:grey;">%s</font>%s%d<font style="color:grey;">/</font>%d ]], j, string.rep("&nbsp;", charwidth - #j- intlen(rift.invcontents[j]) - intlen(rift.riftcontents[j])), rift.invcontents[j], rift.riftcontents[j])
    if count % columncount == 0 then tbl[#tbl+1] = "<br />" end
  end

  -- fill up the rest with spaces for alignment
  if count % columncount ~= 0 then
    -- insert spaces for each column (20 chars default) + 1 between each column
    local spacesneeded = (columncount - (count % columncount)) * (charwidth+1)
    tbl[#tbl+1] = string.rep("&nbsp;", spacesneeded)
  end

  echo("svo.riftlabel", string.format([[<center><p style="font-size: ]]..(conf.herbstatsize and conf.herbstatsize or 9)..[[px; color:white; font-weight:;">%s</p></center>]], table.concat(tbl)))
end

rift.outr = function (what)
  if not sys.canoutr then return end

  if (rift.precache[what] and rift.precache[what] == 0) or not rift.invcontents[what] or not rift.precache[what] or (rift.invcontents[what] and rift.precache[what] and (rift.invcontents[what] - 1 >= rift.precache[what])) then
    send("outr " .. what, conf.commandecho)
  else
    send("outr " .. (rift.precache[what] - rift.invcontents[what] + 1) .. " " .. what, conf.commandecho)
  end

  -- allow other outrs to catch up, then re-check again
  if sys.blockoutr then killTimer(sys.blockoutr); sys.blockoutr = nil end
  sys.blockoutr = tempTimer(sys.wait + syncdelay(), function () sys.blockoutr = nil; debugf("sys.blockoutr expired") make_gnomes_work() end)
  debugf("sys.blockoutr setup: ", debug.traceback())
end

rift.checkprecache = function()
  rift.doprecache = false

  for herb, amount in pairs(rift.precache) do
    -- if we have addiction, then only precache 1, otherwise, however much is needed
    if rift.precache[herb] ~= 0 and rift.riftcontents[herb] ~= 0 and (not affs.addiction and (rift.invcontents[herb] < rift.precache[herb]) or (rift.invcontents[herb] == 0)) then
      rift.doprecache = true; return
    end
  end
end

-- used by skeleton's check_herb to see that you can eat something. It checks the appropriate herb in inv if we can't outr
-- takes in dict.<aff>.herb as an argument
signals.curemethodchanged:connect(function ()
  if conf.curemethod == "conconly" then
    sk.can_eat_for = function (aff)
      return (rift.invcontents[aff.eatcure[1]] > 0)
    end
  elseif conf.curemethod == "transonly" then
    sk.can_eat_for = function (aff)
      return (rift.invcontents[aff.eatcure[2]] > 0)
    end
  else -- handles nil and prefer*s for curemethod
    sk.can_eat_for = function (aff)
      return (rift.invcontents[aff.eatcure[1]] > 0) or (rift.invcontents[aff.eatcure[2]] > 0)
    end
  end
end)

local function siprandom(what)
  if not es_vialids or not es_vialids[what] or not es_vialids[what][1] then return what end

  return es_vialids[what][math.random(#es_vialids[what])]
end

-- determine the sip method. gets a table as arg with two things - the conc and trans cure
signals.curemethodchanged:connect(function ()
  sip = function (what)
    local use = what.sipcure[1]
    if conf.siprandom then use = siprandom(use) end
    send("sip "..use, conf.commandecho)
    sys.last_used[what.name] = use
  end
end)

-- determine the apply method
signals.curemethodchanged:connect(function ()
  apply = function (what, whereto)
    whereto = whereto or ""
    local use = what.applycure[1]
    send("apply "..use..whereto, conf.commandecho)
    sys.last_used[what.name] = use
  end
end)

-- used to determine what to eat, and set what we've eaten
signals.curemethodchanged:connect(function ()
  if conf.curemethod == "conconly" then
    sk.synceat = function(what)
      local use = what.eatcure[1]
      if rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use = what.eatcure[1]
      if rift.invcontents[use] and rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send("eat " .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == "transonly" then
    sk.synceat = function(what)
      local use = what.eatcure[2]
      if rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use = what.eatcure[2]
      if rift.invcontents[use] and rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send("eat " .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == nil or conf.curemethod == "preferconc" then
    sk.synceat = function(what)
      local use, use2 = what.eatcure[1], what.eatcure[2]
      -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
      if (not (rift.invcontents[use] > 0) and (rift.invcontents[use2] > 0))
        -- or if we don't have the conc cure in rift either, use alchemy
        or not (rift.riftcontents[use] > 0) then
          use = use2
      end

      if rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use, use2 = what.eatcure[1], what.eatcure[2]
      -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
      if (not (rift.invcontents[use] > 0) and (rift.invcontents[use2] > 0))
        -- or if we don't have the conc cure in rift either, use alchemy
        or not (rift.riftcontents[use] > 0) then
          use = use2
      end

      if rift.invcontents[use] and rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send("eat " .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == "prefertrans" then
    -- should eat trans if it's in inv
    -- should eat trans if it's in the rift and no conc in inv
    sk.synceat = function(what)
      -- check if we should use trans
      local use, use2 = what.eatcure[1], what.eatcure[2]
      if (rift.invcontents[use2] > 0)
        or (not (rift.invcontents[use] > 0) and (rift.riftcontents[use2] > 0)) then
          use = use2
      end

      if rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use, use2 = what.eatcure[1], what.eatcure[2]
      if (rift.invcontents[use2] > 0)
        or (not (rift.invcontents[use] > 0) and (rift.riftcontents[use2] > 0)) then
          use = use2
      end

      if rift.invcontents[use] and rift.invcontents[use] > 0 then
        send("eat " .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send("eat " .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == "prefercustom" then
    -- should eat trans if it's in inv
    -- should eat trans if it's in the rift and no conc in inv
    sk.synceat = function(what)
      if me.curelist[what.eatcure[1]] == what.eatcure[1] then
        local use, use2 = what.eatcure[1], what.eatcure[2]
        -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
        if (not (rift.invcontents[use] > 0) and (rift.invcontents[use2] > 0))
          -- or if we don't have the conc cure in rift either, use alchemy
          or not (rift.riftcontents[use] > 0) then
            use = use2
        end

        if rift.invcontents[use] > 0 then
          send("eat " .. use, conf.commandecho)
          sys.last_used[what.name] = use
        else
          rift.outr(use)
        end
      else
        local use, use2 = what.eatcure[1], what.eatcure[2]
        if (rift.invcontents[use2] > 0)
          or (not (rift.invcontents[use] > 0) and (rift.riftcontents[use2] > 0)) then
            use = use2
        end

        if rift.invcontents[use] > 0 then
          send("eat " .. use, conf.commandecho)
          sys.last_used[what.name] = use
        else
          rift.outr(use)
        end
      end
    end
    sk.asynceat = function(what)
      if me.curelist[what.eatcure[1]] == what.eatcure[1] then
        local use, use2 = what.eatcure[1], what.eatcure[2]
        -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
        if (not (rift.invcontents[use] > 0) and (rift.invcontents[use2] > 0))
          -- or if we don't have the conc cure in rift either, use alchemy
          or not (rift.riftcontents[use] > 0) then
            use = use2
        end

        if rift.invcontents[use] and rift.invcontents[use] > 0 then
          send("eat " .. use, conf.commandecho)
          rift.outr(use)
        else
          rift.outr(use)
          send("eat " .. use, conf.commandecho)
        end
        sys.last_used[what.name] = use
      else
        local use, use2 = what.eatcure[1], what.eatcure[2]
        if (rift.invcontents[use2] > 0)
          or (not (rift.invcontents[use] > 0) and (rift.riftcontents[use2] > 0)) then
            use = use2
        end

        if rift.invcontents[use] and rift.invcontents[use] > 0 then
          send("eat " .. use, conf.commandecho)
          rift.outr(use)
        else
          rift.outr(use)
          send("eat " .. use, conf.commandecho)
        end
        sys.last_used[what.name] = use
      end
    end

    -- disabled for now, because tracking which herb we used for an action is problematic
  -- elseif conf.curemethod == "auto" then
  --   sk.synceat = function(what)
  --     -- if we have the alchemy cure, use it, otherwise stick to usual
  --     local haveusual, havealchemy = rift.invcontents[what], rift.invcontents[herb_conversions[what]]
  --     if haveusual and havealchemy then
  --       what = (math.random(1,2) == 1) and what or herb_conversions[what]
  --     elseif not haveusual then
  --       what = herb_conversions[what]
  --     end

  --     if rift.invcontents[what] > 0 then
  --       send("eat " .. what, conf.commandecho)
  --     else
  --       rift.outr(what)
  --     end
  --   end
  --   sk.asynceat = function(what)
  --     local haveusual, havealchemy = rift.invcontents[what], rift.invcontents[herb_conversions[what]]
  --     if haveusual and havealchemy then
  --       what = (math.random(1,2) == 1) and what or herb_conversions[what]
  --     elseif not haveusual then
  --       what = herb_conversions[what]
  --     end

  --     if rift.invcontents[what] and rift.invcontents[what] > 0 then
  --       send("eat " .. what, conf.commandecho)
  --       rift.outr(what)
  --     else
  --       rift.outr(what)
  --       send("eat " .. what, conf.commandecho)
  --     end
    -- end
  end

  -- update the actual 'eat' function
  sk.checkaeony()
  signals.aeony:emit()
end)

signals.systemstart:connect(function()
  signals.curemethodchanged:emit()
end)

signals.aeony:connect(function ()
  if sys.sync then
    eat = sk.synceat
  else
    eat = sk.asynceat
  end
end)

local smoke_herb_conversions = {
  elm      = "cinnabar",
  skullcap = "malachite",
  valerian = "realgar",
}

-- pipes don't need to be refilled that often, so we'll do the herb selection realtime instead of recompiling this huge monster all the time
function sk.asyncfill(what, where)
  local orig = what

  -- work out if we need to change what to its alternative
  if conf.curemethod ~= "conconly" and (

    conf.curemethod == "transonly" or

    ((conf.curemethod == "preferconc" or conf.curemethod == nil) and
      -- we don't have in forestal inventory, but do have alchemy in inventory, use alchemy
       (not (rift.invcontents[what] > 0) and (rift.invcontents[smoke_herb_conversions[what]] > 0)) or
        -- or if we don't have the conc cure in rift either, use alchemy
       (not (rift.riftcontents[what] > 0))) or

    (conf.curemethod == "prefertrans" and -- we *do* have the trans available
      (rift.invcontents[smoke_herb_conversions[what]] > 0
        or (not (rift.invcontents[what] > 0) and (rift.riftcontents[smoke_herb_conversions[what]] > 0)))) or

    -- prefercustom, and we either prefer alchy and have it, or prefer conc and don't have it
    (conf.curemethod == "prefercustom" and
      ((me.curelist[what] == smoke_herb_conversions[what] and rift.riftcontents[smoke_herb_conversions[what]] > 0)
        or
       (me.curelist[what] == what and rift.riftcontents[what] <= 0)
      )
    )) then
      what = smoke_herb_conversions[what]
  end

  sys.last_used["fill"..orig.."_physical"] = what
  pipes[orig].filledwith = what

  if rift.invcontents[what] > 0 then
    if pipes[orig].puffs > 0 then
      if not defc.selfishness then
        send("empty "..where, conf.commandecho)
      else
        for i = 1, (pipes[orig].puffs + 1) do
          send("smoke "..where, conf.commandecho)
        end
      end
    end

    send("put " .. what .. " in " .. where, conf.commandecho)
    rift.outr(what)
  else
    rift.outr(what)
    if pipes[orig].puffs > 0 then
      if not defc.selfishness then
        send("empty "..where, conf.commandecho)
      else
        for i = 1, (pipes[orig].puffs + 1) do
          send("smoke "..where, conf.commandecho)
        end
      end
    end
    send("put " .. what .. " in " .. where, conf.commandecho)
  end
end

function sk.syncfill(what, where)
  local orig = what
  -- work out if we need to change what to its alternative
  if conf.curemethod ~= "conconly" and (

    conf.curemethod == "transonly" or

    ((conf.curemethod == "preferconc" or conf.curemethod == nil) and
       (not (rift.invcontents[what] > 0) and (rift.invcontents[smoke_herb_conversions[what]] > 0))
        -- or if we don't have the conc cure in rift either, use alchemy
        or not (rift.riftcontents[what] > 0)) or

    (conf.curemethod == "prefertrans" and
      (rift.invcontents[smoke_herb_conversions[what]] > 0)
        or (not (rift.invcontents[what] > 0) and (rift.riftcontents[smoke_herb_conversions[what]] > 0))) or

    -- prefercustom, and we either prefer alchy and have it, or prefer conc and don't have it
    (conf.curemethod == "prefercustom" and (
      (me.curelist[what] == what and rift.riftcontents[what] <= 0)
        or
      (me.curelist[what] == smoke_herb_conversions[what] and rift.riftcontents[smoke_herb_conversions[what]] > 0)
    ))) then
      what = smoke_herb_conversions[what]
  end

  sys.last_used["fill"..orig.."_physical"] = what
  pipes[orig].filledwith = what

  if pipes[orig].puffs > 0 then
    if defc.selfishness then echof("Problem - can't refill while selfish :/") return end
    send("empty "..where, conf.commandecho)
  elseif rift.invcontents[what] > 0 then
    send("put " .. what .. " in " .. where, conf.commandecho)
  else
    rift.outr(what)
  end
end

signals.aeony:connect(function ()
  if sys.sync then
    fillpipe = sk.syncfill
  else
    fillpipe = sk.asyncfill
  end
end)


function riftline()
  for i = 1, #matches, 3 do
    local amount = tonumber(matches[i+1])
    local rawherbstring, herb = matches[i+2], false

    -- Achaea's rift doesn't use standard singular naming or even the short names,
    -- so substring find which herb is it
    for _, herbi in ipairs(rift.allherbs) do
      if rawherbstring:find("%f[%a]"..herbi.."%f[%A]") then
        herb = herbi
        break
      end
    end

    if herb and amount then
      rift.riftcontents[herb] = amount
    end
  end

  rift.update_riftlabel()
end

function showrift()
  display(rift.riftcontents)
end

function showinv()
  display(rift.invcontents)
end

function showprecache()
  local count = 1

  local function makelink(herb, sign)
    if sign == "-" and rift.precache[herb] == 0 then
      echo " "
    elseif sign == "+" then
      echoLink(sign, [[svo.setprecache("]]..herb..[[", 1, "add", nil, true)]], sign .. " the " .. herb .. " amount")
    elseif sign == "-" then
      echoLink(sign, [[svo.setprecache("]]..herb..[[", 1, "subtract", nil, true)]], sign .. " the " .. herb .. " amount")
    else
      echo " "
    end

    return ""
  end

--[[  moveCursor("main", 0, getLastLineNumber("main"))
  debugf("line: " .. getCurrentLine() .. ", latest: " .. getLastLineNumber("main"))
  if getCurrentLine() == "-" or getCurrentLine() == " " then
    insertText(" ")
    for i = 1, 1000 do deleteLine()
    debugf("deleting") end
  end]]
  echof("Herb pre-cache list (%s defences):", defs.mode)

  local t = {}; for herb in pairs(rift.precache) do t[#t+1] = herb end; table.sort(t)
  for i = 1, #t do
    local herb, amount = t[i], rift.precache[t[i]]
  -- for herb, amount in pairs(rift.precache) do
    if count % 3 ~= 0 then
      decho(string.format("<153,204,204>[<91,134,214>%d<153,204,204>%s%s] %-"..(intlen(amount) == 1 and "23" or "22").."s", amount, makelink(herb, "+"), makelink(herb, "-"), herb))
    else
      decho(string.format("<153,204,204>[<91,134,214>%d<153,204,204>%s%s] %s", amount, makelink(herb, "+"), makelink(herb, "-"), herb)) end

    if count % 3 == 0 then echo("\n") end
    count = count + 1
  end

--[[  moveCursor("main", 0, getLastLineNumber("main"))
  moveCursor("main", #getCurrentLine(), getLastLineNumber("main"))
  insertText("\n-\n")]]
  echo"\n"
  showprompt()
end

function setprecache(herb, amount, flag, echoback, show_list)
  local sendf
  if echoback then sendf = echof else sendf = errorf end

  assert(rift.precache[herb], "what herb do you want to set a precache amount for?", sendf)

  if flag == "add" then
    rift.precache[herb] = rift.precache[herb] + amount
  elseif flag == "subtract" then
    rift.precache[herb] = rift.precache[herb] - amount
    if rift.precache[herb] < 0 then rift.precache[herb] = 0 end
  elseif not flag or flag == "set" then
    rift.precache[herb] = amount
  end

  if echoback then
    echof("Will keep at least %d of %s out in the inventory now.", rift.precache[herb], herb)
  elseif show_list then
    showprecache()
  end
  rift.checkprecache()
end

function invline()
  rift.resetinvcontents()

  -- lowercase as the first letter is capitalised
  local line = line:lower()
  local tabledline = line:split(", ")

  -- strip out the last 'and'
  if tabledline[#tabledline]:starts("and ") then
    tabledline[#tabledline] = tabledline[#tabledline]:gsub("^and ", '')
  end

  -- for everything we got in our inv
  for i = 1, #tabledline do
    local riftable = tabledline[i]
    if riftable:sub(-1) == "." then riftable = riftable:sub(1,#riftable - 1) end -- kill trailing dot

    -- tally up rift.herbs_singular items
    if rift.herbs_singular[riftable] then
      rift.invcontents[rift.herbs_singular[riftable]] = rift.invcontents[rift.herbs_singular[riftable]] + 1
    end

    -- tally up rift.herbs_plural items
    for k,l in pairs(rift.herbs_plural) do
      local result = riftable:match(l)
      if result then
        rift.invcontents[k] = rift.invcontents[k] + tonumber(result)
      end
    end
  end

  rift.update_riftlabel()
  rift.checkprecache()
end

function riftremoved()
  local removed = tonumber(matches[2])
  local what = rift.herbs_singular_sansprefix[matches[3]]
  local inrift = tonumber(matches[4])

  if not (what and removed and inrift) then return end

  if rift.riftcontents[what] then rift.riftcontents[what] = inrift end
  if rift.invcontents[what] then rift.invcontents[what] = rift.invcontents[what] + removed end

  rift.update_riftlabel()

  signals.removed_from_rift:emit(removed, what, inrift)

  -- don't add if not doing it
  checkaction(dict.doprecache.misc, false)
  if actions.doprecache_misc then
    lifevision.add(actions.doprecache_misc.p)
  end
end

function pocketbelt_added()
  local removedamount = tonumber(matches[2])
  local what = matches[3]
  if not rift.invcontents[what] then return end

  rift.invcontents[what] = rift.invcontents[what] - removedamount
end

function pocketbelt_removed()
  local removedamount = tonumber(matches[2])
  local what = matches[3]
  if not rift.invcontents[what] then return end

  rift.invcontents[what] = rift.invcontents[what] + removedamount
end

function riftadded()
  local removed = tonumber(matches[2])
  local what = rift.herbs_singular_sansprefix[matches[3]]
  if not what then return end
  local inrift = tonumber(matches[4])

  if rift.riftcontents[what] then rift.riftcontents[what] = inrift end
  if rift.invcontents[what] then rift.invcontents[what] = rift.invcontents[what] - removed end
  if rift.invcontents[what] and rift.invcontents[what] < 0 then rift.invcontents[what] = 0 end

  rift.update_riftlabel()
  rift.checkprecache()
end

function riftnada()
  local what = matches[2]
  if rift.invcontents[what] then rift.invcontents[what] = 0 end

  rift.update_riftlabel()
  rift.checkprecache()
end

function riftate()
  -- if conf.aillusion and not (usingbal"herb" or usingbal"moss") then
  --   resetFormat()
  --   echoLink(" (i)", '', "Precache considered this to be an illusion (because the system isn't eating anything right now) and didn't count the herb used", true)
  --   return
  -- end

  local what = matches[2]

  if not rift.herbs_singular[what] then return end

  if not conf.arena then
    rift.invcontents[rift.herbs_singular[what]] = rift.invcontents[rift.herbs_singular[what]] - 1
    if rift.invcontents[rift.herbs_singular[what]] < 0 then rift.invcontents[rift.herbs_singular[what]] = 0 end
  end

  rift.update_riftlabel()
  rift.checkprecache()
end

do
  local oldCL = createLabel
  function createLabel(name, posX, posY, width, height, fillBackground)
    oldCL(name, 0, 0, 0, 0, fillBackground)
    moveWindow(name, posX, posY)
    resizeWindow(name, width, height)
  end
end

function toggle_riftlabel(toggle)
  if (type(toggle) == 'nil' and riftlabel.hidden) or (type(toggle) ~= 'nil' and toggle) then
    riftlabel:show()
    rift.update_riftlabel()
    echof("Spawned the herbstat window.")
    conf.riftlabel = true
    raiseEvent("svo config changed", "riftlabel")
  elseif (type(toggle) == 'nil' and not riftlabel.hidden) or (type(toggle) ~= 'nil' and not toggle) then
    riftlabel:hide()
    echof("Hid the herbstat window.")
    conf.riftlabel = false
    raiseEvent("svo config changed", "riftlabel")
  end
end

signals.systemstart:add_post_emit(function ()
  if lfs.attributes(getMudletHomeDir() .. "/svo/rift+inv/rift") then
    table.load(getMudletHomeDir() .. "/svo/rift+inv/rift", rift.riftcontents)
  end
  if lfs.attributes(getMudletHomeDir() .. "/svo/rift+inv/inv") then
    table.load(getMudletHomeDir() .. "/svo/rift+inv/inv", rift.invcontents)
  end

  -- reset, because we can't have herbs in inv at login
  rift.resetinvcontents()

  for mode, _ in pairs(defdefup) do
    rift.precachedata[mode] = {}

    for _,herb in pairs(rift.herbsminerals) do
      rift.precachedata[mode][herb] = 0
    end

    if mode == "combat" then
      rift.precachedata[mode].irid = 1
      rift.precachedata[mode].kelp = 1
      rift.precachedata[mode].bloodroot = 1
    end
  end



  local tmp = {}
  if lfs.attributes(getMudletHomeDir() .. "/svo/rift+inv/precachedata") then
    table.load(getMudletHomeDir() .. "/svo/rift+inv/precachedata", tmp)
    update(rift.precachedata, tmp)
    rift.precache = rift.precachedata[defs.mode]

    -- moss was removed, get rid of it
    for mode, m in pairs(rift.precachedata) do
      if m.moss then m.moss = nil end
    end
  end
  rift.update_riftlabel()
end)

signals.enablegmcp:connect(function()
  sendGMCP([[Core.Supports.Add ["IRE.Rift 1"] ]])
end)

signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/rift+inv/rift", rift.riftcontents)
  table.save(getMudletHomeDir() .. "/svo/rift+inv/inv", rift.invcontents)
  table.save(getMudletHomeDir() .. "/svo/rift+inv/precachedata", rift.precachedata)
end)


sk.checkaeony()
signals.aeony:emit()

-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

function valid.diagnose_start()
  checkaction(dict.diag.physical)
  if actions.diag_physical then
    lifevision.add(actions.diag_physical.p)
  elseif conf.aillusion then
    setTriggerStayOpen("svo diag", 0)
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', 'Ignored this diagnose because we aren\'t actually diagnosing right now (if this is godfeelings, don\'t mind me, then)')
    moveCursorEnd()

    -- necessary since the trigger itself lasts on the next line
    prompttrigger("reset diag", function() sk.diag_list = {} end)
   end
end

function valid.empty_diagnose()
  checkaction(dict.diag.physical)
  if actions.diag_physical then
    lifevision.add(actions.diag_physical.p, nil, nil, 1)
    valid.diagnose_end()
  else
    ignore_illusion("Ignoring this illusion because we weren't diagnosing right now.")
  end
end

local whitelist = {}
whitelist.lovers, whitelist.retardation, whitelist.hoisted = true, true, true

function valid.diagnose_end()
  if sk.diag_list.godfeelings then sk.diag_list = {} setTriggerStayOpen("svo diag", 0) return end

  -- clear ones we don't have
  for affn, afft in pairs(affs) do
    if not sk.diag_list[affn] and not whitelist[affn] then
      if dict[affn].count then dict[affn].count = 0 end
      removeaff(affn)
    elseif not whitelist[affn] then -- if we do have the aff, remove from diag list, so we don't add it again
      -- but update the current count!
      if type(sk.diag_list[affn]) == "number" and dict[affn].count then
        dict[affn].count = sk.diag_list[affn]
        updateaffcount(dict[affn])
      end

      sk.diag_list[affn] = nil
    end
  end

  -- add left over ones
  for j,k in pairs(sk.diag_list) do
    -- skip defs
    if defc[j] == nil then
      checkaction(dict[j].aff, true)
      if type(k) == "number" and not dict[j].count then
        for amount = 1, k do lifevision.add(actions[j .. "_aff"].p) end
      elseif type(k) == "number" and dict[j].count then
        lifevision.add(actions[j .. "_aff"].p, nil, k)
      else
        lifevision.add(actions[j .. "_aff"].p)
      end
    end
  end

  affsp = {} -- potential affs
  sk.checkaeony()
  signals.aeony:emit()
  setTriggerStayOpen("svo diag", 0)
  sk.diag_list = {}
end

function valid.diag_ablaze()
  sk.diag_list.ablaze = true

  if not affs.ablaze then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.ablaze.sw).."s)")
  end

  if ignore.ablaze then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_severeburn()
  sk.diag_list.severeburn = true

  if not affs.severeburn then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.severeburn.sw).."s)")
  end

  if ignore.severeburn then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_extremeburn()
  sk.diag_list.extremeburn = true

  if not affs.extremeburn then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.extremeburn.sw).."s)")
  end

  if ignore.extremeburn then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_charredburn()
  sk.diag_list.charredburn = true

  if not affs.charredburn then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.charredburn.sw).."s)")
  end

  if ignore.charredburn then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_meltingburn()
  sk.diag_list.meltingburn = true

  if not affs.meltingburn then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.meltingburn.sw).."s)")
  end

  if ignore.meltingburn then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_addiction()
  sk.diag_list.addiction = true

  if not affs.addiction then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.addiction.sw).."s)")
  end

  if ignore.addiction then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_aeon()
  sk.diag_list.aeon = true

  if not affs.aeon then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.aeon.sw).."s)")
  end

  if ignore.aeon then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_agoraphobia()
  sk.diag_list.agoraphobia = true

  if not affs.agoraphobia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.agoraphobia.sw).."s)")
  end

  if ignore.agoraphobia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_anorexia()
  sk.diag_list.anorexia = true

  if not affs.anorexia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.anorexia.sw).."s)")
  end

  if ignore.anorexia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_asthma()
  sk.diag_list.asthma = true

  if not affs.asthma then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.asthma.sw).."s)")
  end

  if ignore.asthma then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_blackout()
  sk.diag_list.blackout = true

  if not affs.blackout then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.blackout.sw).."s)")
  end

  if ignore.blackout then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_bleeding()
  sk.diag_list.bleeding = true

  if not affs.bleeding then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.bleeding.sw).."s)")
  end

  if ignore.bleeding then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_bound()
  sk.diag_list.bound = true

  if not affs.bound then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.bound.sw).."s)")
  end

  if ignore.bound then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_burning()
  sk.diag_list.burning = true

  if not affs.burning then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.burning.sw).."s)")
  end

  if ignore.burning then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_claustrophobia()
  sk.diag_list.claustrophobia = true

  if not affs.claustrophobia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.claustrophobia.sw).."s)")
  end

  if ignore.claustrophobia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_clumsiness()
  sk.diag_list.clumsiness = true

  if not affs.clumsiness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.clumsiness.sw).."s)")
  end

  if ignore.clumsiness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mildconcussion()
  sk.diag_list.mildconcussion = true

  if not affs.mildconcussion then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mildconcussion.sw).."s)")
  end

  if ignore.mildconcussion then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_confusion()
  sk.diag_list.confusion = true

  if not affs.confusion then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.confusion.sw).."s)")
  end

  if ignore.confusion then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_crippledleftarm()
  sk.diag_list.crippledleftarm = true

  if not affs.crippledleftarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.crippledleftarm.sw).."s)")
  end

  if ignore.crippledleftarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_crippledleftleg()
  sk.diag_list.crippledleftleg = true

  if not affs.crippledleftleg then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.crippledleftleg.sw).."s)")
  end

  if ignore.crippledleftleg then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_crippledrightarm()
  sk.diag_list.crippledrightarm = true

  if not affs.crippledrightarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.crippledrightarm.sw).."s)")
  end

  if ignore.crippledrightarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_crippledrightleg()
  sk.diag_list.crippledrightleg = true

  if not affs.crippledrightleg then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.crippledrightleg.sw).."s)")
  end

  if ignore.crippledrightleg then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_darkshade()
  sk.diag_list.darkshade = true

  if not affs.darkshade then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.darkshade.sw).."s)")
  end

  if ignore.darkshade then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_deadening()
  sk.diag_list.deadening = true

  if not affs.deadening then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.deadening.sw).."s)")
  end

  if ignore.deadening then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_dementia()
  sk.diag_list.dementia = true

  if not affs.dementia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.dementia.sw).."s)")
  end

  if ignore.dementia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_disloyalty()
  sk.diag_list.disloyalty = true

  if not affs.disloyalty then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.disloyalty.sw).."s)")
  end

  if ignore.disloyalty then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_disrupt()
  sk.diag_list.disrupt = true

  if not affs.disrupt then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.disrupt.sw).."s)")
  end

  if ignore.disrupt then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_dissonance()
  sk.diag_list.dissonance = true

  if not affs.dissonance then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.dissonance.sw).."s)")
  end

  if ignore.dissonance then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_dizziness()
  sk.diag_list.dizziness = true

  if not affs.dizziness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.dizziness.sw).."s)")
  end

  if ignore.dizziness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_epilepsy()
  sk.diag_list.epilepsy = true

  if not affs.epilepsy then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.epilepsy.sw).."s)")
  end

  if ignore.epilepsy then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_fear()
  sk.diag_list.fear = true

  if not affs.fear then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.fear.sw).."s)")
  end

  if ignore.fear then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_galed()
  sk.diag_list.galed = true

  if not affs.galed then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.galed.sw).."s)")
  end

  if ignore.galed then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_generosity()
  sk.diag_list.generosity = true

  if not affs.generosity then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.generosity.sw).."s)")
  end

  if ignore.generosity then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_haemophilia()
  sk.diag_list.haemophilia = true

  if not affs.haemophilia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.haemophilia.sw).."s)")
  end

  if ignore.haemophilia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hallucinations()
  sk.diag_list.hallucinations = true

  if not affs.hallucinations then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hallucinations.sw).."s)")
  end

  if ignore.hallucinations then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_healthleech()
  sk.diag_list.healthleech = true

  if not affs.healthleech then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.healthleech.sw).."s)")
  end

  if ignore.healthleech then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_heartseed()
  sk.diag_list.heartseed = true

  if not affs.heartseed then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.heartseed.sw).."s)")
  end

  if ignore.heartseed then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hellsight()
  sk.diag_list.hellsight = true

  if not affs.hellsight then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hellsight.sw).."s)")
  end

  if ignore.hellsight then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hypersomnia()
  sk.diag_list.hypersomnia = true

  if not affs.hypersomnia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hypersomnia.sw).."s)")
  end

  if ignore.hypersomnia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hypochondria()
  sk.diag_list.hypochondria = true

  if not affs.hypochondria then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hypochondria.sw).."s)")
  end

  if ignore.hypochondria then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_icing()
  sk.diag_list.icing = true

  if not affs.icing then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.icing.sw).."s)")
  end

  if ignore.icing then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_illness()
  sk.diag_list.illness = true

  if not affs.illness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.illness.sw).."s)")
  end

  if ignore.illness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_impale()
  sk.diag_list.impale = true

  if not affs.impale then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.impale.sw).."s)")
  end

  if ignore.impale then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_impatience()
  sk.diag_list.impatience = true

  if not affs.impatience then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.impatience.sw).."s)")
  end

  if ignore.impatience then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_inlove()
  sk.diag_list.inlove = true

  if not affs.inlove then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.inlove.sw).."s)")
  end

  if ignore.inlove then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_inquisition()
  sk.diag_list.inquisition = true

  if not affs.inquisition then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.inquisition.sw).."s)")
  end

  if ignore.inquisition then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_itching()
  sk.diag_list.itching = true

  if not affs.itching then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.itching.sw).."s)")
  end

  if ignore.itching then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_justice()
  sk.diag_list.justice = true

  if not affs.justice then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.justice.sw).."s)")
  end

  if ignore.justice then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_laceratedthroat()
  sk.diag_list.laceratedthroat = true

  if not affs.laceratedthroat then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.laceratedthroat.sw).."s)")
  end

  if ignore.laceratedthroat then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_lethargy()
  sk.diag_list.lethargy = true

  if not affs.lethargy then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.lethargy.sw).."s)")
  end

  if ignore.lethargy then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_loneliness()
  sk.diag_list.loneliness = true

  if not affs.loneliness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.loneliness.sw).."s)")
  end

  if ignore.loneliness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_lovers()
  sk.diag_list.lovers = true

  if not affs.lovers then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.lovers.sw).."s)")
  end

  if ignore.lovers then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_madness()
  sk.diag_list.madness = true

  if not affs.madness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.madness.sw).."s)")
  end

  if ignore.madness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mangledleftarm()
  sk.diag_list.mangledleftarm = true

  if not affs.mangledleftarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mangledleftarm.sw).."s)")
  end

  if ignore.mangledleftarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mangledleftleg()
  sk.diag_list.mangledleftleg = true

  if not affs.mangledleftleg then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mangledleftleg.sw).."s)")
  end

  if ignore.mangledleftleg then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mangledrightarm()
  sk.diag_list.mangledrightarm = true

  if not affs.mangledrightarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mangledrightarm.sw).."s)")
  end

  if ignore.mangledrightarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mangledrightleg()
  sk.diag_list.mangledrightleg = true

  if not affs.mangledrightleg then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mangledrightleg.sw).."s)")
  end

  if ignore.mangledrightleg then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_masochism()
  sk.diag_list.masochism = true

  if not affs.masochism then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.masochism.sw).."s)")
  end

  if ignore.masochism then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mildtrauma()
  sk.diag_list.mildtrauma = true

  if not affs.mildtrauma then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mildtrauma.sw).."s)")
  end

  if ignore.mildtrauma then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mutilatedleftarm()
  sk.diag_list.mutilatedleftarm = true

  if not affs.mutilatedleftarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mutilatedleftarm.sw).."s)")
  end

  if ignore.mutilatedleftarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mutilatedleftleg()
  sk.diag_list.mutilatedleftleg = true

  if not affs.mutilatedleftleg then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mutilatedleftleg.sw).."s)")
  end

  if ignore.mutilatedleftleg then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mutilatedrightarm()
  sk.diag_list.mutilatedrightarm = true

  if not affs.mutilatedrightarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mutilatedrightarm.sw).."s)")
  end

  if ignore.mutilatedrightarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_mutilatedrightleg()
  sk.diag_list.mutilatedrightleg = true

  if not affs.mutilatedrightleg then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.mutilatedrightleg.sw).."s)")
  end

  if ignore.mutilatedrightleg then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_pacifism()
  sk.diag_list.pacifism = true

  if not affs.pacifism then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.pacifism.sw).."s)")
  end

  if ignore.pacifism then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_paralysis()
  sk.diag_list.paralysis = true

  if not affs.paralysis then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.paralysis.sw).."s)")
  end

  if ignore.paralysis then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_paranoia()
  sk.diag_list.paranoia = true

  if not affs.paranoia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.paranoia.sw).."s)")
  end

  if ignore.paranoia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_peace()
  sk.diag_list.peace = true

  if not affs.peace then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.peace.sw).."s)")
  end

  if ignore.peace then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_prone()
  sk.diag_list.prone = true

  if not affs.prone then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.prone.sw).."s)")
  end

  if ignore.prone then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_recklessness()
  sk.diag_list.recklessness = true

  if not affs.recklessness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.recklessness.sw).."s)")
  end

  if ignore.recklessness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_relapsing()
  sk.diag_list.relapsing = true

  if not affs.relapsing then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.relapsing.sw).."s)")
  end

  if ignore.relapsing then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_roped()
  sk.diag_list.roped = true

  if not affs.roped then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.roped.sw).."s)")
  end

  if ignore.roped then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_selarnia()
  sk.diag_list.selarnia = true

  if not affs.selarnia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.selarnia.sw).."s)")
  end

  if ignore.selarnia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_sensitivity()
  sk.diag_list.sensitivity = true

  if not affs.sensitivity then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.sensitivity.sw).."s)")
  end

  if ignore.sensitivity then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_seriousconcussion()
  sk.diag_list.seriousconcussion = true

  if not affs.seriousconcussion then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.seriousconcussion.sw).."s)")
  end

  if ignore.seriousconcussion then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_serioustrauma()
  sk.diag_list.serioustrauma = true

  if not affs.serioustrauma then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.serioustrauma.sw).."s)")
  end

  if ignore.serioustrauma then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_shyness()
  sk.diag_list.shyness = true

  if not affs.shyness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.shyness.sw).."s)")
  end

  if ignore.shyness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_slashedthroat()
  sk.diag_list.slashedthroat = true

  if not affs.slashedthroat then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.slashedthroat.sw).."s)")
  end

  if ignore.slashedthroat then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_slickness()
  sk.diag_list.slickness = true

  if not affs.slickness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.slickness.sw).."s)")
  end

  if ignore.slickness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_stun()
  sk.diag_list.stun = true

  if not affs.stun then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.stun.sw).."s)")
  end

  if ignore.stun then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_stupidity()
  sk.diag_list.stupidity = true

  if not affs.stupidity then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.stupidity.sw).."s)")
  end

  if ignore.stupidity then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_stuttering()
  sk.diag_list.stuttering = true

  if not affs.stuttering then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.stuttering.sw).."s)")
  end

  if ignore.stuttering then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_transfixed()
  sk.diag_list.transfixed = true

  if not affs.transfixed then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.transfixed.sw).."s)")
  end

  if ignore.transfixed then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_unknownany()
  sk.diag_list.unknownany = true

  if not affs.unknownany then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.unknownany.sw).."s)")
  end

  if ignore.unknownany then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_unknowncrippledarm()
  sk.diag_list.unknowncrippledarm = true

  if not affs.unknowncrippledarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.unknowncrippledarm.sw).."s)")
  end

  if ignore.unknowncrippledarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_unknowncrippledleg()
  sk.diag_list.unknowncrippledleg = true

  if not affs.unknowncrippledleg then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.unknowncrippledleg.sw).."s)")
  end

  if ignore.unknowncrippledleg then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_unknownmental()
  sk.diag_list.unknownmental = true

  if not affs.unknownmental then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.unknownmental.sw).."s)")
  end

  if ignore.unknownmental then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_vertigo()
  sk.diag_list.vertigo = true

  if not affs.vertigo then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.vertigo.sw).."s)")
  end

  if ignore.vertigo then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_voided()
  sk.diag_list.voided = true

  if not affs.voided then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.voided.sw).."s)")
  end

  if ignore.voided then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_voyria()
  sk.diag_list.voyria = true

  if not affs.voyria then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.voyria.sw).."s)")
  end

  if ignore.voyria then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_weakness()
  sk.diag_list.weakness = true

  if not affs.weakness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.weakness.sw).."s)")
  end

  if ignore.weakness then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_webbed()
  sk.diag_list.webbed = true

  if not affs.webbed then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.webbed.sw).."s)")
  end

  if ignore.webbed then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hamstring()
  sk.diag_list.hamstring = true

  if not affs.hamstring then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hamstring.sw).."s)")
  end

  if ignore.hamstring then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_shivering()
  sk.diag_list.shivering = true

  if not affs.shivering then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.shivering.sw).."s)")
  end

  if ignore.shivering then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_frozen()
  sk.diag_list.frozen = true

  if not affs.frozen then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.frozen.sw).."s)")
  end

  if ignore.frozen then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_manaleech()
  sk.diag_list.manaleech = true

  if not affs.manaleech then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.manaleech.sw).."s)")
  end

  if ignore.manaleech then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_voyria()
  sk.diag_list.voyria = true

  if not affs.voyria then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.voyria.sw).."s)")
  end

  if ignore.voyria then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_slightfluid()
  sk.diag_list.slightfluid = true

  if not affs.slightfluid then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.slightfluid.sw).."s)")
  end

  if ignore.slightfluid then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_elevatedfluid()
  sk.diag_list.elevatedfluid = true

  if not affs.elevatedfluid then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.elevatedfluid.sw).."s)")
  end

  if ignore.elevatedfluid then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_highfluid()
  sk.diag_list.highfluid = true

  if not affs.highfluid then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.highfluid.sw).."s)")
  end

  if ignore.highfluid then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_seriousfluid()
  sk.diag_list.seriousfluid = true

  if not affs.seriousfluid then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.seriousfluid.sw).."s)")
  end

  if ignore.seriousfluid then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_criticalfluid()
  sk.diag_list.criticalfluid = true

  if not affs.criticalfluid then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.criticalfluid.sw).."s)")
  end

  if ignore.criticalfluid then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_godfeelings()
  sk.diag_list.godfeelings = true

  if not affs.godfeelings then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.godfeelings.sw).."s)")
  end

  if ignore.godfeelings then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_phlogistication()
  sk.diag_list.phlogistication = true

  if not affs.phlogistication then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.phlogistication.sw).."s)")
  end

  if ignore.phlogistication then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_vitrification()
  sk.diag_list.vitrification = true

  if not affs.vitrification then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.vitrification.sw).."s)")
  end

  if ignore.vitrification then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_corrupted()
  sk.diag_list.corrupted = true

  if not affs.corrupted then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.corrupted.sw).."s)")
  end

  if ignore.corrupted then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_stain()
  sk.diag_list.stain = true

  if not affs.stain then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.stain.sw).."s)")
  end

  if ignore.stain then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_rixil()
  sk.diag_list.rixil = true

  if not affs.rixil then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.rixil.sw).."s)")
  end

  if ignore.rixil then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_palpatar()
  sk.diag_list.palpatar = true

  if not affs.palpatar then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.palpatar.sw).."s)")
  end

  if ignore.palpatar then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_cadmus()
  sk.diag_list.cadmus = true

  if not affs.cadmus then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.cadmus.sw).."s)")
  end

  if ignore.cadmus then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hecate()
  sk.diag_list.hecate = true

  if not affs.hecate then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hecate.sw).."s)")
  end

  if ignore.hecate then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_ninkharsag()
  sk.diag_list.ninkharsag = true

  if not affs.ninkharsag then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.ninkharsag.sw).."s)")
  end

  if ignore.ninkharsag then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_spiritdisrupt()
  sk.diag_list.spiritdisrupt = true

  if not affs.spiritdisrupt then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.spiritdisrupt.sw).."s)")
  end

  if ignore.spiritdisrupt then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_airdisrupt()
  sk.diag_list.airdisrupt = true

  if not affs.airdisrupt then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.airdisrupt.sw).."s)")
  end

  if ignore.airdisrupt then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_firedisrupt()
  sk.diag_list.firedisrupt = true

  if not affs.firedisrupt then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.firedisrupt.sw).."s)")
  end

  if ignore.firedisrupt then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_earthdisrupt()
  sk.diag_list.earthdisrupt = true

  if not affs.earthdisrupt then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.earthdisrupt.sw).."s)")
  end

  if ignore.earthdisrupt then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_waterdisrupt()
  sk.diag_list.waterdisrupt = true

  if not affs.waterdisrupt then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.waterdisrupt.sw).."s)")
  end

  if ignore.waterdisrupt then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hoisted()
  sk.diag_list.hoisted = true

  if not affs.hoisted then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hoisted.sw).."s)")
  end

  if ignore.hoisted then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_swellskin()
  sk.diag_list.swellskin = true

  if not affs.swellskin then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.swellskin.sw).."s)")
  end

  if ignore.swellskin then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_pinshot()
  sk.diag_list.pinshot = true

  if not affs.pinshot then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.pinshot.sw).."s)")
  end

  if ignore.pinshot then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_hypothermia()
  sk.diag_list.hypothermia = true

  if not affs.hypothermia then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.hypothermia.sw).."s)")
  end

  if ignore.hypothermia then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_scalded()
  sk.diag_list.scalded = true

  if not affs.scalded then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.scalded.sw).."s)")
  end

  if ignore.scalded then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_dehydrated()
  sk.diag_list.dehydrated = true

  if not affs.dehydrated then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.dehydrated.sw).."s)")
  end

  if ignore.dehydrated then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_timeflux()
  sk.diag_list.timeflux = true

  if not affs.timeflux then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.timeflux.sw).."s)")
  end

  if ignore.timeflux then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_numbedleftarm()
  sk.diag_list.numbedleftarm = true

  if not affs.numbedleftarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.numbedleftarm.sw).."s)")
  end

  if ignore.numbedleftarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_numbedrightarm()
  sk.diag_list.numbedrightarm = true

  if not affs.numbedrightarm then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.numbedrightarm.sw).."s)")
  end

  if ignore.numbedrightarm then
    decho(getDefaultColor().." (currently ignored)")
  end
end
function valid.diag_unconsciousness()
  sk.diag_list.unconsciousness = true

  if not affs.unconsciousness then
    decho(getDefaultColor().."(new)")
  else
    decho(getDefaultColor().." ("..getStopWatchTime(affs.unconsciousness.sw).."s)")
  end

  if ignore.unconsciousness then
    decho(getDefaultColor().." (currently ignored)")
  end
end

-- afflictions with a count
function valid.diag_cholerichumour(howmuch)
  sk.diag_list.cholerichumour = tonumber(howmuch)

  if ignore.cholerichumour then
    echo(" (currently ignored)")
  end
end
function valid.diag_melancholichumour(howmuch)
  sk.diag_list.melancholichumour = tonumber(howmuch)

  if ignore.melancholichumour then
    echo(" (currently ignored)")
  end
end
function valid.diag_phlegmatichumour(howmuch)
  sk.diag_list.phlegmatichumour = tonumber(howmuch)

  if ignore.phlegmatichumour then
    echo(" (currently ignored)")
  end
end
function valid.diag_sanguinehumour(howmuch)
  sk.diag_list.sanguinehumour = tonumber(howmuch)

  if ignore.sanguinehumour then
    echo(" (currently ignored)")
  end
end
function valid.diag_bleeding(howmuch)
  sk.diag_list.bleeding = tonumber(howmuch)

  if ignore.bleeding then
    echo(" (currently ignored)")
  end
end
function valid.diag_skullfractures(howmuch)
  sk.diag_list.skullfractures = tonumber(howmuch)

  if ignore.skullfractures then
    echo(" (currently ignored)")
  end
end
function valid.diag_crackedribs(howmuch)
  sk.diag_list.crackedribs = tonumber(howmuch)

  if ignore.crackedribs then
    echo(" (currently ignored)")
  end
end
function valid.diag_wristfractures(howmuch)
  sk.diag_list.wristfractures = tonumber(howmuch)

  if ignore.wristfractures then
    echo(" (currently ignored)")
  end
end
function valid.diag_torntendons(howmuch)
  sk.diag_list.torntendons = tonumber(howmuch)

  if ignore.torntendons then
    echo(" (currently ignored)")
  end
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

for i,j in ipairs({"ablaze", "severeburn", "extremeburn", "charredburn", "meltingburn", "addiction", "aeon", "agoraphobia", "anorexia", "asthma", "blackout", "bleeding", "bound", "burning", "claustrophobia", "clumsiness", "mildconcussion", "confusion", "crippledleftarm", "crippledleftleg", "crippledrightarm", "crippledrightleg", "darkshade", "deadening", "dementia", "disloyalty", "disrupt", "dissonance", "dizziness", "epilepsy", "fear", "galed", "generosity", "haemophilia", "hallucinations", "healthleech", "heartseed", "hellsight", "hypersomnia", "hypochondria", "icing", "illness", "impale", "impatience", "inlove", "inquisition", "itching", "justice", "laceratedthroat", "lethargy", "loneliness", "lovers", "madness", "mangledleftarm", "mangledleftleg", "mangledrightarm", "mangledrightleg", "masochism", "mildtrauma", "mutilatedleftarm", "mutilatedleftleg", "mutilatedrightarm", "mutilatedrightleg", "pacifism", "paralysis", "paranoia", "peace", "prone", "recklessness", "relapsing", "roped", "selarnia", "sensitivity", "seriousconcussion", "serioustrauma", "shyness", "slashedthroat", "slickness", "stun", "stupidity", "stuttering", "transfixed", "unknownany", "unknowncrippledarm", "unknowncrippledleg", "unknownmental", "vertigo", "voided", "voyria", "weakness", "webbed", "hamstring", "shivering", "frozen", "blindaff", "deafaff", "retardation", "manaleech", "sleep", "amnesia", "unknowncrippledlimb", "cholerichumour", "melancholichumour", "phlegmatichumour", "sanguinehumour", "phlogistication", "vitrification", "corrupted", "stain", "rixil", "palpatar", "cadmus", "hecate", "ninkharsag", "spiritdisrupt", "airdisrupt", "firedisrupt", "earthdisrupt", "waterdisrupt", "hoisted", "swellskin", "pinshot", "hypothermia", "scalded", "dehydrated", "timeflux", "lullaby", "numbedleftarm", "numbedrightarm", "unconsciousness",
}) do
  valid["simple" .. j] = function ()
    checkaction(dict[j].aff, true)
    lifevision.add(actions[j .. "_aff"].p)
  end
end

valid.simpleprone = function ()
  checkaction(dict.prone.aff, true)
  lifevision.add(actions.prone_aff.p)

  if conf.paused and conf.hinderpausecolour then
    selectCurrentLine()
    fg(conf.hinderpausecolour)
    resetFormat()
    deselect()
  end
end

valid.simplewebbed = function ()
  checkaction(dict.webbed.aff, true)
  lifevision.add(actions.webbed_aff.p)

  if conf.paused and conf.hinderpausecolour then
    selectCurrentLine()
    fg(conf.hinderpausecolour)
    resetFormat()
    deselect()
  end
end

valid.simpleblackout = function()
  checkaction(dict.blackout.aff, true)
  -- add it first, before others - so stun checking doesn't delay blackout
  lifevision.addcust(actions.blackout_aff.p, 1)
end

valid.simplebleeding = function (amount)
  if not conf.preclot then return end

  checkaction(dict.bleeding.aff, true)
  if lifevision.l.bleeding_aff then
    lifevision.add(actions.bleeding_aff.p, nil, dict.bleeding.count + (amount or 200) + (lifevision.l.bleeding_aff.arg or 0))
  else
    lifevision.add(actions.bleeding_aff.p, nil, dict.bleeding.count + (amount or 200))
  end
end

valid.simplelovers = function (name)
  assert(name)

  if (conf.autoreject == "white" and me.lustlist[name]) or (conf.autoreject == "black" and not me.lustlist[name]) then return end

  checkaction(dict.lovers.aff, true)
  dict.lovers.tempmap[#dict.lovers.tempmap+1] = name -- hack to allow multiple names on ALLIES
  lifevision.add(actions.lovers_aff.p, nil)
end

valid.simpleunknowncrippledleg = function (number)
  assert(not number or tonumber(number), "svo.valid.simpleunknowncrippledleg: how many affs do you want to add? Must be a number")

  checkaction(dict.unknowncrippledleg.aff, true)

  if lifevision.l.unknowncrippledleg_aff then
    lifevision.add(actions.unknowncrippledleg_aff.p, nil, (number or 1) + (lifevision.l.unknowncrippledleg_aff.arg or 1))
  else
    lifevision.add(actions.unknowncrippledleg_aff.p, nil, (number or 1))
  end
end

valid.simpleunknowncrippledarm = function (number)
  assert(not number or tonumber(number), "svo.valid.simpleunknowncrippledarm: how many affs do you want to add? Must be a number")

  checkaction(dict.unknowncrippledarm.aff, true)

  if lifevision.l.unknowncrippledarm_aff then
    lifevision.add(actions.unknowncrippledarm_aff.p, nil, (number or 1) + (lifevision.l.unknowncrippledarm_aff.arg or 1))
  else
    lifevision.add(actions.unknowncrippledarm_aff.p, nil, (number or 1))
  end
end

valid.simpleunknowncrippledlimb = function (number)
  assert(not number or tonumber(number), "svo.valid.simpleunknowncrippledlimb: how many affs do you want to add? Must be a number")

  checkaction(dict.unknowncrippledlimb.aff, true)

  if lifevision.l.unknowncrippledlimb_aff then
    lifevision.add(actions.unknowncrippledlimb_aff.p, nil, (number or 1) +(lifevision.l.unknowncrippledlimb_aff.arg or 1))
  else
    lifevision.add(actions.unknowncrippledlimb_aff.p, nil, (number or 1))
  end
end

valid.simpleunknownany = function (number)
  assert(not number or tonumber(number), "svo.valid.simpleunknownany: how many affs do you want to add? Must be a number")
  if number then assert(number > 0, "svo.valid.simpleunknownany: number must be positive") end

  checkaction(dict.unknownany.aff, true)
  if lifevision.l.unknownany_aff then
    lifevision.add(actions.unknownany_aff.p, nil, (number or 1) +(lifevision.l.unknownany_aff.arg or 1))
  else
    lifevision.add(actions.unknownany_aff.p, nil, (number or 1))
  end

  -- to check if we got reckless!
  if stats.currenthealth ~= stats.maxhealth then
    dict.unknownany.reckhp = true end
  if stats.currentmana ~= stats.maxmana then
    dict.unknownany.reckmana = true end
end

valid.simpleunknownmental = function (number)
  assert(not number or tonumber(number), "svo.valid.simpleunknownany: how many affs do you want to add? Must be a number")
  if number then assert(number > 0, "svo.valid.simpleunknownmental: number must be positive") end

  checkaction(dict.unknownmental.aff, true)
  if lifevision.l.unknownmental_aff then
    lifevision.add(actions.unknownmental_aff.p, nil, (number or 1) +(lifevision.l.unknownmental_aff.arg or 1))
  else
    lifevision.add(actions.unknownmental_aff.p, nil, (number or 1))
  end

  -- to check if we got reckless!
  if stats.currenthealth ~= stats.maxhealth then
    dict.unknownmental.reckhp = true end
  if stats.currentmana ~= stats.maxmana then
    dict.unknownmental.reckmana = true end
end

valid.simpleskullfractures = function (number)
  assert(not number or tonumber(number), "svo.valid.simpleskullfractures: how many affs do you want to add? Must be a number")

  checkaction(dict.skullfractures.aff, true)

  if lifevision.l.skullfractures_aff then
    lifevision.add(actions.skullfractures_aff.p, nil, (number or 1) +(lifevision.l.skullfractures_aff.arg or 1))
  else
    lifevision.add(actions.skullfractures_aff.p, nil, (number or 1))
  end
end
valid.simplecrackedribs = function (number)
  assert(not number or tonumber(number), "svo.valid.simplecrackedribs: how many affs do you want to add? Must be a number")

  checkaction(dict.crackedribs.aff, true)

  if lifevision.l.crackedribs_aff then
    lifevision.add(actions.crackedribs_aff.p, nil, (number or 1) +(lifevision.l.crackedribs_aff.arg or 1))
  else
    lifevision.add(actions.crackedribs_aff.p, nil, (number or 1))
  end
end
valid.simplewristfractures = function (number)
  assert(not number or tonumber(number), "svo.valid.simplewristfractures: how many affs do you want to add? Must be a number")

  checkaction(dict.wristfractures.aff, true)

  if lifevision.l.wristfractures_aff then
    lifevision.add(actions.wristfractures_aff.p, nil, (number or 1) +(lifevision.l.wristfractures_aff.arg or 1))
  else
    lifevision.add(actions.wristfractures_aff.p, nil, (number or 1))
  end
end
valid.simpletorntendons = function (number)
  assert(not number or tonumber(number), "svo.valid.simpletorntendons: how many affs do you want to add? Must be a number")

  checkaction(dict.torntendons.aff, true)

  if lifevision.l.torntendons_aff then
    lifevision.add(actions.torntendons_aff.p, nil, (number or 1) +(lifevision.l.torntendons_aff.arg or 1))
  else
    lifevision.add(actions.torntendons_aff.p, nil, (number or 1))
  end
end

-- historical API compatibility
valid.proper_crippledleftleg = simplecrippledrightleg
valid.proper_crippledrightleg = simplecrippledrightleg
valid.proper_crippledrightarm = simplecrippledrightarm
valid.proper_crippledleftarm = simplecrippledleftarm
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.








function valid.caught_illusion()
  sys.flawedillusion = true
  me.haveillusion = true
end

function not_illusion(reason)
  sys.not_illusion = reason or true
end

function ignore_illusion(reason, moveback)
  -- don't spam with multiple (i)'s
  if sys.flawedillusion then return end

  sys.flawedillusion = true
  me.haveillusion = reason or true
  local currentline = getLineNumber()

  if reason == "not first" then
    local previousline = getLines(currentline-1, currentline)[1]
    moveCursor(#getCurrentLine(), currentline)
    insertText(" ") moveCursor(#getCurrentLine(), currentline) insertLink("(i)", '', string.format("Ignored this illusion because '%s' can't come together with '%s' at once.", line, previousline))
  else
    if moveback then moveCursor(0, currentline-1) end
    moveCursor(#getCurrentLine(), currentline)
    insertText(" ") moveCursor(#getCurrentLine(), currentline) insertLink("(i)", '', reason or '')
  end

  moveCursorEnd("main")
  debugf("ignore_illusion()")
end

function show_info(shortmsg, message, moveback)
  if moveback then moveCursor(0, getLineNumber()-1) end
  moveCursor(#getCurrentLine(), getLineNumber())
  insertText(" ") moveCursor(#getCurrentLine(), getLineNumber())
  deselect()
  fg("green")
  insertLink("("..shortmsg..")", '', message or '') -- can't format, https://bugs.launchpad.net/mudlet/+bug/1027732
  resetFormat()
end

-- +2 if we do stuff on the prompt
function vm.last_line_was_prompt(onprompt)
  return (paragraph_length == 1) and true or false
end

function valid.symp_asleep()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then
    ignore_illusion("not first")
    return
  end

  if not affs.sleep and not actions.sleep_aff then
    checkaction(dict.sleep.aff, true)
    lifevision.add(actions["sleep_aff"].p, "symptom", nil, 1)
  end

  -- reset non-wait things we were doing, because they got cancelled by the sleep
  if affs.asleep or actions.asleep_aff then
    for k,v in actions:iter() do
      if v.p.balance ~= "waitingfor" and v.p.balance ~= "aff" then
        killaction(dict[v.p.action_name][v.p.balance])
      end
    end
  end
end

function valid.cured_lovers()
  checkaction(dict.lovers.physical)
  if actions.lovers_physical then
    lifevision.add(actions.lovers_physical.p, nil, multimatches[2][2])
  end
end

function valid.cured_lovers_nobody()
  checkaction(dict.lovers.physical)
  if actions.lovers_physical then
    lifevision.add(actions.lovers_physical.p, "nobody")
  end
end


function valid.bloodsworn_gone()
end

function defs.sileris_start()
  checkaction(dict.sileris.misc)
  if actions.sileris_misc then
    lifevision.add(actions.sileris_misc.p)
  end
end

function defs.sileris_finished()
  checkaction(dict.waitingforsileris.waitingfor)
  if actions.waitingforsileris_waitingfor then
    lifevision.add(actions.waitingforsileris_waitingfor.p)
  end
end

function defs.sileris_slickness()
  checkaction(dict.sileris.misc)
  if actions.sileris_misc then
    if dict.sileris.applying == "quicksilver" and not line:find("quicksilver", 1, true) then
      ignore_illusion("Ignored this illusion because we're applying quicksilver, not sileris right now (or we were forced).")
    elseif dict.sileris.applying == "sileris" and not line:find("berry", 1, true) then
      ignore_illusion("Ignored this illusion because we're applying sileris, not quicksilver right now (or we were forced).")
    else
      lifevision.add(actions.sileris_misc.p, "slick", nil, 1)
    end
  end
end

function valid.sileris_flayed()
  if not conf.aillusion then
    defs.lost_sileris()
  elseif paragraph_length == 1 then
    checkaction(dict.sileris.gone, true)
    lifevision.add(actions.sileris_gone.p, nil, getLastLineNumber("main"), 1)
  else
    ignore_illusion("not first")
  end
end

function valid.insomnia_relaxed()
  if not conf.aillusion then
    defs.lost_insomnia()
  else
    checkaction(dict.insomnia.gone, true)
    lifevision.add(actions.insomnia_gone.p, "relaxed", getLastLineNumber("main"))
  end
end

function valid.insomnia_healed()
  if not conf.aillusion then
    defs.lost_insomnia()
  elseif affs.blackout or paragraph_length > 1 then
    defs.lost_insomnia()
  else
    ignore_illusion("The heal line doesn't seem to be on it's own as it should be.")
  end
end

function defs.got_block(dir)
  checkaction(dict.block.physical)
  if actions.block_physical then
    lifevision.add(actions.block_physical.p, nil, dir)
  end
end

function valid.smoke_stillgot_inquisition()
  checkaction(dict.hellsight.smoke)
  if actions.hellsight_smoke then
    lifevision.add(actions.hellsight_smoke.p, "inquisition")
  end
end

function valid.smoke_stillhave_madness()
  checkaction(dict.madness.smoke)
  if actions.madness_smoke then
    lifevision.add(actions.madness_smoke.p, "hecate")
  end
end

function valid.smoke_have_rebounding()
  checkaction(dict.rebounding.smoke)
  if actions.rebounding_smoke then
    smoke_cure = true
    lifevision.add(actions.rebounding_smoke.p, "alreadygot")
  end
end

function defs.got_fitness() end
function valid.fitness_cured_asthma() end
function valid.fitness_weariness() end
function valid.fitness_allgood() end


function valid.dragonform_riding()
  if actions.riding_physical then
    lifevision.add(actions.riding_physical.p, "dragonform")
  end
end

function defs.started_dragonform()
  if actions.dragonform_physical then
    lifevision.add(actions.dragonform_physical.p)
  end
end

-- set the Elder dragon colour - but only when we are mid-dragonforming, so as not to get tricked by illusions
function valid.dragonformingcolour(colour)
  if not conf.aillusion or actions.waitingfordragonform_waitingfor then
    colour = colour:lower()

    local t = {
       ["red"] = 'dragonfire',
       ["black"] = 'acid',
       ["silver"] = 'lightning',
       -- it is 'golden' and not 'gold' for this message
       ["golden"] = 'psi',
       ["blue"] = 'ice',
       ["green"] = 'venom'
    }

    conf.dragonbreath = t[colour]
    raiseEvent("svo config changed", "dragonbreath")
  end
end

function defs.got_dragonform()
  checkaction(dict.waitingfordragonform.waitingfor)
  if actions.waitingfordragonform_waitingfor then
    lifevision.add(actions.waitingfordragonform_waitingfor.p)
  end
end

function defs.cancelled_dragonform()
  if actions.waitingfordragonform_waitingfor then
    lifevision.add(actions.waitingfordragonform_waitingfor.p, "cancelled")
  end
end





function valid.alreadyhave_dragonbreath()
  if actions.dragonbreath_physical then
    lifevision.add(actions.dragonbreath_physical.p, "alreadygot")
  end
end

function defs.alreadyhave_dragonform()
  if actions.dragonform_physical then
    lifevision.add(actions.dragonform_physical.p, "alreadyhave")
  end
end

function defs.started_dragonbreath()
  if actions.dragonbreath_physical then
    lifevision.add(actions.dragonbreath_physical.p)
  end
end

function defs.got_dragonbreath()
  checkaction(dict.waitingfordragonbreath.waitingfor)
  if actions.waitingfordragonbreath_waitingfor then
    lifevision.add(actions.waitingfordragonbreath_waitingfor.p)
  end
end
-- hallucinations symptoms
function valid.swandive()
  local have_pflag = pflags.p
  sk.onprompt_beforeaction_add("swandive", function ()
    if not have_pflag and pflags.p then
      valid.simpleprone()
      valid.simplehallucinations()
    end
  end)
end

-- detect conf/dizzy, or amnesia/amnesia at worst
function sk.check_evileye()
  if find_until_last_paragraph("Your curseward has been breached!", "exact") then
    sk.tempevileye.count = sk.tempevileye.count - 1
  end

  -- fails when they give the same aff twice
  --[[local affcount = 0
  for action in lifevision.l:iter() do
    if string.ends(action, "_aff") or string.find(action, "check") then affcount = affcount + 1 end
  end

  local diff = sk.tempevileye.count - affcount]]

  local diff = sk.tempevileye.hiddencount

  if diff == 1 then
    valid.simpleunknownmental()
    echof("assuming focusable aff.")
  elseif diff == 2 then
    valid.simpleconfusion()
    valid.simpleunknownmental()
    echof("assuming confusion and focusable aff.")
  end
  -- diff of 0 is OK

  sk.tempevileye = nil
  signals.before_prompt_processing:disconnect(sk.check_evileye)
end

function valid.hidden_evileye()
  if line:find("stares at you, giving you the evil eye", 1, true) or isPrompt() then
    sk.tempevileye.hiddencount = (sk.tempevileye.hiddencount or 0) + 1
  end
end

function valid.evileye()
  -- check next line to see if it's
  if sk.tempevileye then sk.tempevileye.count = sk.tempevileye.count + 1 return end -- don't set it if the first line already did
  sk.tempevileye = {startline = getLastLineNumber("main"), count = 1}
  signals.before_prompt_processing:connect(sk.check_evileye)
end

function sk.check_trip()
  if not find_until_last_paragraph("You parry the attack with a deft manoeuvre.", "exact") and not find_until_last_paragraph("You step into the attack,", "substring") then
    valid.simpleprone()
  end

  signals.before_prompt_processing:disconnect(sk.check_trip)
end

function valid.trip_prone()
  signals.before_prompt_processing:connect(sk.check_trip)
end

function valid.spiders_all_overme()
  valid.simplefear()
  valid.simplehallucinations()
end

function valid.symp_impale()
  if affs.blackout then
    valid.proper_impale()
  elseif not conf.aillusion then
    valid.simpleimpale()
  else
    sk.impale_symptom()
  end
end

function valid.symp_stupidity()
  sk.stupidity_symptom()
end

function valid.symp_transfixed()
  sk.transfixed_symptom()
end


function valid.symp_paralysis()
  if actions.fillskullcap_physical then
    killaction(dict.fillskullcap.physical)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(getDefaultColor().." (paralysis confirmed)")
    end
    return
  elseif actions.fillelm_physical then
    killaction(dict.fillelm.physical)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(getDefaultColor().." (paralysis confirmed)")
    end
    return
  elseif actions.fillvalerian_physical then
    killaction(dict.fillvalerian.physical)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(getDefaultColor().." (paralysis confirmed)")
    end
    return
  end

  if actions.checkparalysis_misc then
    lifevision.add(actions.checkparalysis_misc.p, "paralysed")
    decho(getDefaultColor().." (paralysis confirmed)")
  elseif not conf.aillusion then
    valid.simpleparalysis()
  elseif not affs.paralysis then
    checkaction(dict.checkparalysis.aff, true)
    lifevision.add(actions.checkparalysis_aff.p)
  end

  if actions.prone_misc then
    killaction(dict.prone.misc)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(getDefaultColor().." (paralysis confirmed)")
    end
  end

  -- in slowcuring only (for AI safety for now), count all balanceful actions for paralysis
  if sys.sync and usingbal"physical" then
    valid.simpleparalysis()
  end
end

function valid.symp_stun()
  if not conf.aillusion then
    valid.simplestun()
  elseif actions.checkstun_misc then
    lifevision.add(actions.checkstun_misc.p)
  else
    sk.stun_symptom()
  end

  -- reset non-wait things we were doing, because they got cancelled by the stun
  if affs.stun or actions.stun_aff then
    for k,v in actions:iter() do
      if v.p.balance ~= "waitingfor" and v.p.balance ~= "aff" then
        killaction(dict[v.p.action_name][v.p.balance])
      end
    end
  end
end

function valid.symp_illness_constitution()
  sk.illness_constitution_symptom()
end

function valid.saidnothing()
  if actions.checkslows_misc then
    deleteLineP()
    lifevision.add(actions.checkslows_misc.p, "onclear")
  elseif affs.aeon or affs.retardation or affs.stun then
    deleteLineP()
  end
end
valid.silence_vibe = valid.saidnothing

function valid.jump()
  if actions.checkparalysis_misc then
    lifevision.add(actions.checkparalysis_misc.p, "onclear")
    deleteLineP()
  end
end

function valid.nobalance()
  if actions.checkparalysis_misc then
    lifevision.add(actions.checkparalysis_misc.p, "paralysed")
    deleteLineP()
  end

  if actions.checkasthma_misc then
    lifevision.add(actions.checkasthma_misc.p, "weakbreath", nil, 1)
  end

  -- cancel standing if we can't due to no balance
  if actions.prone_misc then
    killaction(dict.prone.misc)
    if bals.balance then
      bals.balance = false -- unset balance, in case of blackout, where we don't see prompt
      raiseEvent("svo lost balance", "balance")
    end
  end

  -- this might not be necessary for this case of getting hit off balance
  -- elseif actions.breath_physical and not affs.asthma and affsp.asthma then
  --   checkaction(dict.checkasthma.misc, true)
  --   lifevision.add(actions.checkasthma_misc.p, "weakbreath", nil, 1)
  -- end
end

function valid.nothingtowield()
  if actions.checkparalysis_misc then
    deleteLineP()
    lifevision.add(actions.checkparalysis_misc.p, "onclear")
  end
end

function valid.nosymptom()
  if actions.checkwrithes_misc then
    tempLineTrigger(0,3,[[deleteLine()]])
    lifevision.add(actions.checkwrithes_misc.p, "onclear")
  end
end

function valid.nothingtoeat()
  if actions.checkanorexia_misc then
    deleteLineP()
    lifevision.add(actions.checkanorexia_misc.p, "onclear")
  elseif actions.checkstun_misc then
    deleteLineP()
    lifevision.add(actions.checkstun_misc.p, "onclear")
  elseif affs.anorexia or affs.stun then
    deleteLineP()
  end
end

function valid.lungsokay()
  if actions.checkasthma_misc then
    deleteLineP()
    lifevision.add(actions.checkasthma_misc.p, "onclear")
  end
end

-- given a sluggish symptom, either confirms sluggish if we're checking for it already
-- or goes out and tests it
function valid.webeslow()
  sk.sawsluggish = getLastLineNumber("main") -- for retardation going away auto-detection
  if sk.sluggishtimer then killTimer(sk.sluggishtimer); sk.sluggishtimer = nil end

  -- if triggered by curing, don't consider it retardation
  if sk.sawcuring() then return end

  -- if we suspect aeon, and aren't checking it yet, add the action in
  if affsp.aeon and not actions.checkslows_misc then
    checkaction(dict.checkslows.misc, true)
  end

  -- confirm that we're sluggish if we were checking for slows
  if actions.checkslows_misc then
    lifevision.add(actions.checkslows_misc.p, "sluggish")
    return
  end

  -- if we have aeon or retardation already, do nothing then
  if affs.aeon or affs.retardation then return end

  if affs.blackout and not affs.retardation then
    valid.simpleaeon()
  elseif not affs.retardation then
    -- confirm aeon out of the blue, treat it as retardation over aeon
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, "retardation")
    -- sk.retardation_symptom()
  end
end

function valid.webbily()
  if actions.checkwrithes_misc then
    lifevision.add(actions.checkwrithes_misc.p, "webbily")
  end
end

function valid.symp_webbed()
  if not conf.aillusion then
    valid.simplewebbed()
  else
    sk.webbed_symptom()
  end
end

function valid.symp_impaled()
  if not conf.aillusion then
    valid.simpleimpale()
  else
    sk.impaled_symptom()
  end
end

function valid.transfixily()
  if actions.checkwrithes_misc then
    lifevision.add(actions.checkwrithes_misc.p, "transfixily")
  end

  -- special workaround for waking up not showing up in blackout: clear sleep if we saw this msg
  -- it's an issue otherwise to miss the sleep msg from a totem while in blackout and think you're still asleep
  if affs.asleep then removeaff("asleep") end
end

function valid.symp_roped()
  if not conf.aillusion then
    valid.simpleroped()
  else
    sk.roped_symptom()
  end
end

function valid.symp_transfixed()
  if not conf.aillusion then
    valid.simpletransfixed()
  else
    sk.transfixed_symptom()
  end
end

function valid.weakbreath()
  if actions.checkasthma_misc then
    lifevision.add(actions.checkasthma_misc.p, "weakbreath", nil, 1)
  elseif actions.breath_physical and not affs.asthma then
    checkaction(dict.checkasthma.misc, true)
    lifevision.add(actions.checkasthma_misc.p, "weakbreath", nil, 1)
  elseif conf.aillusion and (not actions.breath_physical and not affs.asthma) then
    ignore_illusion("Ignored this illusion because we aren't trying to hold breath right now (or we were forced).")
  else
    checkaction(dict.checkasthma.aff, true)
    lifevision.add(actions.checkasthma_aff.p)
  end
end

function valid.impaly()
  if actions.checkwrithes_misc then
    lifevision.add(actions.checkwrithes_misc.p, "impaly")
  end
end

function valid.chimera_stun()
  if conf.aillusion and (not defc.deaf or not affs.deafaff or not actions.deafaff_aff) then return end

  valid.simplestun(2)
end

function valid.restore()
  checkaction(dict.restore.physical)
  if actions.restore_physical then
    -- prevent against a well-timed restore use, which when empty, forces us to clear all afflictions
    if conf.aillusion then
      local time, lat = getStopWatchTime(actions.restore_physical.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    valid.passive_cure()
    lifevision.add(actions.restore_physical.p, nil, getLineNumber())

    selectCurrentLine()
    setBgColor(0,0,0)
    setFgColor(0,170,255)
    resetFormat()
  end
end

function valid.dragonheal()
  checkaction(dict.dragonheal.physical)
  if actions.dragonheal_physical then
    valid.passive_cure()
    lifevision.add(actions.dragonheal_physical.p, nil, getLineNumber())

    selectCurrentLine()
    setBgColor(0,0,0)
    setFgColor(0,170,255)
    resetFormat()
  end
end

function valid.nodragonheal()
  checkaction(dict.dragonheal.physical)
  if actions.dragonheal_physical then
    lifevision.add(actions.dragonheal_physical.p, "nobalance")
  end
end

function valid.knighthood_disembowel()
  local result = checkany(dict.curingimpale.waitingfor)

  -- we won't get curing* if we didn't even start to writhe, so fake it for these purposes
  if not result and affs.impale then
    checkaction(dict.curingimpale.waitingfor, true)
    result = { name = "curingimpale_waitingfor" }
  end

  if result and actions[result.name] then
    lifevision.add(actions[result.name].p, "withdrew")
  end
end

valid.impale_withdrew = valid.knighthood_disembowel

function valid.fell_sleep()
  checkaction(dict.sleep.aff, true)
  checkaction(dict.prone.aff, true)

  lifevision.add(actions.sleep_aff.p)
  lifevision.add(actions.prone_aff.p)
end

function valid.proper_sleep()
  if defc.insomnia then
    defs.lost_insomnia()
  else
    checkaction(dict.sleep.aff, true)
    checkaction(dict.prone.aff, true)

    lifevision.add(actions.sleep_aff.p)
    lifevision.add(actions.prone_aff.p)
  end
end

function valid.disruptingshiver()
  if conf.aillusion and bals.equilibrium then
    sk.onprompt_beforeaction_add("disruptingshiver", function ()
      if not bals.equilibrium  then
        checkaction(dict.shivering.aff, true)
        checkaction(dict.disrupt.aff, true)
        lifevision.add(actions.shivering_aff.p)
        lifevision.add(actions.disrupt_aff.p)
        defs.lost_caloric()
      end
    end)
  else
    checkaction(dict.shivering.aff, true)
    checkaction(dict.disrupt.aff, true)
    lifevision.add(actions.shivering_aff.p)
    lifevision.add(actions.disrupt_aff.p)
    defs.lost_caloric()
  end
end

function svo.valid.check_dragonform()
  -- show xp? ignore!
  if lastpromptnumber+1 == getLastLineNumber("main") or not find_until_last_paragraph(me.name, "substring") then return end

  if defc.dragonform and not find_until_last_paragraph("Dragon)", "substring") then
    echo"\n" echof("Apparently we aren't in Dragon.")
    svo.defs.lost_dragonform()
    svo.defs.lost_dragonarmour()
    svo.defs.lost_dragonbreath()
  elseif not defc.dragonform and find_until_last_paragraph("Dragon)", "substring") then
    echo"\n" echof("Apparently we're in Dragon.")
    svo.defs.got_dragonform()
  end
end

svo.defs.got_dragonform = dict.waitingfordragonform.waitingfor.oncompleted

function valid.proper_impale()
  if not conf.aillusion then
    valid.simpleimpale()
  else
    checkaction(dict.checkwrithes.aff, true)
    lifevision.add(actions.checkwrithes_aff.p, "impale", stats.currenthealth)
  end
end

function valid.swachbuckling_pesante()
  if (not find_until_last_paragraph("The attack rebounds back onto", "substring")) and (find_until_last_paragraph("jabs", "substring")) and (find_until_last_paragraph("you", "substring")) then
    if (not conf.aillusion) or (defc.deaf or affs.deafaff) then
      valid.simplestun(.5)
    end
  end
end

--[[
  Martellato can get tricked by the following, avoid it:

  Lightning-quick, Bob jabs you with a Soulpiercer.
  A prickly, stinging sensation spreads through your body.
  The songblessing upon the rapier sings out with a piercing high note.
  Mary viciously jabs an elegant Mhaldorian rapier into Bob.
  The songblessing upon the rapier swells with a rich, vibrant hum.

]]
function valid.swachbuckling_martellato()
  if not find_until_last_paragraph("The attack rebounds back onto", "substring") and
     find_until_last_paragraph("jabs", "substring") and
     find_until_last_paragraph("you", "substring") and
     not find_until_last_paragraph("^%w+ viciously jabs", "pattern") then
    valid.simpleprone()
  end
end

local last_jabber = ""
function valid.swashbuckling_jab(name)
  if sk.swashbuckling_jab then killTimer(sk.swashbuckling_jab) end
  sk.swashbuckling_jab = tempTimer(.5, function() sk.swashbuckling_jab = nil end)
  last_jabber = name
end

function valid.voicecraft_tremolo(name, side)
  local known_class = (ndb and ndb.getclass(name))
  if not conf.aillusion or ((affs["crippled"..side.."leg"] or sk["delayvenom_"..side.."leg"] or sk["delayacciaccatura_"..side.."leg"]) and ((sk.swashbuckling_jab and last_jabber == name) or known_class == "bard")) then

    -- when we've accepted that the Tremolo is legitimate, record the side - to be checked later in the mangle trigger for verification
    sk.tremoloside = sk.tremoloside or {}
    sk.tremoloside[side] = true
    prompttrigger("clear tremolo", function()
      -- the prompttrigger happens after the mangle should have been processed:
      -- so if we still have tremoloside setup, it means no mangle happened as the
      -- mangle would have cleared it. Hence, make the venom timer go off at the
      -- earlist possible time.
      if sk.tremoloside and sk.tremoloside[side] and sk["delayvenom_"..side.."leg"] then
        killTimer(sk["delayvenom_"..side.."leg"])
        sk["delayvenom_"..side.."leg"] = nil
        -- we can't use valid here, but we can use addaff
        addaff(dict["crippled"..side.."leg"])

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        signals.canoutr:emit()
      end

      sk.tremoloside = nil
    end)
  end
end

function valid.voicecraft_vibrato(name, side)
  if not conf.aillusion or ((affs["crippled"..side.."arm"] or sk["delayvenom_"..side.."arm"] or sk["delayacciaccatura_"..side.."arm"]) and ((sk.swashbuckling_jab and last_jabber == name) or known_class == "bard")) then
    valid["simplemangled"..side.."arm"]()
  end
end

-- for a Bard tremolo/vibrato hit, avoid curing the crippled limb right away
-- because that will use up our salve balance and delay the mangled break, which
-- follows soon after. Hence this, upon detecting a jab form a Bard with
-- epteth/epseth, delays adding the crippled affliction until after the tremolo
-- or vibrato
function valid.swashbuckling_poison()
  if not conf.aillusion or (paragraph_length == 2 and not conf.batch) then
    for _, limb in ipairs{"rightleg", "rightarm", "leftarm", "leftleg"} do
      if actions["crippled"..limb.."_aff"] then
        killaction(dict["crippled"..limb].aff)

        sk["delayvenom_"..limb] = tempTimer(.25, function()
          if not affs["mangled"..limb] then
            addaff(dict["crippled"..limb])

            signals.after_lifevision_processing:unblock(cnrl.checkwarning)
            signals.canoutr:emit()
            make_gnomes_work()
          end

          sk["delayvenom_"..limb] = nil
        end)
        break
      end
    end
  end
end

function svo.valid.swashbuckling_acciaccatura(side, limb)
  local aff = side..limb

  sk["delayacciaccatura_"..aff] = tempTimer(.25, function()
    if not affs["mangled"..aff] then
      addaff(dict["crippled"..aff])

      signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      signals.canoutr:emit()
      make_gnomes_work()
    end

    sk["delayacciaccatura_"..aff] = nil
  end)
end

-- handle cancelling of delayvenom in case of this being a DSL:
-- apply the cripples right away, so the cure of a potential mangled limb in the
-- dsl, the venoms and the limb break get computed for cure at once on the prompt
signals.limbhit:connect(function(which, attacktype)
  if attacktype ~= "weapon" then return end

  sk.weapon_hits = (sk.weapon_hits or 0) + 1
  sk.onprompt_beforeaction_add("track a dsl", function()
    -- if we got a DSL, apply the delayvenoms right now
    if sk.weapon_hits == 2 then
      for _, aff in ipairs{"rightleg", "rightarm", "leftarm", "leftleg"} do
        if sk["delayvenom_"..aff] then
          if not affs["mangled"..aff] then
            addaff(dict["crippled"..aff])
            signals.after_lifevision_processing:unblock(cnrl.checkwarning)
            signals.canoutr:emit()
          end

          killTimer(sk["delayvenom_"..aff])
          sk["delayvenom_"..aff] = nil
        end
      end
    end

    sk.weapon_hits = nil
  end)
end)

function svo.valid.bloodleech()
  sk.bloodleech_hit = true
  sk.onprompt_beforeaction_add("unset bloodleech", function()
    sk.bloodleech_hit = nil
  end)
end

function svo.valid.defstrip(which)
  assert(which, "svo.valid.defstrip: which defence was stripped?")

  local t = {
    ["anti-weapon field"]      = 'rebounding',
    ["caloric salve"]          = 'caloric',
    ["cold resistance"]        = 'coldresist',
    ["density"]                = 'mass',
    ["electricity resistance"] = 'electricresist',
    ["fire resistance"]        = 'fireresist',
    ["gripping"]               = 'grip',
    ["held breath"]            = 'breath',
    ["insulation"]             = 'caloric',
    ["levitating"]             = 'levitation',
    ["magic resistance"]       = 'magicresist',
    ["scholasticism"]          = 'myrrh',
    ["soft focus"]             = 'softfocus',
    ["soft focusing"]          = 'softfocus',
    ["speed defence"]          = 'speed', -- typo in game was showing 'speed defence defence'
    ["temperance"]             = 'frost',
    ["third eye"]              = 'thirdeye',

    ["demon armour"]           = 'demonarmour',
    ["death aura"]             = 'deathaura',
  }

  if t[which] then which = t[which] end

  if defs["lost_"..which] then
    defs["lost_"..which]()
  end
end

function valid.truename()
  if not conf.aillusion then
    valid.simpleaeon()
    defs.lost_lyre()
  elseif (paragraph_length == 1 or (find_until_last_paragraph("is unable to resist the force of your faith", "substring") or find_until_last_paragraph("aura of weapons rebounding disappears", "substring"))) then
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, "truename")
    defs.lost_lyre()
  else
    ignore_illusion("not first")
  end
end

function valid.just_aeon()
  checkaction(dict.checkslows.aff, true)
  lifevision.add(actions.checkslows_aff.p, nil, "aeon")
end

function valid.proper_aeon()
  if defc.speed then
    defs.lost_speed()
  elseif not conf.aillusion then
    valid.simpleaeon()
  else
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, "aeon")
  end
end
valid.bashing_aeon = valid.proper_aeon

function valid.proper_retardation()
  if conf.aillusion then
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, "retardation")
  else
    valid.simpleretardation()
  end
end

function valid.proper_stun(num)
  if not conf.aillusion then
    valid.simplestun(num)
  else
    checkaction(dict.checkstun.aff, true)
    lifevision.add(actions.checkstun_aff.p, nil, num)
  end
end

function valid.proper_paralysis()
  -- if not conf.aillusion or (not (bals.balance and bals.equilibrium and bals.leftarm and bals.rightarm) or ignore.checkparalysis) then
  if not conf.aillusion or ignore.checkparalysis then
    valid.simpleparalysis()
  elseif not affs.paralysis then
    checkaction(dict.checkparalysis.aff, true)
    lifevision.add(actions.checkparalysis_aff.p)
  end

  if conf.paused and conf.hinderpausecolour then
    selectCurrentLine()
    fg(conf.hinderpausecolour)
    resetFormat()
    deselect()
  end
end

function valid.proper_hypersomnia()
  if not conf.aillusion or ignore.checkhypersomnia then
    valid.simplehypersomnia()
  elseif not affs.hypersomnia then
    checkaction(dict.checkhypersomnia.aff, true)
    lifevision.add(actions.checkhypersomnia_aff.p)
  end
end

function valid.proper_asthma()
  if not conf.aillusion or ignore.checkasthma then
    valid.simpleasthma()
    affsp.asthma = nil
  elseif not affs.asthma then
    checkaction(dict.checkasthma.aff, true)
    lifevision.add(actions.checkasthma_aff.p, nil, stats.currenthealth)
  end
end

function valid.proper_asthma_smoking()
  if conf.aillusion and paragraph_length <= 1 and not conf.batch then return end

  if not conf.aillusion or ignore.checkasthma then
    valid.simpleasthma()
    affsp.asthma = nil
  else
    checkaction(dict.checkasthma.aff, true)
    lifevision.add(actions.checkasthma_aff.p, nil, stats.currenthealth)
  end
end

function valid.darkshade_paralysis()
  if not conf.aillusion then
    valid.simpleparalysis()
    valid.simpledarkshade()
  else
    checkaction(dict.checkparalysis.aff, true)
    lifevision.add(actions.checkparalysis_aff.p, nil, "darkshade")
  end
end

function valid.darkshade_sun()
  checkaction(dict.darkshade.aff, true)
  if actions.darkshade_aff then
    lifevision.add(actions.darkshade_aff.p, nil, stats.currenthealth)
  end
end

function valid.maybe_impatience()
  checkaction(dict.checkimpatience.aff, true)
  lifevision.add(actions.checkimpatience_aff.p, nil, "quiet")
end

function valid.proper_impatience()
  if not conf.aillusion or ignore.checkimpatience then
    valid.simpleimpatience()
  else
     -- limerick because songbirds will make lg 2
     -- maggots isn't a full line, because on sw80 it will wrap
    local previousline = (find_until_last_paragraph("glares at you and your brain suddenly feels slower", "substring") or find_until_last_paragraph("evil eye", "substring") or find_until_last_paragraph("wracks", "substring") or find_until_last_paragraph("You recoil in horror as countless maggots squirm over your flesh", "substring") or line:find("jaunty limerick", 1, true) or find_until_last_paragraph("points an imperious finger at you", "substring") or find_until_last_paragraph("glowers at you with a look of repressed disgust before making a slight gesture toward you.", "substring") or find_until_last_paragraph("hand at you, a wash of cold causing your blood to evolve into something new.", "substring") or find_until_last_paragraph("Horror overcomes you as you realise that the curse of impatience", "substring")) and true or false
    if paragraph_length == 1 or previousline then
      checkaction(dict.checkimpatience.aff, true)
      if previousline then
        lifevision.add(actions.checkimpatience_aff.p)
      else
        lifevision.add(actions.checkimpatience_aff.p, nil, nil, 1)
      end
    else
      ignore_illusion("not first")
    end
  end
end

function valid.curse_dispel()
  if defc.ghost then defs.lost_ghost() return end
  if defc.shroud then defs.lost_shroud() return end
end

function valid.subterfuge_hallucinations()
  if getLineNumber("main") ~= lastpromptnumber+2 then return end
  valid.simplehallucinations()
end

function valid.subterfuge_confusion()
  if getLineNumber("main") ~= lastpromptnumber+2 then return end
  valid.simpleconfusion()
end

function valid.subterfuge_bite()
  -- should use affs.from field to track what did you get the venom from, then if it's confirmed, strip sileris
end

function valid.subterfuge_camus()
  checkaction(dict.sileris.gone, true)
  lifevision.add(actions.sileris_gone.p, "camusbite", stats.currenthealth)
end

function valid.subterfuge_sumac()
  checkaction(dict.sileris.gone, true)
  lifevision.add(actions.sileris_gone.p, "sumacbite", stats.currenthealth)
end

function valid.proper_relapsing()
  if not conf.aillusion then
    valid.simplerelapsing()
  else
    checkaction(dict.relapsing.aff, true)
    lifevision.add(actions.relapsing_aff.p)
  end
end

function valid.relapsing_camus()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "camus", stats.currenthealth)
end

function valid.relapsing_sumac()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "sumac", stats.currenthealth)
end

function valid.relapsing_vitality()
  dict.relapsing.aff.hitvitality = true
end

function valid.relapsing_oleander()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "oleander", (defc.blind or affs.blindaff))
end

function valid.relapsing_colocasia()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "colocasia", (defc.blind or affs.blindaff or defc.deaf or affs.deafaff))
end

function valid.relapsing_oculus()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "oculus", (defc.blind or affs.blindaff or defc.deaf or affs.deafaff))
end

function valid.relapsing_oculus()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "oculus", (defc.blind or affs.blindaff))
end

function valid.relapsing_prefarar()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "prefarar", (defc.deaf or affs.deafaff))
end

function valid.relapsing_asthma()
  checkaction(dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, "asthma")
end

function valid.subterfuge_bind()
  if not conf.aillusion or affs.sleep then
    valid.simplebound()
  end
end

function valid.kaido_choke()
  if conf.breath and conf.keepup and not defkeepup[defs.mode].breath then
    defs.keepup("breath", true)
    echo("\n")
    if math.random(1, 10) == 1 then
      echof("Run away! Run away! ('br' to turn off breath)")
    elseif math.random(1, 10) == 1 then
      echof("We'll get through this. *determined* ('br' to turn off breath)")
    else
      echof("Eep... holding our breath ('br' to turn off).")
    end
  end
end
valid.noose_trap = valid.kaido_choke
valid.vodun_throttle = valid.kaido

function valid.proper_sensitivity()
  checkaction(dict.sensitivity.aff, true)
  lifevision.add(actions.sensitivity_aff.p, "checkdeaf")
end

function valid.webbed_buckawns()
  if conf.buckawns then return
  else
    if not conf.aillusion then
      valid.simplewebbed()
    else
      checkaction(dict.checkwrithes.aff, true)
      lifevision.add(actions.checkwrithes_aff.p, nil, "webbed", 1)
    end
  end
end

function valid.proper_webbed()
  if not conf.aillusion then
    valid.simplewebbed()
  else
    checkaction(dict.checkwrithes.aff, true)
    lifevision.add(actions.checkwrithes_aff.p, nil, "webbed")
  end
end

function valid.proper_chill()
  local aff

  if defc.caloric then defs.lost_caloric() return end

  if not affs.shivering then aff = "shivering" else aff = "frozen" end

  checkaction(dict[aff].aff, true)
  if actions[aff .. "_aff"] then
    lifevision.add(actions[aff .. "_aff"].p)
  end
end

function valid.magi_deepfreeze()
  if defc.caloric then
    defs.lost_caloric()
    valid.simpleshivering()
  else
    valid.simpleshivering()
    valid.simplefrozen()
  end
end

-- logic is done inside receivers
function valid.proper_transfix()
  if not conf.aillusion or paragraph_length > 2 then
    valid.simpletransfixed()
  else
    checkaction(dict.checkwrithes.aff, true)
    lifevision.add(actions.checkwrithes_aff.p, nil, "transfixed")
  end
end

valid.proper_transfixed = valid.proper_transfix

function valid.failed_transfix()
  defs.lost_blind()

  if actions.transfixed_aff then
    killaction(dict.transfixed.aff)
  end
  if actions.checkwrithes_aff and lifevision.l.checkwrithes_aff and lifevision.l.checkwrithes_aff.arg == "transfixed" then
    killaction(dict.checkwrithes.aff)
  end
end

function valid.parry_limb(limb)
  if not sp_limbs[limb] then return end

  if find_until_last_paragraph("You feel your will manipulated by the soulmaster entity.", "exact") or find_until_last_paragraph("You cannot help but obey.", "exact") then
    checkaction(dict.doparry.physical, true)
  else
    checkaction(dict.doparry.physical)
  end

  if actions.doparry_physical then
    lifevision.add(actions.doparry_physical.p, nil, limb)
  end
end

function valid.parry_none()
  checkaction(dict.doparry.physical)
  if actions.doparry_physical then
    lifevision.add(actions.doparry_physical.p, "none")
  end
end

function valid.cant_parry()
  valid.parry_none()

  if not conf.aillusion then
    sk.cant_parry()
  else
    sk.unparryable_symptom()
  end
end

function valid.bad_legs()
  if affs.crippledrightleg or affs.crippledleftleg or affs.mangledleftleg or affs.mangledrightleg or affs.mutilatedrightleg or affs.mutilatedleftleg then return end

  valid.simpleunknownany()
end


for _, aff in ipairs({"hamstring", "galed", "voided", "inquisition", "burning", "icing", "phlogistication", "vitrification", "corrupted", "mucous", "rixil", "palpatar", "cadmus", "hecate", "ninkharsag", "swellskin", "pinshot", "dehydrated", "timeflux", "lullaby", "numbedleftarm", "numbedrightarm", "unconsciousness",
}) do
  valid[aff.."_woreoff"] = function()
    checkaction(dict[aff].waitingfor, true)
    if actions[aff.."_waitingfor"] then
      lifevision.add(actions[aff.."_waitingfor"].p)
    end
  end
end

function valid.stun_woreoff()
  -- not only stun, but checkstun maybe was waiting, didn't get to check -> needs to restore lifevision
  checkaction(dict.stun.waitingfor)
  if actions.stun_waitingfor then
    lifevision.add(actions.stun_waitingfor.p)
  elseif actions.checkstun_misc then
    lifevision.add(actions.checkstun_misc.p, nil, "fromstun")
  end
end

function valid.heartseed_cured()
  checkaction(dict.curingheartseed.waitingfor)
  if actions.curingheartseed_waitingfor then
    lifevision.add(actions.curingheartseed_waitingfor.p)
  end
end
function valid.hypothermia_cured()
  checkaction(dict.curinghypothermia.waitingfor)
  if actions.curinghypothermia_waitingfor then
    lifevision.add(actions.curinghypothermia_waitingfor.p)
  end
end

function valid.aeon_woreoff()
  local result = checkany(dict.aeon.smoke)

  if not result then
    if conf.aillusion and not passive_cure_paragraph and not find_until_last_paragraph("You touch the tree of life tattoo.", "exact") then
      checkaction(dict.aeon.gone, true)
      lifevision.add(actions.aeon_gone.p, nil, nil, 1)
    else
      -- clear the lineguard if we previously set it via aeon_gone
      if table.contains(lifevision.l:keys(), "aeon_gone") and lifevision.getlineguard() then
        lifevision.clearlineguard()
      end
      checkaction(dict.aeon.gone, true)
      lifevision.add(actions.aeon_gone.p)
    end
  else
    -- if it was a smoke cure, can't lineguard 1 then, it'll be 2
    smoke_cure = true
    lifevision.add(actions[result.name].p)
  end
end

function valid.destroy_retardation()
  checkaction(dict.retardation.gone, true)
  lifevision.add(actions.retardation_gone.p)

  valid.simpleaeon()
end

function valid.ablaze_woreoff()
  checkaction(dict.ablaze.gone, true)
  lifevision.add(actions.ablaze_gone.p)
end

function valid.wake_start()
  checkaction(dict.sleep.misc)
  if actions.sleep_misc then
    lifevision.add(actions.sleep_misc.p)
  end
end

function valid.wake_done()
  checkaction(dict.curingsleep.waitingfor, true)
  lifevision.add(actions.curingsleep_waitingfor.p)
end

function valid.symp_dizziness_fell()
  -- if not conf.aillusion then
    valid.simpledizziness()
    valid.simpleprone()
  -- elseif affs.dizziness then
  --   valid.simpleprone()
  -- end
end

function valid.cured_fear()
  checkaction(dict.fear.misc)
  if actions.fear_misc then
    lifevision.add(actions.fear_misc.p)
  end
end

function valid.tootired_focus()
  local r = findbybal("focus")
  if not r then return end

  focus_cure = true

  -- in case of double-applies, don't overwrite the first successful application
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "offbalance")
  end
end

function valid.mickey()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then ignore_illusion("not first") return end

  local r = findbybal("herb")
  if not r then return end

  lifevision.add(actions[r.name].p, "mickey")
end

function valid.focus_choleric()
  local r = findbybal("focus")
  if not r then ignore_illusion("Ignored the illusion because we aren't actually focusing right now (or we were forced).") return end

  checkaction(dict.stolebalance.happened, true)
  lifevision.add(actions.stolebalance_happened.p, nil, "focus")

  focus_cure = true
  killaction(dict[r.action_name].focus)
end

function valid.nomana_focus()
  local r = findbybal("focus")
  if not r then return end

  lifevision.add(actions[r.name].p, "nomana")
end

function valid.nomana_clot()
  checkaction(dict.bleeding.misc)
  if actions.bleeding_misc then
    lifevision.add(actions.bleeding_misc.p, "nomana")
  end
end

function valid.stoodup()
  checkaction(dict.prone.misc)
  if actions.prone_misc then
    lifevision.add(actions.prone_misc.p)
  end
end

function valid.sippedhealth()
  checkaction(dict.healhealth.sip)
  if actions.healhealth_sip then
    sip_cure = true
    lifevision.add(actions.healhealth_sip.p)
  end
end
function valid.sippedmana()
  checkaction(dict.healmana.sip)
  if actions.healmana_sip then
    sip_cure = true
    lifevision.add(actions.healmana_sip.p)
  end
end

function valid.gotherb()
  if not conf.aillusion or not sk.blockherbbal then
    checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "herb" -- hack to allow multiple balances at once
    lifevision.add(actions.gotbalance_happened.p)
    selectCurrentLine()
    setFgColor(0, 170, 0)
    deselect()
  else
    ignore_illusion("Couldnt've possibly recovered herb balance so soon - "..(watch.herb_block and getStopWatchTime(watch.herb_block) or '?').."s after eating.")
  end
end

function valid.gotmoss()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "moss" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
function valid.gotfocus()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "focus" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
function valid.gotsip()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "sip" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
function valid.gotpurgative()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "purgative" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
function valid.gotdragonheal()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "dragonheal" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
function valid.gotsmoke()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "smoke" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
function valid.gottree()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "tree" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function valid.gotsalve()
  if conf.aillusion and paragraph_length ~= 1 then
    local lastline = getLines(getLineNumber()-1, getLineNumber())[1]

    local lines = {
      ["Your left leg feels stronger and healthier."] = {affs = {"curingmutilatedrightleg", "curingmutilatedleftleg", "curingmangledrightleg", "curingmangledleftleg", "curingparestolegs"}, location = "legs"},
      ["Your right leg feels stronger and healthier."] = {affs = {"curingmutilatedrightleg", "curingmutilatedleftleg", "curingmangledrightleg", "curingmangledleftleg", "curingparestolegs"}, location = "legs"},
      ["Your left arm feels stronger and healthier."] = {affs = {"curingmutilatedrightarm", "curingmutilatedleftarm", "curingmangledrightarm", "curingmangledleftarm", "curingparestoarms"}, location = "arms"},
      ["Your right arm feels stronger and healthier."] = {affs = {"curingmutilatedrightarm", "curingmutilatedleftarm", "curingmangledrightarm", "curingmangledleftarm", "curingparestoarms"}, location = "arms"},
    }

    if lines[lastline] then
      local had
      for _, aff in ipairs(lines[lastline].affs) do
        if actions[aff.."_waitingfor"] then
          local afftime = getStopWatchTime(actions[aff.."_waitingfor"].p.actionwatch)
          if afftime >= conf.ai_minrestorecure then
            had = true; break
          else
            ignore_illusion(string.format("%s cure couldnt've possibly finished so soon, in %ss - minimum allowed is %ss. This seems like an illusion to trick you.", aff, afftime, conf.ai_minrestorecure))
            return
          end
        end
      end

      if not had then
        ignore_illusion("We aren't applying restoration to "..lines[lastline].location.." right now")
      end
    end
  end
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "salve" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function valid.gotpurgative()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "purgative" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function valid.forcesalve()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "salve" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function valid.forcefocus()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "focus" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function valid.forceherb()
  checkaction(dict.gotbalance.happened, true)
    dict.gotbalance.happened.tempmap[#dict.gotbalance.happened.tempmap+1] = "herb" -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function valid.got_rebounding()
  checkaction(dict.waitingonrebounding.waitingfor)
  if actions.waitingonrebounding_waitingfor then
    lifevision.add(actions.waitingonrebounding_waitingfor.p)
  end
end

function valid.rebounding_deathtarot()
  checkaction(dict.waitingonrebounding.waitingfor, false)
  if actions.waitingonrebounding_waitingfor then
    lifevision.add(actions.waitingonrebounding_waitingfor.p, "deathtarot")
  end
end

-- palpatar line will be before this if you've had it
function defs.got_speed()
  checkaction(dict.curingspeed.waitingfor)
  if actions.curingspeed_waitingfor then
    lifevision.add(actions.curingspeed_waitingfor.p)
  end
end

function valid.bled(howmuch)
  local amount = tonumber(howmuch)

  checkaction(dict.bleeding.aff, true)
  if actions.bleeding_aff then
    lifevision.add(actions.bleeding_aff.p, nil, amount)
  end

  if affs.unknownany and stats.hp == 100 and stats.mana == 100 then
    valid.simplerecklessness()
  end
end

function valid.clot1()
  checkaction(dict.bleeding.misc)
  if actions.bleeding_misc then
    lifevision.add(actions.bleeding_misc.p)
  end

  if conf.gagclot and not sys.sync then deleteLineP() end
end

function valid.clot2()
  checkaction(dict.bleeding.misc)
  if actions.bleeding_misc then
    lifevision.add(actions.bleeding_misc.p, "oncured")
  end

  if conf.gagclot and not sys.sync then deleteLineP() end
end

function valid.symp_haemophilia()
  if not conf.aillusion and actions.bleeding_misc then
    valid.remove_unknownany("haemophilia")
    valid.simplehaemophilia()
  else
    checkaction(dict.bleeding.misc, false)
    if actions.bleeding_misc then
      valid.remove_unknownany("haemophilia")
      lifevision.add(actions.bleeding_misc.p, "haemophilia", nil, 1)
    elseif not affs.haemophilia then
      ignore_illusion("Ignored this illusion because we aren't trying to clot right now (or we were forced).")
    end
  end
end

function valid.proper_haemophilia()
  if not conf.aillusion then
    valid.simplehaemophilia()
  elseif find_until_last_paragraph("wracks", "substring") and paragraph_length >= 3 then
    valid.simplehaemophilia()
  elseif find_until_last_paragraph("glowers at you with a look of repressed disgust", "substring") or find_until_last_paragraph("stares menacingly at you, its eyes flashing brightly.", "substring") then
    valid.simplehaemophilia()
  elseif find_until_last_paragraph("points an imperious finger at you.", "substring") then
    -- shamanism
    valid.simplehaemophilia()
  elseif find_until_last_paragraph("makes a quick, sharp gesture toward you.", "substring") then
    -- occultism instill
    valid.simplehaemophilia()
  elseif line:starts("A bloodleech leaps at you, clamping with teeth onto exposed flesh and secreting some foul toxin into your bloodstream. You stumble as you are afflicted") then
    -- domination bloodleech
    valid.simplehaemophilia()
  else
    ignore_illusion("Doesn't seem to be an Alchemist wrack or Occultism instill - going to see if it's real off symptoms.")
  end
end

function valid.humour_wrack()
  checkaction(dict.unknownany.aff, true)
  lifevision.add(actions["unknownany_aff"].p, "wrack", nil)

  -- to check if we got reckless!
  if stats.currenthealth ~= stats.maxhealth then
    dict.unknownany.reckhp = true end
  if stats.currentmana ~= stats.maxmana then
    dict.unknownany.reckmana = true end
end

-- detect how many wracks (of the 2 available in a truewrack) were hidden (that is - humour-based wrack, which is hidden)
-- vs affliction-based wrack, which is visible
function valid.humour_truewrack()
  local sawaffs = 0
  for _, action in pairs(lifevision.l:keys()) do
    if action:find("_aff", 1, true) then
      sawaffs = sawaffs + 1
    end
  end

  -- limit to 2 in case we saw more - we don't want to add more than 2 unknowns
  if sawaffs > 2 then sawaffs = 2 end

  -- add the appropriate amount of missing unknowns, up to 2. If we saw an affliction, don't add an unknown for it.
  for i = 1, 2-sawaffs do
    valid.simpleunknownany()
  end
end

function valid.got_humour(which)
  assert(dict[which.."humour"], "svo.valid.got_humour: which humour to add?")

  local function countaffs(humour)
    local affs_in_a_humour = 3

    local t = {
      choleric    = {"illness", "sensitivity", "slickness"},
      melancholic = {"anorexia", "impatience", "stupidity"},
      phlegmatic  = {"asthma", "clumsiness", "disloyalty"},
      sanguine    = {"haemophilia", "recklessness",  "paralysis"}
    }

    -- add the amount of focusables in a humour as the 4th argument, to check for as well
    for humour, data in pairs(t) do
      local focusables_in_humour = 0
      for i = 1, affs_in_a_humour do
        if dict[data[i]].focus then focusables_in_humour = focusables_in_humour + 1 end
      end
      data[affs_in_a_humour+1] = focusables_in_humour
    end

    -- update temper count according to known humour-related affs we've got
    local count = 0
    for i = 1, affs_in_a_humour do
      if affs[t[humour][i]] then count = count + 1 end
    end

    -- update temper count according to unknown focusable affs we've got, limited by the max
    -- amount of focusable affs we can have
    if affs.unknownmental then
      local max_focusable_affs_in_humour = t[humour][affs_in_a_humour+1]
      count = count + (dict.unknownmental.count > max_focusable_affs_in_humour and max_focusable_affs_in_humour or dict.unknownmental.count)
    end

    -- and lastly, unknown affs
    if affs.unknownany then
      count = count + dict.unknownany.count
    end

    return count
  end

  -- humours give up to 3 levels in one go, depending on which relevant afflictions have you got. account for unknown afflictions as well!
  -- 1 for the temper, + any more affs
  local humourlevels = 1 + countaffs(which)
  -- trim the max we counted down to 3, which is the most possible right now
  if humourlevels > 3 then humourlevels = 3 end

  checkaction(dict[which.."humour"].aff, true)
  lifevision.add(actions[which.."humour_aff"].p, nil, humourlevels)
end

function valid.sanguine_inundate()
  checkaction(dict.sanguinehumour.herb, true)
  if actions.sanguinehumour_herb then
    lifevision.add(actions.sanguinehumour_herb.p, "inundated")
  end
end

function valid.choleric_inundate()
  checkaction(dict.cholerichumour.herb, true)
  if actions.cholerichumour_herb then
    lifevision.add(actions.cholerichumour_herb.p, "inundated")
  end
end

function valid.melancholic_inundate()
  checkaction(dict.melancholichumour.herb, true)
  if actions.melancholichumour_herb then
    lifevision.add(actions.melancholichumour_herb.p, "inundated")
  end
end

function valid.phlegmatic_inundate()
  checkaction(dict.phlegmatichumour.herb, true)
  if actions.phlegmatichumour_herb then
    lifevision.add(actions.phlegmatichumour_herb.p, "inundated")
  end
end

function valid.skullfractures_apply()
  applyelixir_cure = true

  checkaction(dict.skullfractures.sip, true)
  lifevision.add(actions.skullfractures_sip.p)
end

function valid.skullfractures_cured()
  applyelixir_cure = true

  checkaction(dict.skullfractures.sip, true)
  lifevision.add(actions.skullfractures_sip.p, "cured")
end
function valid.crackedribs_apply()
  applyelixir_cure = true

  checkaction(dict.crackedribs.sip, true)
  lifevision.add(actions.crackedribs_sip.p)
end

function valid.crackedribs_cured()
  applyelixir_cure = true

  checkaction(dict.crackedribs.sip, true)
  lifevision.add(actions.crackedribs_sip.p, "cured")
end
function valid.wristfractures_apply()
  applyelixir_cure = true

  checkaction(dict.wristfractures.sip, true)
  lifevision.add(actions.wristfractures_sip.p)
end

function valid.wristfractures_cured()
  applyelixir_cure = true

  checkaction(dict.wristfractures.sip, true)
  lifevision.add(actions.wristfractures_sip.p, "cured")
end
function valid.torntendons_apply()
  applyelixir_cure = true

  checkaction(dict.torntendons.sip, true)
  lifevision.add(actions.torntendons_sip.p)
end

function valid.torntendons_cured()
  applyelixir_cure = true

  checkaction(dict.torntendons.sip, true)
  lifevision.add(actions.torntendons_sip.p, "cured")
end

function valid.tarot_aeon()
  -- speed -can- be stripped in blackout
  -- if conf.aillusion and defc.speed and not actions.speed_gone and paragraph_length <= 2 then return end

  if not conf.aillusion or paragraph_length > 2 then
    valid.simpleaeon()
  else
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, "aeon")
  end
end

function valid.refilled(what)
  local shortname = es_shortnamesr[what]
  if not shortname or es_categories[what] == "venom" then return end

  if es_potions[es_categories[what]][what].sips == 0 then
    es_potions[es_categories[what]][what].sips = es_potions[es_categories[what]][what].sips + 50
    es_potions[es_categories[what]][what].vials = es_potions[es_categories[what]][what].vials + 1
    echo"\n" echof("We refilled %s - will use it for cures now.", what)
  end
end

function valid.missing_herb()
  if actions.checkstun_misc then
    deleteLineP()
    lifevision.add(actions.checkstun_misc.p, "onclear")
  end

  -- don't echo anything for serverside failing to eat a herb
  if conf.serverside then return end

  local eating = findbybals ({"herb", "moss"})
  if not eating then return end
  local action = select(2, next(eating))
  eating = next(eating)

  if sys.last_used[eating] then
    rift.invcontents[sys.last_used[eating]] = 0

    -- echo only if temporarily ran out and have more in rift
    if rift.riftcontents[sys.last_used[eating]] ~= 0 and sys.canoutr then
      echo"\n" echof("(don't have %s in inventory for %s as I thought)", sys.last_used[eating], action.action_name)
    end
    -- SHOULD cancel action, but that can also cause us to get into an infinite loop of eating nothing
    -- needs to be fixed after better herb tracking
  end
end

function valid.symp_anorexia()
  if not conf.aillusion then -- ai is off? go-ahead then
    valid.simpleanorexia()
    return
  end

  local eating = findbybal ("herb")
  if eating then
    valid.simpleanorexia()
    killaction(dict[eating.action_name].herb)
  elseif findbybals({"sip", "purgative", "herb", "moss"}) then
    valid.simpleanorexia()
  elseif actions.checkanorexia_misc then
    lifevision.add(actions.checkanorexia_misc.p, "blehfood")
  end
end

function valid.salve_fizzled(limb)
  local r = checkany(dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.unknowncrippledlimb.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve)
  if not r then return end

  apply_cure = true

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "fizzled", limb)
  end
end

function valid.health_fizzled()
  local r = checkany(dict.skullfractures.sip, dict.crackedribs.sip, dict.wristfractures.sip, dict.torntendons.sip)
  if not r then return end

  applyelixir_cure = true

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "fizzled")
  end
end

function valid.health_noeffect()
  local r = checkany(dict.skullfractures.sip, dict.crackedribs.sip, dict.wristfractures.sip, dict.torntendons.sip)
  if not r then return end

  applyelixir_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "noeffect")
  end
end

-- this can happen on a restore or a mending application
-- handle upgrading of the limb
function valid.update_break(limb)
  local r = checkany(dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.unknowncrippledlimb.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve)
  if not r and not actions.restore_physical then return end

  if actions.restore_physical then
    if not affs["mangled"..limb] then
      valid.simple["mangled"..limb]()
    end
  else
    apply_cure = true
    if not lifevision.l[r.name] then
      lifevision.add(actions[r.name].p, "fizzled", limb)
    end
  end
end

function valid.salve_offbalance()
  local r = findbybal("salve")
  if not r then return end

  apply_cure = true

  -- in case of double-applies, don't overwrite the first successful application
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "offbalance")
  end
end

function valid.force_aeon()
  vaff("aeon")
end

function valid.herb_cured_insomnia()
  local r = checkany(dict.dissonance.herb, dict.impatience.herb, dict.stupidity.herb, dict.dizziness.herb, dict.epilepsy.herb, dict.shyness.herb)
  if conf.aillusion and not (r or find_until_last_paragraph("You feel irresistibly compelled", "substring") or find_until_last_paragraph("You cannot help but obey.", "exact")) then ignore_illusion("We aren't eating goldenseal at the moment.") return end

  if r then
    killaction(dict[r.action_name].herb)
  end

  defs.lost_insomnia()
  lostbal_herb()

  if r then
    checkaction(dict[r.action_name].gone, true)
    lifevision.add(actions[r.action_name.."_gone"].p)
  end

  checkaction(dict.checkimpatience.misc, true)
  lifevision.add(actions.checkimpatience_misc.p, "onclear")
end

function valid.fillskullcap()
  checkaction(dict.fillskullcap.physical)
  if actions.fillskullcap_physical then
    lifevision.add(actions.fillskullcap_physical.p)
  end
end

function valid.fillelm()
  checkaction(dict.fillelm.physical)
  if actions.fillelm_physical then
    lifevision.add(actions.fillelm_physical.p)
  end
end

function valid.fillvalerian()
  checkaction(dict.fillvalerian.physical)
  if actions.fillvalerian_physical then
    lifevision.add(actions.fillvalerian_physical.p)
  end
end

function valid.alreadyfull()
  local result = checkany(dict.fillskullcap.physical, dict.fillelm.physical, dict.fillvalerian.physical)

  if not result then return end

  lifevision.add(actions[result.name].p)
end

function valid.litpipe(gag2)
  if not sys.sync then
    if conf.gagrelight then deleteLineP() end
    if conf.gagrelight and gag2 then deleteLine() end
  end

  local result = checkany(
    dict.lightelm.physical, dict.lightvalerian.physical, dict.lightskullcap.physical)

  if not result then return end
  lifevision.add(actions[result.name].p)
end

function valid.litallpipes()
  if not sys.sync and conf.gagrelight then deleteLineP() end

  checkaction(dict.lightpipes.physical)
  if actions.lightpipes_physical then
    lifevision.add(actions.lightpipes_physical.p)
  end
end

herb_cure = false
 -- reset the flag tracking whenever we got a cure for what we ate (herb_cure) at the start
function valid.ate1()
  if paragraph_length == 1 then
    herb_cure = false
  end

  -- see if we need to enable arena mode for some reason
  local t = sk.arena_areas
  local area = atcp.RoomArea or (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.area)
  if area and t[area] and not conf.arena then
    conf.arena = true
    raiseEvent("svo config changed", "arena")
    prompttrigger("arena echo", function()
      echo'\n'echof("Looks like you're actually in the arena - enabled arena mode.\n") showprompt()
    end)
  end

  -- check anti-illusion with GMCP's herb removal
  if conf.aillusion and not conf.arena and not affs.dementia and sys.enabledgmcp and not sk.removed_something and not find_until_last_paragraph("You feel irresistibly compelled", "substring") and not find_until_last_paragraph("You cannot help but obey.", "exact") then
    -- let nicer tooltips come first before this one
    aiprompt("nothing removed, but ate", function() ignore_illusion("We didn't eat that!", true) end)
  end

  -- check if we need to add or remove addiction - but not if we are ginseng/ferrum as that doesn't go off on addiction
  if (not conf.aillusion or findbybal("herb")) and not find_until_last_paragraph("ginseng root", "substring") and not find_until_last_paragraph("ferrum flake", "substring") then
    sk.onprompt_beforelifevision_add("add/remove addiction", function()
      if not affs.addiction and find_until_last_paragraph("Your addiction can never be sated.", "exact") then
        valid.simpleaddiction()
      elseif affs.addiction and not find_until_last_paragraph("Your addiction can never be sated.", "exact") then
        checkaction(dict.addiction.gone, true)
        lifevision.add(actions.addiction_gone.p)
      end
    end)
  end
end

-- see if the herb we ate actually cured us: if no, register the herb eating action as 'empty'
function valid.ate2()
  -- cadmus comes on the next line after
  tempLineTrigger(1,1,[[
    if line == "The vile curse of Cadmus leaves you." then
      svo.valid.cadmus_woreoff()
    end
  ]])

  -- if it's addition or swellskin stretching the eating - don't go off now, but on the next one
  if line == "Your addiction can never be sated." or line == "Eating is suddenly less difficult again." then return end

  if not herb_cure then
    local eating = findbybal("herb")
    if not eating then return end

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions[eating.name].p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    -- addiction needs to stretch the lineguard to 2, since it is You eat/Your addiction/prompt.
    -- [Curing] does not show up for find_until_last_paragraph when it is gagged, so track it otherwise
    if conf.aillusion then
      lifevision.add(actions[eating.name].p, "empty", nil, ((find_until_last_paragraph("Your addiction can never be sated.", "exact") or find_until_last_paragraph("Eating is suddenly less difficult again.", "exact") or sk.sawcuringcommand) and 2 or 1))
    else
      lifevision.add(actions[eating.name].p, "empty")
    end
  end

  herb_cure = false
end

local sip_cure = false

function valid.sip1()
  sip_cure = false
end

function valid.sip2()
  if not sip_cure then
  local sipping = findbybal("purgative")

  if not sipping then
    -- special case for speed, which is a sip but balanceless
    if doingaction"speed" then
      lifevision.add(actions.speed_purgative.p)
    end
  return end

    lifevision.add(actions[sipping.name].p, "empty")
  end

  sip_cure = false
end

local tree_cure = false

function valid.tree1()
  tree_cure = false
end

function valid.tree2()
  if not tree_cure then
    if conf.aillusion and not actions.touchtree_misc then
      ignore_illusion("We aren't actually touching tree right now (or we were forced).", true)
      return
    end

    -- prevent against a well-timed tree illusion, which when empty, forces us to clear all afflictions
    if conf.aillusion then
      local time, lat = getStopWatchTime(actions.touchtree_misc.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    checkaction(dict.touchtree.misc, true)

    -- add it anyway, as the illusion could get cancelled later on
    lifevision.add(actions.touchtree_misc.p, "empty")
  end

  tree_cure = false
end

apply_cure = false

function valid.apply1()
  apply_cure = false
end

function valid.apply2()
  if not apply_cure then
  local r = findbybal("salve")
  if not r then return end

    lifevision.add(actions[r.name].p, "empty")
  end

  apply_cure = false
end

smoke_cure = false

function valid.smoke1()
  smoke_cure = false
end

function valid.smoke2()
  if not smoke_cure then
    local r = findbybal("smoke")
    if r then
      lifevision.add(actions[r.name].p, "empty")
    elseif actions.checkasthma_smoke then
      lifevision.add(actions.checkasthma_smoke.p, "onclear")
    end
  end

  smoke_cure = false
end

applyelixir_cure = false

function valid.applyelixir1()
  applyelixir_cure = false
end

function valid.applyelixir2()
  if not applyelixir_cure then
    local r = findbybal("sip")
    if not r then return end

      lifevision.add(actions[r.name].p, "empty")
  end

  applyelixir_cure = false
end

focus_cure = false

-- note: rixil fading will be inbetween here
function valid.focus1()
  focus_cure = false
end

-- this should go off on the line where a focus cure would have otherwise seen
function valid.focus2()
  -- ignore spirit disrupt tick and affliction lines, as they will trigger an 'empty'
  local spiritdisrupt = {
    "The elemental energy about you fluctuates.",
    "Your throat grows suddenly dry.",
    "Your skin begins to grow uncomfortably hot.",
    "A sudden feeling of nausea overtakes you.",
    "Your lungs suddenly constrict and dizziness overtakes you."
  }

  if table.contains(spiritdisrupt, line) then return end

  if actions.checkimpatience_misc then
    lifevision.add(actions.checkimpatience_misc.p, "onclear")
  end

  if not focus_cure then
    focus_cure = false

    local r = findbybal("focus")

    if not r then return end

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions[r.name].p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions[r.name].p, "empty")
  end
end

function valid.salve_had_no_effect()
  local r = findbybal("salve")
  if not r then return end

  apply_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "noeffect")
  end
end

function valid.plant_had_no_effect()
  local r = findbybal("herb")
  if not r then return end

  herb_cure = true

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "noeffect")
  end
end

function valid.salve_slickness()
  local r = findbybal("salve")
  if not r then return end

  apply_cure = true
  valid.simpleslickness()
  killaction(dict[r.action_name].salve)
end

function valid.potion_slickness()
  local r = findbybal("salve")
  if not r then return end

  apply_cure = true
  valid.simpleslickness()
  killaction(dict[r.action_name].salve)
end

function valid.sip_had_no_effect()
  local function kill(r)
    sip_cure = true
    if not lifevision.l[r.name] then
      lifevision.add(actions[r.name].p, "noeffect")
    end
  end

  local r = findbybal("sip")
  if r then kill(r) else
    r = findbybal("purgative")
    if not r then return end

    kill(r)
  end
end

function valid.removed_from_rift()
  -- we're only interested in this while in sync mode
  if not sys.sync then return end

  local eating = findbybal("herb")
  if eating then killaction(eating) return end

  local outring = findbybal("physical")
  if outring then killaction(outring) end
end
signals.removed_from_rift:connect(valid.removed_from_rift)

function valid.no_refill_herb()
  for _, herb in ipairs{"elm", "valerian", "skullcap"} do
    if actions["fill"..herb.."_physical"] then
      rift.invcontents[pipes[herb].filledwith] = 0
      killaction(dict["fill"..herb].physical)
    end
  end
end

function valid.no_outr_herb(what)
  assert(what, "svo.valid.no_outr_herb: requires a single argument")
  if actions.doprecache_misc and rift.precache[what] ~= 0 and rift.riftcontents[what] ~= 0 and (rift.invcontents[what] < rift.precache[what]) then
    rift.riftcontents[what] = 0
    echo"\n" echof("Apparently we're out of %s! Can't precache it.", what)
  else
    local eating = findbybals ({"herb", "moss", "misc"})
    if not eating then
      -- check pipes instead
      local r = checkany(dict.fillskullcap.physical, dict.fillelm.physical, dict.fillvalerian.physical)

      if not r then return end

      rift.riftcontents[sys.last_used[r.name]] = 0
      return
    end

    local action = select(2, next(eating))
    eating = next(eating)

    -- check against what we actually ate as well in case of overlaps (ie sileris/irid)
    if sys.last_used[eating] and what:find(sys.last_used[eating]) then
      local eaten = sys.last_used[eating]
      rift.riftcontents[eaten] = 0

      local alternative
      if action.eatcure[1] == eaten then alternative = action.eatcure[2]
      else alternative = action.eatcure[1] end

      echo'\n' echof("Don't have %s, will try %s next time.", eaten, alternative)

      if rift.riftcontents[alternative] <= 0 then
        rift.riftcontents[alternative] = 1
      end
    end
  end
end

function valid.cureddisrupt()
  checkaction(dict.disrupt.misc)
  if actions.disrupt_misc then
    lifevision.add(actions.disrupt_misc.p)
  end
end


function valid.failed_focus_impatience()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then ignore_illusion("not first") return end
  local r = findbybal("focus")
  if r or not conf.aillusion or actions.checkimpatience_misc then
    if r then killaction(dict[r.action_name].focus) end

    if actions.checkimpatience_misc then
      lifevision.add(actions.checkimpatience_misc.p, "impatient", nil, 1)
    else
      valid.simpleimpatience()
    end
  -- don't show a false (i) when we already know we've got impatience
  elseif conf.aillusion and not affs.impatience then
    ignore_illusion("Not actually trying to focus right now (or we were forced).")
  end
end

function valid.smoke_failed_asthma()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then ignore_illusion("not first") return end

  if actions.checkasthma_smoke then
    lifevision.add(actions.checkasthma_smoke.p, "badlungs", nil, 1)
  end

  local r = findbybal("smoke")
  if r or not conf.aillusion then

    if not affs.asthma then
      checkaction(dict.asthma.aff, true)
      lifevision.add(actions["asthma_aff"].p, nil, nil, 1)
      affsp.asthma = nil
    end
  elseif conf.aillusion and not affs.asthma then -- don't show (i) on delays + already have valid asthma
    ignore_illusion("Not actually trying to smoke anything right now (or we were forced).")
  end
end

function valid.got_mucous()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then ignore_illusion("not first") return end

  if actions.checkasthma_smoke then
    lifevision.add(actions.checkasthma_smoke.p, "mucous", nil, 1)
  end

  local r = findbybal("smoke")
  if r or not conf.aillusion then

    if not affs.mucous then
      checkaction(dict.mucous.aff, true)
      lifevision.add(actions["mucous_aff"].p, nil, nil, 1)
    end
  elseif conf.aillusion then
    ignore_illusion("Not actually trying to smoke anything right now (or we were forced).")
  end
end

function valid.have_mucous()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then ignore_illusion("not first") return end

  local r = findbybal("smoke")
  if r or not conf.aillusion then

    if not affs.mucous then
      checkaction(dict.mucous.aff, true)
      lifevision.add(actions["mucous_aff"].p, nil, nil, 1)
    end
  elseif conf.aillusion then
    ignore_illusion("Not actually trying to smoke anything right now (or we were forced).")
  end
end

function valid.unlit_pipe()
  local r = findbybal("smoke")
  if not r then return end

  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then
    ignore_illusion("not first")
    return
  end

  if type(dict[r.action_name].smoke.smokecure) == "string" then
    pipes[dict[r.action_name].smoke.smokecure].lit = false
    show_info("unlit "..dict[r.action_name].smoke.smokecure, "Apparently the "..dict[r.action_name].smoke.smokecure.." pipe was out")
    killaction(dict[r.action_name].smoke)
  elseif type(dict[r.action_name].smoke.smokecure) == "table" then
    for _, herb in pairs(dict[r.action_name].smoke.smokecure) do
      if pipes[herb] and pipes[herb].lit then
        pipes[herb].lit = false
        show_info("unlit "..herb, "Apparently the "..herb.." pipe was out")
        if pipes[herb].arty then
          pipes[herb].arty = false
          show_info("not an artefact", "It's not an artefact pipe, either. I've made it be a normal one for you")
        end
        killaction(dict[r.action_name].smoke)
      end
    end
  end
end

function valid.necromancy_shrivel()
  valid["simplecrippled"..matches[2]..matches[3]]()
end

function valid.got_aeon()
  if conf.aillusion and not defc.speed then
    valid.simpleaeon()
  elseif not conf.aillusion then
    if not conf.aillusion then
      valid.simpleaeon()
    else
      checkaction(dict.checkslows.aff, true)
      lifevision.add(actions.checkslows_aff.p, nil, "aeon")
    end

    defs.lost_speed()
  end
end

function valid.empty_pipe()
  local r = findbybal("smoke")
  if not r then
    if conf.aillusion and not (actions.fillskullcap_physical or actions.fillelm_physical or actions.fillvalerian_physical)
      then ignore_illusion("Not actually trying to smoke anything right now (or we were forced).") end
    return
  end

  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then
    ignore_illusion("not first")
    return
  end

-- TODO: turn this into a dict. action validated by lifevision w/ a lifeguard
  if type(dict[r.action_name].smoke.smokecure) == "string" then
    pipes[dict[r.action_name].smoke.smokecure].puffs = 0
  elseif type(dict[r.action_name].smoke.smokecure) == "table" then
    for _, herb in pairs(dict[r.action_name].smoke.smokecure) do
      if pipes[herb] and pipes[herb].puffs then
        pipes[herb].puffs = 0
      end
    end
  end

  killaction(dict[r.action_name].smoke)

  if dict[r.action_name].smoke.smokecure[1] == "valerian" and not (bals.balance and bals.equilibrium) then
    sk.warn("emptyvalerianpipe")
  end
end

function valid.pipe_emptied()
  local r = checkany(dict.fillskullcap.physical, dict.fillelm.physical, dict.fillvalerian.physical)

  if not r then return end

  if dict[r.action_name].fillingid == pipes[dict[r.action_name].physical.herb].id then
    pipes[dict[r.action_name].physical.herb].puffs = 0
  else
    pipes[dict[r.action_name].physical.herb].puffs2 = 0
  end

  if sys.sync then
    killaction(dict[r.action_name].physical)
  end
end

function valid.empty_light()
  local r = checkany(dict.lightskullcap.physical, dict.lightelm.physical, dict.lightvalerian.physical)

  if not r then return end

  if dict[r.action_name].fillingid == pipes[dict[r.action_name].physical.herb].id then
    pipes[dict[r.action_name].physical.herb].puffs = 0
  else
    pipes[dict[r.action_name].physical.herb].puffs2 = 0
  end
  killaction(dict[r.action_name].physical)
end

-- bindings
function valid.writhedbound()
  if not affs.bound then return end

  local result = checkany(dict.curingbound.waitingfor, dict.curingwebbed.waitingfor, dict.curingroped.waitingfor, dict.curingtransfixed.waitingfor, dict.curingimpale.waitingfor, dict.curinghoisted.waitingfor)

  if not result then return end

  -- if we were writhing what we expected from to writhe, continue
  if actions.curingbound_waitingfor then
    lifevision.add(dict.curingbound.waitingfor)
  -- otherwise if we writhed from something we were not - kill if we were doing anything else and add the new
  else
    killaction(dict[result.action_name].waitingfor)
    checkaction(dict.curingbound.waitingfor, true)
    lifevision.add(dict.curingbound.waitingfor)
  end
end
function valid.writhedwebbed()
  if not affs.webbed then return end

  local result = checkany(dict.curingbound.waitingfor, dict.curingwebbed.waitingfor, dict.curingroped.waitingfor, dict.curingtransfixed.waitingfor, dict.curingimpale.waitingfor, dict.curinghoisted.waitingfor)

  if not result then return end

  -- if we were writhing what we expected from to writhe, continue
  if actions.curingwebbed_waitingfor then
    lifevision.add(dict.curingwebbed.waitingfor)
  -- otherwise if we writhed from something we were not - kill if we were doing anything else and add the new
  else
    killaction(dict[result.action_name].waitingfor)
    checkaction(dict.curingwebbed.waitingfor, true)
    lifevision.add(dict.curingwebbed.waitingfor)
  end
end
function valid.writhedroped()
  if not affs.roped then return end

  local result = checkany(dict.curingbound.waitingfor, dict.curingwebbed.waitingfor, dict.curingroped.waitingfor, dict.curingtransfixed.waitingfor, dict.curingimpale.waitingfor, dict.curinghoisted.waitingfor)

  if not result then return end

  -- if we were writhing what we expected from to writhe, continue
  if actions.curingroped_waitingfor then
    lifevision.add(dict.curingroped.waitingfor)
  -- otherwise if we writhed from something we were not - kill if we were doing anything else and add the new
  else
    killaction(dict[result.action_name].waitingfor)
    checkaction(dict.curingroped.waitingfor, true)
    lifevision.add(dict.curingroped.waitingfor)
  end
end
function valid.writhedtransfixed()
  if not affs.transfixed then return end

  local result = checkany(dict.curingbound.waitingfor, dict.curingwebbed.waitingfor, dict.curingroped.waitingfor, dict.curingtransfixed.waitingfor, dict.curingimpale.waitingfor, dict.curinghoisted.waitingfor)

  if not result then return end

  -- if we were writhing what we expected from to writhe, continue
  if actions.curingtransfixed_waitingfor then
    lifevision.add(dict.curingtransfixed.waitingfor)
  -- otherwise if we writhed from something we were not - kill if we were doing anything else and add the new
  else
    killaction(dict[result.action_name].waitingfor)
    checkaction(dict.curingtransfixed.waitingfor, true)
    lifevision.add(dict.curingtransfixed.waitingfor)
  end
end
function valid.writhedimpale()
  if not affs.impale then return end

  local result = checkany(dict.curingbound.waitingfor, dict.curingwebbed.waitingfor, dict.curingroped.waitingfor, dict.curingtransfixed.waitingfor, dict.curingimpale.waitingfor, dict.curinghoisted.waitingfor)

  if not result then return end

  -- if we were writhing what we expected from to writhe, continue
  if actions.curingimpale_waitingfor then
    lifevision.add(dict.curingimpale.waitingfor)
  -- otherwise if we writhed from something we were not - kill if we were doing anything else and add the new
  else
    killaction(dict[result.action_name].waitingfor)
    checkaction(dict.curingimpale.waitingfor, true)
    lifevision.add(dict.curingimpale.waitingfor)
  end
end
function valid.writhedhoisted()
  if not affs.hoisted then return end

  local result = checkany(dict.curingbound.waitingfor, dict.curingwebbed.waitingfor, dict.curingroped.waitingfor, dict.curingtransfixed.waitingfor, dict.curingimpale.waitingfor, dict.curinghoisted.waitingfor)

  if not result then return end

  -- if we were writhing what we expected from to writhe, continue
  if actions.curinghoisted_waitingfor then
    lifevision.add(dict.curinghoisted.waitingfor)
  -- otherwise if we writhed from something we were not - kill if we were doing anything else and add the new
  else
    killaction(dict[result.action_name].waitingfor)
    checkaction(dict.curinghoisted.waitingfor, true)
    lifevision.add(dict.curinghoisted.waitingfor)
  end
end

function valid.writhe()
  local result = checkany(dict.bound.misc, dict.webbed.misc, dict.roped.misc, dict.transfixed.misc, dict.hoisted.misc, dict.impale.misc)

  if not result then return end
  if actions[result.name] then
    lifevision.add(actions[result.name].p)
  end
end


function valid.writheimpale()
  local result = checkany(dict.impale.misc, dict.transfixed.misc, dict.webbed.misc, dict.roped.misc, dict.hoisted.misc, dict.bound.misc)

  if not result then return end

  if result.name == "impale_misc" then
    lifevision.add(actions[result.name].p)
  else
    lifevision.add(actions[result.name].p, "impale")
  end
end

function valid.writhe_helpless()
  local result = checkany(dict.bound.misc, dict.webbed.misc, dict.roped.misc, dict.impale.misc, dict.transfixed.misc, dict.hoisted.misc)

  if not result then ignore_illusion("We aren't actually writhing from anything right now (or we were forced).") return end
  if actions[result.name] then
    lifevision.add(actions[result.name].p, "helpless")
  end
end

-- restoration cures


function valid.curingmutilatedrightarm()
  local result = checkany(dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

  if not result then return end

  if result.name == "curingmutilatedrightarm_waitingfor" then
    lifevision.add(actions["curingmutilatedrightarm_waitingfor"].p)
  elseif (not conf.aillusion or affs.mutilatedrightarm or affs.parestoarms) then
    checkaction(dict["curingmutilatedrightarm"].waitingfor, true)
    lifevision.add(dict["curingmutilatedrightarm"].waitingfor)
  else
    ignore_illusion("We don't have a mutilatedrightarm right now.")
  end
end
function valid.curingmutilatedleftarm()
  local result = checkany(dict.curingmutilatedleftarm.waitingfor, dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

  if not result then return end

  if result.name == "curingmutilatedleftarm_waitingfor" then
    lifevision.add(actions["curingmutilatedleftarm_waitingfor"].p)
  elseif (not conf.aillusion or affs.mutilatedleftarm or affs.parestoarms) then
    checkaction(dict["curingmutilatedleftarm"].waitingfor, true)
    lifevision.add(dict["curingmutilatedleftarm"].waitingfor)
  else
    ignore_illusion("We don't have a mutilatedleftarm right now.")
  end
end
function valid.curingmangledrightarm()
  local result = checkany(dict.curingmangledrightarm.waitingfor, dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

  if not result then return end

  if result.name == "curingmangledrightarm_waitingfor" then
    lifevision.add(actions["curingmangledrightarm_waitingfor"].p)
  elseif (not conf.aillusion or affs.mangledrightarm or affs.parestoarms) then
    checkaction(dict["curingmangledrightarm"].waitingfor, true)
    lifevision.add(dict["curingmangledrightarm"].waitingfor)
  else
    ignore_illusion("We don't have a mangledrightarm right now.")
  end
end
function valid.curingmangledleftarm()
  local result = checkany(dict.curingmangledleftarm.waitingfor, dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

  if not result then return end

  if result.name == "curingmangledleftarm_waitingfor" then
    lifevision.add(actions["curingmangledleftarm_waitingfor"].p)
  elseif (not conf.aillusion or affs.mangledleftarm or affs.parestoarms) then
    checkaction(dict["curingmangledleftarm"].waitingfor, true)
    lifevision.add(dict["curingmangledleftarm"].waitingfor)
  else
    ignore_illusion("We don't have a mangledleftarm right now.")
  end
end
function valid.curingparestoarms()
  local result = checkany(dict.curingparestoarms.waitingfor, dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingparestoarms.waitingfor)

  if not result then return end

  if result.name == "curingparestoarms_waitingfor" then
    lifevision.add(actions["curingparestoarms_waitingfor"].p)
  elseif (not conf.aillusion or affs.parestoarms or affs.parestoarms) then
    checkaction(dict["curingparestoarms"].waitingfor, true)
    lifevision.add(dict["curingparestoarms"].waitingfor)
  else
    ignore_illusion("We don't have a parestoarms right now.")
  end
end


function valid.curingmildtrauma()
  local result = checkany(dict.curingmildtrauma.waitingfor, dict.curingmildtrauma.waitingfor, dict.curingserioustrauma.waitingfor, dict.curingmildconcussion.waitingfor, dict.curingseriousconcussion.waitingfor, dict.curinglaceratedthroat.waitingfor, dict.curingheartseed.waitingfor)

  if not result then return end

  if result.name == "curingmildtrauma_waitingfor" then
    lifevision.add(actions["curingmildtrauma_waitingfor"].p)
  elseif (not conf.aillusion or affs.mildtrauma or affs.parestoarms) then
    checkaction(dict["curingmildtrauma"].waitingfor, true)
    lifevision.add(dict["curingmildtrauma"].waitingfor)
  else
    ignore_illusion("We don't have a mildtrauma right now.")
  end
end
function valid.curingserioustrauma()
  local result = checkany(dict.curingserioustrauma.waitingfor, dict.curingmildtrauma.waitingfor, dict.curingserioustrauma.waitingfor, dict.curingmildconcussion.waitingfor, dict.curingseriousconcussion.waitingfor, dict.curinglaceratedthroat.waitingfor, dict.curingheartseed.waitingfor)

  if not result then return end

  if result.name == "curingserioustrauma_waitingfor" then
    lifevision.add(actions["curingserioustrauma_waitingfor"].p)
  elseif (not conf.aillusion or affs.serioustrauma or affs.parestoarms) then
    checkaction(dict["curingserioustrauma"].waitingfor, true)
    lifevision.add(dict["curingserioustrauma"].waitingfor)
  else
    ignore_illusion("We don't have a serioustrauma right now.")
  end
end
function valid.curingmildconcussion()
  local result = checkany(dict.curingmildconcussion.waitingfor, dict.curingmildtrauma.waitingfor, dict.curingserioustrauma.waitingfor, dict.curingmildconcussion.waitingfor, dict.curingseriousconcussion.waitingfor, dict.curinglaceratedthroat.waitingfor, dict.curingheartseed.waitingfor)

  if not result then return end

  if result.name == "curingmildconcussion_waitingfor" then
    lifevision.add(actions["curingmildconcussion_waitingfor"].p)
  elseif (not conf.aillusion or affs.mildconcussion or affs.parestoarms) then
    checkaction(dict["curingmildconcussion"].waitingfor, true)
    lifevision.add(dict["curingmildconcussion"].waitingfor)
  else
    ignore_illusion("We don't have a mildconcussion right now.")
  end
end
function valid.curingseriousconcussion()
  local result = checkany(dict.curingseriousconcussion.waitingfor, dict.curingmildtrauma.waitingfor, dict.curingserioustrauma.waitingfor, dict.curingmildconcussion.waitingfor, dict.curingseriousconcussion.waitingfor, dict.curinglaceratedthroat.waitingfor, dict.curingheartseed.waitingfor)

  if not result then return end

  if result.name == "curingseriousconcussion_waitingfor" then
    lifevision.add(actions["curingseriousconcussion_waitingfor"].p)
  elseif (not conf.aillusion or affs.seriousconcussion or affs.parestoarms) then
    checkaction(dict["curingseriousconcussion"].waitingfor, true)
    lifevision.add(dict["curingseriousconcussion"].waitingfor)
  else
    ignore_illusion("We don't have a seriousconcussion right now.")
  end
end
function valid.curinglaceratedthroat()
  local result = checkany(dict.curinglaceratedthroat.waitingfor, dict.curingmildtrauma.waitingfor, dict.curingserioustrauma.waitingfor, dict.curingmildconcussion.waitingfor, dict.curingseriousconcussion.waitingfor, dict.curinglaceratedthroat.waitingfor, dict.curingheartseed.waitingfor)

  if not result then return end

  if result.name == "curinglaceratedthroat_waitingfor" then
    lifevision.add(actions["curinglaceratedthroat_waitingfor"].p)
  elseif (not conf.aillusion or affs.laceratedthroat or affs.parestoarms) then
    checkaction(dict["curinglaceratedthroat"].waitingfor, true)
    lifevision.add(dict["curinglaceratedthroat"].waitingfor)
  else
    ignore_illusion("We don't have a laceratedthroat right now.")
  end
end
function valid.curingheartseed()
  local result = checkany(dict.curingheartseed.waitingfor, dict.curingmildtrauma.waitingfor, dict.curingserioustrauma.waitingfor, dict.curingmildconcussion.waitingfor, dict.curingseriousconcussion.waitingfor, dict.curinglaceratedthroat.waitingfor, dict.curingheartseed.waitingfor)

  if not result then return end

  if result.name == "curingheartseed_waitingfor" then
    lifevision.add(actions["curingheartseed_waitingfor"].p)
  elseif (not conf.aillusion or affs.heartseed or affs.parestoarms) then
    checkaction(dict["curingheartseed"].waitingfor, true)
    lifevision.add(dict["curingheartseed"].waitingfor)
  else
    ignore_illusion("We don't have a heartseed right now.")
  end
end


function valid.curingmutilatedrightleg()
  local result = checkany(dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

  if not result then return end

  if result.name == "curingmutilatedrightleg_waitingfor" then
    lifevision.add(actions["curingmutilatedrightleg_waitingfor"].p)
  elseif (not conf.aillusion or affs.mutilatedrightleg or affs.parestolegs) then
    checkaction(dict["curingmutilatedrightleg"].waitingfor, true)
    lifevision.add(dict["curingmutilatedrightleg"].waitingfor)
  else
    ignore_illusion("We don't have a mutilatedrightleg right now.")
  end
end
function valid.curingmutilatedleftleg()
  local result = checkany(dict.curingmutilatedleftleg.waitingfor, dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

  if not result then return end

  if result.name == "curingmutilatedleftleg_waitingfor" then
    lifevision.add(actions["curingmutilatedleftleg_waitingfor"].p)
  elseif (not conf.aillusion or affs.mutilatedleftleg or affs.parestolegs) then
    checkaction(dict["curingmutilatedleftleg"].waitingfor, true)
    lifevision.add(dict["curingmutilatedleftleg"].waitingfor)
  else
    ignore_illusion("We don't have a mutilatedleftleg right now.")
  end
end
function valid.curingmangledrightleg()
  local result = checkany(dict.curingmangledrightleg.waitingfor, dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

  if not result then return end

  if result.name == "curingmangledrightleg_waitingfor" then
    lifevision.add(actions["curingmangledrightleg_waitingfor"].p)
  elseif (not conf.aillusion or affs.mangledrightleg or affs.parestolegs) then
    checkaction(dict["curingmangledrightleg"].waitingfor, true)
    lifevision.add(dict["curingmangledrightleg"].waitingfor)
  else
    ignore_illusion("We don't have a mangledrightleg right now.")
  end
end
function valid.curingmangledleftleg()
  local result = checkany(dict.curingmangledleftleg.waitingfor, dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

  if not result then return end

  if result.name == "curingmangledleftleg_waitingfor" then
    lifevision.add(actions["curingmangledleftleg_waitingfor"].p)
  elseif (not conf.aillusion or affs.mangledleftleg or affs.parestolegs) then
    checkaction(dict["curingmangledleftleg"].waitingfor, true)
    lifevision.add(dict["curingmangledleftleg"].waitingfor)
  else
    ignore_illusion("We don't have a mangledleftleg right now.")
  end
end
function valid.curingparestolegs()
  local result = checkany(dict.curingparestolegs.waitingfor, dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingparestolegs.waitingfor)

  if not result then return end

  if result.name == "curingparestolegs_waitingfor" then
    lifevision.add(actions["curingparestolegs_waitingfor"].p)
  elseif (not conf.aillusion or affs.parestolegs or affs.parestolegs) then
    checkaction(dict["curingparestolegs"].waitingfor, true)
    lifevision.add(dict["curingparestolegs"].waitingfor)
  else
    ignore_illusion("We don't have a parestolegs right now.")
  end
end

-- salve cures - instantaneous only


function valid.salve_cured_selarnia()
  local result = checkany(dict.selarnia.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "selarnia_salve" then
    lifevision.add(actions.selarnia_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.selarnia.salve, true)
    lifevision.add(dict.selarnia.salve)
  end
end
function valid.salve_cured_crippledleftarm()
  local result = checkany(dict.crippledleftarm.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "crippledleftarm_salve" then
    lifevision.add(actions.crippledleftarm_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.crippledleftarm.salve, true)
    lifevision.add(dict.crippledleftarm.salve)
  end
end
function valid.salve_cured_crippledleftleg()
  local result = checkany(dict.crippledleftleg.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "crippledleftleg_salve" then
    lifevision.add(actions.crippledleftleg_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.crippledleftleg.salve, true)
    lifevision.add(dict.crippledleftleg.salve)
  end
end
function valid.salve_cured_crippledrightarm()
  local result = checkany(dict.crippledrightarm.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "crippledrightarm_salve" then
    lifevision.add(actions.crippledrightarm_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.crippledrightarm.salve, true)
    lifevision.add(dict.crippledrightarm.salve)
  end
end
function valid.salve_cured_crippledrightleg()
  local result = checkany(dict.crippledrightleg.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "crippledrightleg_salve" then
    lifevision.add(actions.crippledrightleg_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.crippledrightleg.salve, true)
    lifevision.add(dict.crippledrightleg.salve)
  end
end
function valid.salve_cured_ablaze()
  local result = checkany(dict.ablaze.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "ablaze_salve" then
    lifevision.add(actions.ablaze_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.ablaze.salve, true)
    lifevision.add(dict.ablaze.salve)
  end
end
function valid.salve_cured_unknowncrippledarm()
  local result = checkany(dict.unknowncrippledarm.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "unknowncrippledarm_salve" then
    lifevision.add(actions.unknowncrippledarm_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.unknowncrippledarm.salve, true)
    lifevision.add(dict.unknowncrippledarm.salve)
  end
end
function valid.salve_cured_unknowncrippledleg()
  local result = checkany(dict.unknowncrippledleg.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "unknowncrippledleg_salve" then
    lifevision.add(actions.unknowncrippledleg_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.unknowncrippledleg.salve, true)
    lifevision.add(dict.unknowncrippledleg.salve)
  end
end
function valid.salve_cured_unknowncrippledlimb()
  local result = checkany(dict.unknowncrippledlimb.salve, dict.selarnia.salve, dict.crippledleftarm.salve, dict.crippledleftleg.salve, dict.crippledrightarm.salve, dict.crippledrightleg.salve, dict.ablaze.salve, dict.unknowncrippledarm.salve, dict.unknowncrippledleg.salve, dict.unknowncrippledlimb.salve)

  if not result then return end

  apply_cure = true
  if result.name == "unknowncrippledlimb_salve" then
    lifevision.add(actions.unknowncrippledlimb_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.unknowncrippledlimb.salve, true)
    lifevision.add(dict.unknowncrippledlimb.salve)
  end
end


function valid.salve_cured_frozen()
  local result = checkany(dict.frozen.salve, dict.frozen.salve, dict.shivering.salve, dict.caloric.salve)

  if not result then return end

  apply_cure = true
  if result.name == "frozen_salve" then
    lifevision.add(actions.frozen_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.frozen.salve, true)
    lifevision.add(dict.frozen.salve)
  end
end
function valid.salve_cured_shivering()
  local result = checkany(dict.shivering.salve, dict.frozen.salve, dict.shivering.salve, dict.caloric.salve)

  if not result then return end

  apply_cure = true
  if result.name == "shivering_salve" then
    lifevision.add(actions.shivering_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.shivering.salve, true)
    lifevision.add(dict.shivering.salve)
  end
end
function valid.salve_cured_caloric()
  local result = checkany(dict.caloric.salve, dict.frozen.salve, dict.shivering.salve, dict.caloric.salve)

  if not result then return end

  apply_cure = true
  if result.name == "caloric_salve" then
    lifevision.add(actions.caloric_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.caloric.salve, true)
    lifevision.add(dict.caloric.salve)
  end
end


function valid.salve_cured_anorexia()
  local result = checkany(dict.anorexia.salve, dict.anorexia.salve, dict.itching.salve, dict.stuttering.salve, dict.slashedthroat.salve, dict.blindaff.salve, dict.deafaff.salve, dict.scalded.salve)

  if not result then return end

  apply_cure = true
  if result.name == "anorexia_salve" then
    lifevision.add(actions.anorexia_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.anorexia.salve, true)
    lifevision.add(dict.anorexia.salve)
  end
end
function valid.salve_cured_itching()
  local result = checkany(dict.itching.salve, dict.anorexia.salve, dict.itching.salve, dict.stuttering.salve, dict.slashedthroat.salve, dict.blindaff.salve, dict.deafaff.salve, dict.scalded.salve)

  if not result then return end

  apply_cure = true
  if result.name == "itching_salve" then
    lifevision.add(actions.itching_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.itching.salve, true)
    lifevision.add(dict.itching.salve)
  end
end
function valid.salve_cured_stuttering()
  local result = checkany(dict.stuttering.salve, dict.anorexia.salve, dict.itching.salve, dict.stuttering.salve, dict.slashedthroat.salve, dict.blindaff.salve, dict.deafaff.salve, dict.scalded.salve)

  if not result then return end

  apply_cure = true
  if result.name == "stuttering_salve" then
    lifevision.add(actions.stuttering_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.stuttering.salve, true)
    lifevision.add(dict.stuttering.salve)
  end
end
function valid.salve_cured_slashedthroat()
  local result = checkany(dict.slashedthroat.salve, dict.anorexia.salve, dict.itching.salve, dict.stuttering.salve, dict.slashedthroat.salve, dict.blindaff.salve, dict.deafaff.salve, dict.scalded.salve)

  if not result then return end

  apply_cure = true
  if result.name == "slashedthroat_salve" then
    lifevision.add(actions.slashedthroat_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.slashedthroat.salve, true)
    lifevision.add(dict.slashedthroat.salve)
  end
end
function valid.salve_cured_blindaff()
  local result = checkany(dict.blindaff.salve, dict.anorexia.salve, dict.itching.salve, dict.stuttering.salve, dict.slashedthroat.salve, dict.blindaff.salve, dict.deafaff.salve, dict.scalded.salve)

  if not result then return end

  apply_cure = true
  if result.name == "blindaff_salve" then
    lifevision.add(actions.blindaff_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.blindaff.salve, true)
    lifevision.add(dict.blindaff.salve)
  end
end
function valid.salve_cured_deafaff()
  local result = checkany(dict.deafaff.salve, dict.anorexia.salve, dict.itching.salve, dict.stuttering.salve, dict.slashedthroat.salve, dict.blindaff.salve, dict.deafaff.salve, dict.scalded.salve)

  if not result then return end

  apply_cure = true
  if result.name == "deafaff_salve" then
    lifevision.add(actions.deafaff_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.deafaff.salve, true)
    lifevision.add(dict.deafaff.salve)
  end
end
function valid.salve_cured_scalded()
  local result = checkany(dict.scalded.salve, dict.anorexia.salve, dict.itching.salve, dict.stuttering.salve, dict.slashedthroat.salve, dict.blindaff.salve, dict.deafaff.salve, dict.scalded.salve)

  if not result then return end

  apply_cure = true
  if result.name == "scalded_salve" then
    lifevision.add(actions.scalded_salve.p)
  else
    killaction(dict[result.action_name].salve)
    checkaction(dict.scalded.salve, true)
    lifevision.add(dict.scalded.salve)
  end
end


-- focus


function valid.focus_cured_claustrophobia()
  local result = checkany(dict.claustrophobia.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "claustrophobia_focus" then
    lifevision.add(actions.claustrophobia_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.claustrophobia_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.claustrophobia.focus, true)
    lifevision.add(dict.claustrophobia.focus)
  end
end

function valid.focus_cured_weakness()
  local result = checkany(dict.weakness.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "weakness_focus" then
    lifevision.add(actions.weakness_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.weakness_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.weakness.focus, true)
    lifevision.add(dict.weakness.focus)
  end
end

function valid.focus_cured_masochism()
  local result = checkany(dict.masochism.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "masochism_focus" then
    lifevision.add(actions.masochism_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.masochism_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.masochism.focus, true)
    lifevision.add(dict.masochism.focus)
  end
end

function valid.focus_cured_dizziness()
  local result = checkany(dict.dizziness.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "dizziness_focus" then
    lifevision.add(actions.dizziness_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.dizziness_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.dizziness.focus, true)
    lifevision.add(dict.dizziness.focus)
  end
end

function valid.focus_cured_confusion()
  local result = checkany(dict.confusion.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "confusion_focus" then
    lifevision.add(actions.confusion_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.confusion_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.confusion.focus, true)
    lifevision.add(dict.confusion.focus)
  end
end

function valid.focus_cured_stupidity()
  local result = checkany(dict.stupidity.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "stupidity_focus" then
    lifevision.add(actions.stupidity_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.stupidity_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.stupidity.focus, true)
    lifevision.add(dict.stupidity.focus)
  end
end

function valid.focus_cured_generosity()
  local result = checkany(dict.generosity.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "generosity_focus" then
    lifevision.add(actions.generosity_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.generosity_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.generosity.focus, true)
    lifevision.add(dict.generosity.focus)
  end
end

function valid.focus_cured_loneliness()
  local result = checkany(dict.loneliness.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "loneliness_focus" then
    lifevision.add(actions.loneliness_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.loneliness_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.loneliness.focus, true)
    lifevision.add(dict.loneliness.focus)
  end
end

function valid.focus_cured_agoraphobia()
  local result = checkany(dict.agoraphobia.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "agoraphobia_focus" then
    lifevision.add(actions.agoraphobia_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.agoraphobia_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.agoraphobia.focus, true)
    lifevision.add(dict.agoraphobia.focus)
  end
end

function valid.focus_cured_recklessness()
  local result = checkany(dict.recklessness.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "recklessness_focus" then
    lifevision.add(actions.recklessness_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.recklessness_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.recklessness.focus, true)
    lifevision.add(dict.recklessness.focus)
  end
end

function valid.focus_cured_epilepsy()
  local result = checkany(dict.epilepsy.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "epilepsy_focus" then
    lifevision.add(actions.epilepsy_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.epilepsy_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.epilepsy.focus, true)
    lifevision.add(dict.epilepsy.focus)
  end
end

function valid.focus_cured_pacifism()
  local result = checkany(dict.pacifism.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "pacifism_focus" then
    lifevision.add(actions.pacifism_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.pacifism_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.pacifism.focus, true)
    lifevision.add(dict.pacifism.focus)
  end
end

function valid.focus_cured_anorexia()
  local result = checkany(dict.anorexia.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "anorexia_focus" then
    lifevision.add(actions.anorexia_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.anorexia_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.anorexia.focus, true)
    lifevision.add(dict.anorexia.focus)
  end
end

function valid.focus_cured_shyness()
  local result = checkany(dict.shyness.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "shyness_focus" then
    lifevision.add(actions.shyness_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.shyness_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.shyness.focus, true)
    lifevision.add(dict.shyness.focus)
  end
end

function valid.focus_cured_vertigo()
  local result = checkany(dict.vertigo.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "vertigo_focus" then
    lifevision.add(actions.vertigo_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.vertigo_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.vertigo.focus, true)
    lifevision.add(dict.vertigo.focus)
  end
end

function valid.focus_cured_fear()
  local result = checkany(dict.fear.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "fear_focus" then
    lifevision.add(actions.fear_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.fear_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.fear.focus, true)
    lifevision.add(dict.fear.focus)
  end
end

function valid.focus_cured_airdisrupt()
  local result = checkany(dict.airdisrupt.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "airdisrupt_focus" then
    lifevision.add(actions.airdisrupt_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.airdisrupt_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.airdisrupt.focus, true)
    lifevision.add(dict.airdisrupt.focus)
  end
end

function valid.focus_cured_firedisrupt()
  local result = checkany(dict.firedisrupt.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "firedisrupt_focus" then
    lifevision.add(actions.firedisrupt_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.firedisrupt_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.firedisrupt.focus, true)
    lifevision.add(dict.firedisrupt.focus)
  end
end

function valid.focus_cured_waterdisrupt()
  local result = checkany(dict.waterdisrupt.focus, dict.claustrophobia.focus, dict.weakness.focus, dict.masochism.focus, dict.dizziness.focus, dict.confusion.focus, dict.stupidity.focus, dict.generosity.focus, dict.loneliness.focus, dict.agoraphobia.focus, dict.recklessness.focus, dict.epilepsy.focus, dict.pacifism.focus, dict.anorexia.focus, dict.shyness.focus, dict.vertigo.focus, dict.fear.focus, dict.airdisrupt.focus, dict.firedisrupt.focus, dict.waterdisrupt.focus)
  if not result then return end

  focus_cure = true

  if result.name == "waterdisrupt_focus" then
    lifevision.add(actions.waterdisrupt_focus.p)

    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.waterdisrupt_focus.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end
  else
    killaction(dict[result.action_name].focus)
    checkaction(dict.waterdisrupt.focus, true)
    lifevision.add(dict.waterdisrupt.focus)
  end
end



-- normal smokes


function valid.smoke_cured_deadening()
  local result = checkany(dict.deadening.smoke, dict.deadening.smoke, dict.hellsight.smoke, dict.madness.smoke, dict.aeon.smoke)

  if not result then return end

  smoke_cure = true
  if result.name == "deadening_smoke" then
    lifevision.add(actions.deadening_smoke.p)
  else
    killaction(dict[result.action_name].smoke)
    checkaction(dict.deadening.smoke, true)
    lifevision.add(dict.deadening.smoke)
  end
end

function valid.smoke_cured_hellsight()
  local result = checkany(dict.hellsight.smoke, dict.deadening.smoke, dict.hellsight.smoke, dict.madness.smoke, dict.aeon.smoke)

  if not result then return end

  smoke_cure = true
  if result.name == "hellsight_smoke" then
    lifevision.add(actions.hellsight_smoke.p)
  else
    killaction(dict[result.action_name].smoke)
    checkaction(dict.hellsight.smoke, true)
    lifevision.add(dict.hellsight.smoke)
  end
end

function valid.smoke_cured_madness()
  local result = checkany(dict.madness.smoke, dict.deadening.smoke, dict.hellsight.smoke, dict.madness.smoke, dict.aeon.smoke)

  if not result then return end

  smoke_cure = true
  if result.name == "madness_smoke" then
    lifevision.add(actions.madness_smoke.p)
  else
    killaction(dict[result.action_name].smoke)
    checkaction(dict.madness.smoke, true)
    lifevision.add(dict.madness.smoke)
  end
end

function valid.smoke_cured_aeon()
  local result = checkany(dict.aeon.smoke, dict.deadening.smoke, dict.hellsight.smoke, dict.madness.smoke, dict.aeon.smoke)

  if not result then return end

  smoke_cure = true
  if result.name == "aeon_smoke" then
    lifevision.add(actions.aeon_smoke.p)
  else
    killaction(dict[result.action_name].smoke)
    checkaction(dict.aeon.smoke, true)
    lifevision.add(dict.aeon.smoke)
  end
end



function valid.smoke_cured_disloyalty()
  local result = checkany(dict.disloyalty.smoke, dict.disloyalty.smoke, dict.slickness.smoke, dict.manaleech.smoke)

  if not result then return end

  smoke_cure = true
  if result.name == "disloyalty_smoke" then
    lifevision.add(actions.disloyalty_smoke.p)
  else
    killaction(dict[result.action_name].smoke)
    checkaction(dict.disloyalty.smoke, true)
    lifevision.add(dict.disloyalty.smoke)
  end
end

function valid.smoke_cured_slickness()
  local result = checkany(dict.slickness.smoke, dict.disloyalty.smoke, dict.slickness.smoke, dict.manaleech.smoke)

  if not result then return end

  smoke_cure = true
  if result.name == "slickness_smoke" then
    lifevision.add(actions.slickness_smoke.p)
  else
    killaction(dict[result.action_name].smoke)
    checkaction(dict.slickness.smoke, true)
    lifevision.add(dict.slickness.smoke)
  end
end

function valid.smoke_cured_manaleech()
  local result = checkany(dict.manaleech.smoke, dict.disloyalty.smoke, dict.slickness.smoke, dict.manaleech.smoke)

  if not result then return end

  smoke_cure = true
  if result.name == "manaleech_smoke" then
    lifevision.add(actions.manaleech_smoke.p)
  else
    killaction(dict[result.action_name].smoke)
    checkaction(dict.manaleech.smoke, true)
    lifevision.add(dict.manaleech.smoke)
  end
end


-- normal herbs


function valid.herb_cured_asthma()
  local result = checkany(dict.asthma.herb, dict.asthma.herb, dict.hypochondria.herb, dict.healthleech.herb, dict.sensitivity.herb, dict.clumsiness.herb, dict.weakness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "asthma_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.asthma_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.asthma_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.asthma or affs.unknownany or affs.unknownmental or affsp.asthma))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.asthma.herb, true)
    lifevision.add(dict.asthma.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the asthma herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_hypochondria()
  local result = checkany(dict.hypochondria.herb, dict.asthma.herb, dict.hypochondria.herb, dict.healthleech.herb, dict.sensitivity.herb, dict.clumsiness.herb, dict.weakness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "hypochondria_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.hypochondria_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.hypochondria_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.hypochondria or affs.unknownany or affs.unknownmental or affsp.hypochondria))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.hypochondria.herb, true)
    lifevision.add(dict.hypochondria.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the hypochondria herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_healthleech()
  local result = checkany(dict.healthleech.herb, dict.asthma.herb, dict.hypochondria.herb, dict.healthleech.herb, dict.sensitivity.herb, dict.clumsiness.herb, dict.weakness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "healthleech_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.healthleech_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.healthleech_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.healthleech or affs.unknownany or affs.unknownmental or affsp.healthleech))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.healthleech.herb, true)
    lifevision.add(dict.healthleech.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the healthleech herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_sensitivity()
  local result = checkany(dict.sensitivity.herb, dict.asthma.herb, dict.hypochondria.herb, dict.healthleech.herb, dict.sensitivity.herb, dict.clumsiness.herb, dict.weakness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "sensitivity_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.sensitivity_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.sensitivity_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.sensitivity or affs.unknownany or affs.unknownmental or affsp.sensitivity))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.sensitivity.herb, true)
    lifevision.add(dict.sensitivity.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the sensitivity herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_clumsiness()
  local result = checkany(dict.clumsiness.herb, dict.asthma.herb, dict.hypochondria.herb, dict.healthleech.herb, dict.sensitivity.herb, dict.clumsiness.herb, dict.weakness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "clumsiness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.clumsiness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.clumsiness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.clumsiness or affs.unknownany or affs.unknownmental or affsp.clumsiness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.clumsiness.herb, true)
    lifevision.add(dict.clumsiness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the clumsiness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_weakness()
  local result = checkany(dict.weakness.herb, dict.asthma.herb, dict.hypochondria.herb, dict.healthleech.herb, dict.sensitivity.herb, dict.clumsiness.herb, dict.weakness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "weakness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.weakness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.weakness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.weakness or affs.unknownany or affs.unknownmental or affsp.weakness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.weakness.herb, true)
    lifevision.add(dict.weakness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the weakness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end



function valid.herb_cured_claustrophobia()
  local result = checkany(dict.claustrophobia.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "claustrophobia_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.claustrophobia_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.claustrophobia_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.claustrophobia or affs.unknownany or affs.unknownmental or affsp.claustrophobia))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.claustrophobia.herb, true)
    lifevision.add(dict.claustrophobia.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the claustrophobia herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_recklessness()
  local result = checkany(dict.recklessness.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "recklessness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.recklessness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.recklessness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.recklessness or affs.unknownany or affs.unknownmental or affsp.recklessness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.recklessness.herb, true)
    lifevision.add(dict.recklessness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the recklessness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_agoraphobia()
  local result = checkany(dict.agoraphobia.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "agoraphobia_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.agoraphobia_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.agoraphobia_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.agoraphobia or affs.unknownany or affs.unknownmental or affsp.agoraphobia))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.agoraphobia.herb, true)
    lifevision.add(dict.agoraphobia.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the agoraphobia herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_loneliness()
  local result = checkany(dict.loneliness.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "loneliness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.loneliness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.loneliness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.loneliness or affs.unknownany or affs.unknownmental or affsp.loneliness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.loneliness.herb, true)
    lifevision.add(dict.loneliness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the loneliness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_masochism()
  local result = checkany(dict.masochism.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "masochism_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.masochism_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.masochism_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.masochism or affs.unknownany or affs.unknownmental or affsp.masochism))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.masochism.herb, true)
    lifevision.add(dict.masochism.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the masochism herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_vertigo()
  local result = checkany(dict.vertigo.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "vertigo_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.vertigo_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.vertigo_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.vertigo or affs.unknownany or affs.unknownmental or affsp.vertigo))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.vertigo.herb, true)
    lifevision.add(dict.vertigo.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the vertigo herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_spiritdisrupt()
  local result = checkany(dict.spiritdisrupt.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "spiritdisrupt_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.spiritdisrupt_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.spiritdisrupt_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.spiritdisrupt or affs.unknownany or affs.unknownmental or affsp.spiritdisrupt))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.spiritdisrupt.herb, true)
    lifevision.add(dict.spiritdisrupt.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the spiritdisrupt herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_airdisrupt()
  local result = checkany(dict.airdisrupt.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "airdisrupt_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.airdisrupt_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.airdisrupt_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.airdisrupt or affs.unknownany or affs.unknownmental or affsp.airdisrupt))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.airdisrupt.herb, true)
    lifevision.add(dict.airdisrupt.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the airdisrupt herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_waterdisrupt()
  local result = checkany(dict.waterdisrupt.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "waterdisrupt_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.waterdisrupt_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.waterdisrupt_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.waterdisrupt or affs.unknownany or affs.unknownmental or affsp.waterdisrupt))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.waterdisrupt.herb, true)
    lifevision.add(dict.waterdisrupt.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the waterdisrupt herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_earthdisrupt()
  local result = checkany(dict.earthdisrupt.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "earthdisrupt_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.earthdisrupt_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.earthdisrupt_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.earthdisrupt or affs.unknownany or affs.unknownmental or affsp.earthdisrupt))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.earthdisrupt.herb, true)
    lifevision.add(dict.earthdisrupt.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the earthdisrupt herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_firedisrupt()
  local result = checkany(dict.firedisrupt.herb, dict.claustrophobia.herb, dict.recklessness.herb, dict.agoraphobia.herb, dict.loneliness.herb, dict.masochism.herb, dict.vertigo.herb, dict.spiritdisrupt.herb, dict.airdisrupt.herb, dict.waterdisrupt.herb, dict.earthdisrupt.herb, dict.firedisrupt.herb)

  if not result then return end

  herb_cure = true
  if result.name == "firedisrupt_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.firedisrupt_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.firedisrupt_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.firedisrupt or affs.unknownany or affs.unknownmental or affsp.firedisrupt))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.firedisrupt.herb, true)
    lifevision.add(dict.firedisrupt.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the firedisrupt herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end



function valid.herb_cured_hallucinations()
  local result = checkany(dict.hallucinations.herb, dict.hallucinations.herb, dict.hypersomnia.herb, dict.confusion.herb, dict.paranoia.herb, dict.dementia.herb)

  if not result then return end

  herb_cure = true
  if result.name == "hallucinations_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.hallucinations_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.hallucinations_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.hallucinations or affs.unknownany or affs.unknownmental or affsp.hallucinations))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.hallucinations.herb, true)
    lifevision.add(dict.hallucinations.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the hallucinations herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_hypersomnia()
  local result = checkany(dict.hypersomnia.herb, dict.hallucinations.herb, dict.hypersomnia.herb, dict.confusion.herb, dict.paranoia.herb, dict.dementia.herb)

  if not result then return end

  herb_cure = true
  if result.name == "hypersomnia_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.hypersomnia_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.hypersomnia_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.hypersomnia or affs.unknownany or affs.unknownmental or affsp.hypersomnia))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.hypersomnia.herb, true)
    lifevision.add(dict.hypersomnia.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the hypersomnia herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_confusion()
  local result = checkany(dict.confusion.herb, dict.hallucinations.herb, dict.hypersomnia.herb, dict.confusion.herb, dict.paranoia.herb, dict.dementia.herb)

  if not result then return end

  herb_cure = true
  if result.name == "confusion_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.confusion_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.confusion_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.confusion or affs.unknownany or affs.unknownmental or affsp.confusion))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.confusion.herb, true)
    lifevision.add(dict.confusion.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the confusion herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_paranoia()
  local result = checkany(dict.paranoia.herb, dict.hallucinations.herb, dict.hypersomnia.herb, dict.confusion.herb, dict.paranoia.herb, dict.dementia.herb)

  if not result then return end

  herb_cure = true
  if result.name == "paranoia_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.paranoia_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.paranoia_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.paranoia or affs.unknownany or affs.unknownmental or affsp.paranoia))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.paranoia.herb, true)
    lifevision.add(dict.paranoia.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the paranoia herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_dementia()
  local result = checkany(dict.dementia.herb, dict.hallucinations.herb, dict.hypersomnia.herb, dict.confusion.herb, dict.paranoia.herb, dict.dementia.herb)

  if not result then return end

  herb_cure = true
  if result.name == "dementia_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.dementia_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.dementia_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.dementia or affs.unknownany or affs.unknownmental or affsp.dementia))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.dementia.herb, true)
    lifevision.add(dict.dementia.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the dementia herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end



function valid.herb_cured_generosity()
  local result = checkany(dict.generosity.herb, dict.generosity.herb, dict.pacifism.herb, dict.justice.herb, dict.inlove.herb, dict.peace.herb)

  if not result then return end

  herb_cure = true
  if result.name == "generosity_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.generosity_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.generosity_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.generosity or affs.unknownany or affs.unknownmental or affsp.generosity))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.generosity.herb, true)
    lifevision.add(dict.generosity.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the generosity herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_pacifism()
  local result = checkany(dict.pacifism.herb, dict.generosity.herb, dict.pacifism.herb, dict.justice.herb, dict.inlove.herb, dict.peace.herb)

  if not result then return end

  herb_cure = true
  if result.name == "pacifism_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.pacifism_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.pacifism_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.pacifism or affs.unknownany or affs.unknownmental or affsp.pacifism))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.pacifism.herb, true)
    lifevision.add(dict.pacifism.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the pacifism herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_justice()
  local result = checkany(dict.justice.herb, dict.generosity.herb, dict.pacifism.herb, dict.justice.herb, dict.inlove.herb, dict.peace.herb)

  if not result then return end

  herb_cure = true
  if result.name == "justice_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.justice_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.justice_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.justice or affs.unknownany or affs.unknownmental or affsp.justice))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.justice.herb, true)
    lifevision.add(dict.justice.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the justice herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_inlove()
  local result = checkany(dict.inlove.herb, dict.generosity.herb, dict.pacifism.herb, dict.justice.herb, dict.inlove.herb, dict.peace.herb)

  if not result then return end

  herb_cure = true
  if result.name == "inlove_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.inlove_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.inlove_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.inlove or affs.unknownany or affs.unknownmental or affsp.inlove))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.inlove.herb, true)
    lifevision.add(dict.inlove.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the inlove herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_peace()
  local result = checkany(dict.peace.herb, dict.generosity.herb, dict.pacifism.herb, dict.justice.herb, dict.inlove.herb, dict.peace.herb)

  if not result then return end

  herb_cure = true
  if result.name == "peace_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.peace_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.peace_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.peace or affs.unknownany or affs.unknownmental or affsp.peace))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.peace.herb, true)
    lifevision.add(dict.peace.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the peace herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end



function valid.herb_cured_dissonance()
  local result = checkany(dict.dissonance.herb, dict.dissonance.herb, dict.impatience.herb, dict.stupidity.herb, dict.dizziness.herb, dict.epilepsy.herb, dict.shyness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "dissonance_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.dissonance_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.dissonance_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.dissonance or affs.unknownany or affs.unknownmental or affsp.dissonance))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.dissonance.herb, true)
    lifevision.add(dict.dissonance.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the dissonance herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_impatience()
  local result = checkany(dict.impatience.herb, dict.dissonance.herb, dict.impatience.herb, dict.stupidity.herb, dict.dizziness.herb, dict.epilepsy.herb, dict.shyness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "impatience_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.impatience_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.impatience_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.impatience or affs.unknownany or affs.unknownmental or affsp.impatience))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.impatience.herb, true)
    lifevision.add(dict.impatience.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the impatience herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_stupidity()
  local result = checkany(dict.stupidity.herb, dict.dissonance.herb, dict.impatience.herb, dict.stupidity.herb, dict.dizziness.herb, dict.epilepsy.herb, dict.shyness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "stupidity_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.stupidity_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.stupidity_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.stupidity or affs.unknownany or affs.unknownmental or affsp.stupidity))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.stupidity.herb, true)
    lifevision.add(dict.stupidity.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the stupidity herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_dizziness()
  local result = checkany(dict.dizziness.herb, dict.dissonance.herb, dict.impatience.herb, dict.stupidity.herb, dict.dizziness.herb, dict.epilepsy.herb, dict.shyness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "dizziness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.dizziness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.dizziness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.dizziness or affs.unknownany or affs.unknownmental or affsp.dizziness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.dizziness.herb, true)
    lifevision.add(dict.dizziness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the dizziness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_epilepsy()
  local result = checkany(dict.epilepsy.herb, dict.dissonance.herb, dict.impatience.herb, dict.stupidity.herb, dict.dizziness.herb, dict.epilepsy.herb, dict.shyness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "epilepsy_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.epilepsy_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.epilepsy_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.epilepsy or affs.unknownany or affs.unknownmental or affsp.epilepsy))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.epilepsy.herb, true)
    lifevision.add(dict.epilepsy.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the epilepsy herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_shyness()
  local result = checkany(dict.shyness.herb, dict.dissonance.herb, dict.impatience.herb, dict.stupidity.herb, dict.dizziness.herb, dict.epilepsy.herb, dict.shyness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "shyness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.shyness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.shyness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.shyness or affs.unknownany or affs.unknownmental or affsp.shyness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.shyness.herb, true)
    lifevision.add(dict.shyness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the shyness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end



function valid.herb_cured_paralysis()
  local result = checkany(dict.paralysis.herb, dict.paralysis.herb, dict.slickness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "paralysis_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.paralysis_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.paralysis_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.paralysis or affs.unknownany or affs.unknownmental or affsp.paralysis))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.paralysis.herb, true)
    lifevision.add(dict.paralysis.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the paralysis herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_slickness()
  local result = checkany(dict.slickness.herb, dict.paralysis.herb, dict.slickness.herb)

  if not result then return end

  herb_cure = true
  if result.name == "slickness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.slickness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.slickness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.slickness or affs.unknownany or affs.unknownmental or affsp.slickness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.slickness.herb, true)
    lifevision.add(dict.slickness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the slickness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end



function valid.herb_cured_melancholichumour()
  local result = checkany(dict.melancholichumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "melancholichumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.melancholichumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.melancholichumour_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.melancholichumour or affs.unknownany or affs.unknownmental or affsp.melancholichumour))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.melancholichumour.herb, true)
    lifevision.add(dict.melancholichumour.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the melancholichumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_cholerichumour()
  local result = checkany(dict.cholerichumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "cholerichumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.cholerichumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.cholerichumour_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.cholerichumour or affs.unknownany or affs.unknownmental or affsp.cholerichumour))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.cholerichumour.herb, true)
    lifevision.add(dict.cholerichumour.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the cholerichumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_phlegmatichumour()
  local result = checkany(dict.phlegmatichumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "phlegmatichumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.phlegmatichumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.phlegmatichumour_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.phlegmatichumour or affs.unknownany or affs.unknownmental or affsp.phlegmatichumour))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.phlegmatichumour.herb, true)
    lifevision.add(dict.phlegmatichumour.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the phlegmatichumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_sanguinehumour()
  local result = checkany(dict.sanguinehumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "sanguinehumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.sanguinehumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.sanguinehumour_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.sanguinehumour or affs.unknownany or affs.unknownmental or affsp.sanguinehumour))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.sanguinehumour.herb, true)
    lifevision.add(dict.sanguinehumour.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the sanguinehumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end



function valid.herb_cured_haemophilia()
  local result = checkany(dict.haemophilia.herb, dict.haemophilia.herb, dict.darkshade.herb, dict.relapsing.herb, dict.addiction.herb, dict.illness.herb, dict.lethargy.herb)

  if not result then return end

  herb_cure = true
  if result.name == "haemophilia_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.haemophilia_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.haemophilia_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.haemophilia or affs.unknownany or affs.unknownmental or affsp.haemophilia))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.haemophilia.herb, true)
    lifevision.add(dict.haemophilia.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the haemophilia herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_darkshade()
  local result = checkany(dict.darkshade.herb, dict.haemophilia.herb, dict.darkshade.herb, dict.relapsing.herb, dict.addiction.herb, dict.illness.herb, dict.lethargy.herb)

  if not result then return end

  herb_cure = true
  if result.name == "darkshade_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.darkshade_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.darkshade_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.darkshade or affs.unknownany or affs.unknownmental or affsp.darkshade))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.darkshade.herb, true)
    lifevision.add(dict.darkshade.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the darkshade herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_relapsing()
  local result = checkany(dict.relapsing.herb, dict.haemophilia.herb, dict.darkshade.herb, dict.relapsing.herb, dict.addiction.herb, dict.illness.herb, dict.lethargy.herb)

  if not result then return end

  herb_cure = true
  if result.name == "relapsing_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.relapsing_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.relapsing_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.relapsing or affs.unknownany or affs.unknownmental or affsp.relapsing))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.relapsing.herb, true)
    lifevision.add(dict.relapsing.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the relapsing herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_addiction()
  local result = checkany(dict.addiction.herb, dict.haemophilia.herb, dict.darkshade.herb, dict.relapsing.herb, dict.addiction.herb, dict.illness.herb, dict.lethargy.herb)

  if not result then return end

  herb_cure = true
  if result.name == "addiction_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.addiction_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.addiction_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.addiction or affs.unknownany or affs.unknownmental or affsp.addiction))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.addiction.herb, true)
    lifevision.add(dict.addiction.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the addiction herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_illness()
  local result = checkany(dict.illness.herb, dict.haemophilia.herb, dict.darkshade.herb, dict.relapsing.herb, dict.addiction.herb, dict.illness.herb, dict.lethargy.herb)

  if not result then return end

  herb_cure = true
  if result.name == "illness_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.illness_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.illness_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.illness or affs.unknownany or affs.unknownmental or affsp.illness))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.illness.herb, true)
    lifevision.add(dict.illness.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the illness herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_cured_lethargy()
  local result = checkany(dict.lethargy.herb, dict.haemophilia.herb, dict.darkshade.herb, dict.relapsing.herb, dict.addiction.herb, dict.illness.herb, dict.lethargy.herb)

  if not result then return end

  herb_cure = true
  if result.name == "lethargy_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.lethargy_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.lethargy_herb.p)
  -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
  elseif (not conf.aillusion or (conf.aillusion and (affs.lethargy or affs.unknownany or affs.unknownmental or affsp.lethargy))) then
    killaction(dict[result.action_name].herb)
    checkaction(dict.lethargy.herb, true)
    lifevision.add(dict.lethargy.herb)
  elseif not sk.sawcuringcommand then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the lethargy herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end


-- tree touches

function valid.tree_cured_ablaze()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "ablaze")
    tree_cure = true
  end
end
function valid.tree_cured_addiction()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "addiction")
    tree_cure = true
  end
end
function valid.tree_cured_aeon()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "aeon")
    tree_cure = true
  end
end
function valid.tree_cured_agoraphobia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "agoraphobia")
    tree_cure = true
  end
end
function valid.tree_cured_anorexia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "anorexia")
    tree_cure = true
  end
end
function valid.tree_cured_asthma()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "asthma")
    tree_cure = true
  end
end
function valid.tree_cured_blackout()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "blackout")
    tree_cure = true
  end
end
function valid.tree_cured_bleeding()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "bleeding")
    tree_cure = true
  end
end
function valid.tree_cured_bound()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "bound")
    tree_cure = true
  end
end
function valid.tree_cured_burning()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "burning")
    tree_cure = true
  end
end
function valid.tree_cured_claustrophobia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "claustrophobia")
    tree_cure = true
  end
end
function valid.tree_cured_clumsiness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "clumsiness")
    tree_cure = true
  end
end
function valid.tree_cured_mildconcussion()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "mildconcussion")
    tree_cure = true
  end
end
function valid.tree_cured_confusion()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "confusion")
    tree_cure = true
  end
end
function valid.tree_cured_crippledleftarm()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "crippledleftarm")
    tree_cure = true
  end
end
function valid.tree_cured_crippledleftleg()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "crippledleftleg")
    tree_cure = true
  end
end
function valid.tree_cured_crippledrightarm()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "crippledrightarm")
    tree_cure = true
  end
end
function valid.tree_cured_crippledrightleg()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "crippledrightleg")
    tree_cure = true
  end
end
function valid.tree_cured_darkshade()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "darkshade")
    tree_cure = true
  end
end
function valid.tree_cured_deadening()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "deadening")
    tree_cure = true
  end
end
function valid.tree_cured_dementia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "dementia")
    tree_cure = true
  end
end
function valid.tree_cured_disloyalty()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "disloyalty")
    tree_cure = true
  end
end
function valid.tree_cured_dissonance()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "dissonance")
    tree_cure = true
  end
end
function valid.tree_cured_dizziness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "dizziness")
    tree_cure = true
  end
end
function valid.tree_cured_epilepsy()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "epilepsy")
    tree_cure = true
  end
end
function valid.tree_cured_fear()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "fear")
    tree_cure = true
  end
end
function valid.tree_cured_galed()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "galed")
    tree_cure = true
  end
end
function valid.tree_cured_generosity()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "generosity")
    tree_cure = true
  end
end
function valid.tree_cured_haemophilia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "haemophilia")
    tree_cure = true
  end
end
function valid.tree_cured_hallucinations()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "hallucinations")
    tree_cure = true
  end
end
function valid.tree_cured_healthleech()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "healthleech")
    tree_cure = true
  end
end
function valid.tree_cured_hellsight()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "hellsight")
    tree_cure = true
  end
end
function valid.tree_cured_hypersomnia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "hypersomnia")
    tree_cure = true
  end
end
function valid.tree_cured_hypochondria()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "hypochondria")
    tree_cure = true
  end
end
function valid.tree_cured_icing()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "icing")
    tree_cure = true
  end
end
function valid.tree_cured_illness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "illness")
    tree_cure = true
  end
end
function valid.tree_cured_impatience()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "impatience")
    tree_cure = true
  end
end
function valid.tree_cured_inlove()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "inlove")
    tree_cure = true
  end
end
function valid.tree_cured_itching()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "itching")
    tree_cure = true
  end
end
function valid.tree_cured_justice()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "justice")
    tree_cure = true
  end
end
function valid.tree_cured_laceratedthroat()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "laceratedthroat")
    tree_cure = true
  end
end
function valid.tree_cured_lethargy()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "lethargy")
    tree_cure = true
  end
end
function valid.tree_cured_loneliness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "loneliness")
    tree_cure = true
  end
end
function valid.tree_cured_madness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "madness")
    tree_cure = true
  end
end
function valid.tree_cured_masochism()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "masochism")
    tree_cure = true
  end
end
function valid.tree_cured_pacifism()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "pacifism")
    tree_cure = true
  end
end
function valid.tree_cured_paranoia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "paranoia")
    tree_cure = true
  end
end
function valid.tree_cured_peace()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "peace")
    tree_cure = true
  end
end
function valid.tree_cured_prone()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "prone")
    tree_cure = true
  end
end
function valid.tree_cured_recklessness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "recklessness")
    tree_cure = true
  end
end
function valid.tree_cured_relapsing()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "relapsing")
    tree_cure = true
  end
end
function valid.tree_cured_selarnia()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "selarnia")
    tree_cure = true
  end
end
function valid.tree_cured_sensitivity()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "sensitivity")
    tree_cure = true
  end
end
function valid.tree_cured_shyness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "shyness")
    tree_cure = true
  end
end
function valid.tree_cured_slashedthroat()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "slashedthroat")
    tree_cure = true
  end
end
function valid.tree_cured_slickness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "slickness")
    tree_cure = true
  end
end
function valid.tree_cured_stupidity()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "stupidity")
    tree_cure = true
  end
end
function valid.tree_cured_stuttering()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "stuttering")
    tree_cure = true
  end
end
function valid.tree_cured_vertigo()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "vertigo")
    tree_cure = true
  end
end
function valid.tree_cured_voided()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "voided")
    tree_cure = true
  end
end
function valid.tree_cured_voyria()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "voyria")
    tree_cure = true
  end
end
function valid.tree_cured_weakness()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "weakness")
    tree_cure = true
  end
end
function valid.tree_cured_hamstring()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "hamstring")
    tree_cure = true
  end
end
function valid.tree_cured_shivering()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "shivering")
    tree_cure = true
  end
end
function valid.tree_cured_frozen()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "frozen")
    tree_cure = true
  end
end
function valid.tree_cured_spiritdisrupt()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "spiritdisrupt")
    tree_cure = true
  end
end
function valid.tree_cured_airdisrupt()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "airdisrupt")
    tree_cure = true
  end
end
function valid.tree_cured_firedisrupt()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "firedisrupt")
    tree_cure = true
  end
end
function valid.tree_cured_earthdisrupt()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "earthdisrupt")
    tree_cure = true
  end
end
function valid.tree_cured_waterdisrupt()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "waterdisrupt")
    tree_cure = true
  end
end

-- humour cures


function valid.herb_helped_melancholichumour()
  local result = checkany(dict.melancholichumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "melancholichumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.melancholichumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.melancholichumour_herb.p, "cured")
  elseif (not conf.aillusion or (conf.aillusion and (affs.melancholichumour or (affs.unknownany or affs.unknownmental)))) then -- with AI on, don't accept cures for affs that we don't have
    killaction(dict[result.action_name].herb)
    checkaction(dict.melancholichumour.herb, true)
    lifevision.add(dict.melancholichumour.herb, "cured")
  else
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the melancholichumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_helped_cholerichumour()
  local result = checkany(dict.cholerichumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "cholerichumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.cholerichumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.cholerichumour_herb.p, "cured")
  elseif (not conf.aillusion or (conf.aillusion and (affs.cholerichumour or (affs.unknownany or affs.unknownmental)))) then -- with AI on, don't accept cures for affs that we don't have
    killaction(dict[result.action_name].herb)
    checkaction(dict.cholerichumour.herb, true)
    lifevision.add(dict.cholerichumour.herb, "cured")
  else
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the cholerichumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_helped_phlegmatichumour()
  local result = checkany(dict.phlegmatichumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "phlegmatichumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.phlegmatichumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.phlegmatichumour_herb.p, "cured")
  elseif (not conf.aillusion or (conf.aillusion and (affs.phlegmatichumour or (affs.unknownany or affs.unknownmental)))) then -- with AI on, don't accept cures for affs that we don't have
    killaction(dict[result.action_name].herb)
    checkaction(dict.phlegmatichumour.herb, true)
    lifevision.add(dict.phlegmatichumour.herb, "cured")
  else
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the phlegmatichumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end

function valid.herb_helped_sanguinehumour()
  local result = checkany(dict.sanguinehumour.herb, dict.melancholichumour.herb, dict.cholerichumour.herb, dict.phlegmatichumour.herb, dict.sanguinehumour.herb)

  if not result then return end

  herb_cure = true
  if result.name == "sanguinehumour_herb" then
    -- check timers here! should not be less than half of getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions.sanguinehumour_herb.p.actionwatch), getping()

      if time < (lat/2) then
        ignore_illusion("This 'cure' looks fake - finished way too quickly, in "..time.."s, while our ping is "..lat)
        return
      end
    end

    lifevision.add(actions.sanguinehumour_herb.p, "cured")
  elseif (not conf.aillusion or (conf.aillusion and (affs.sanguinehumour or (affs.unknownany or affs.unknownmental)))) then -- with AI on, don't accept cures for affs that we don't have
    killaction(dict[result.action_name].herb)
    checkaction(dict.sanguinehumour.herb, true)
    lifevision.add(dict.sanguinehumour.herb, "cured")
  else
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(" (i)", '', "Ignored the sanguinehumour herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.")
    moveCursorEnd()
  end
end


-- common ninkharsag code across tree and passive cures
function sk.ninkharsag()
  checkaction(dict.ninkharsag.gone, true)

  if lifevision.l.ninkharsag_gone then
    lifevision.add(actions.ninkharsag_gone.p, "hiddencures", 1 + (lifevision.l.ninkharsag_gone.arg or 1))
  else
    lifevision.add(actions.ninkharsag_gone.p, "hiddencures", 1)
  end
end

-- ninkharsag doesn't show us what we cured - so atm, we'll assume it cured nothing (and not clear all our affs either)
function valid.tree_ninkharsag()
  if conf.aillusion and not actions.touchtree_misc then return end

  tree_cure = true
  sk.ninkharsag()
end

function valid.ninkharsag()
  -- ignore if we don't actually have ninkharsag or we aren't getting a passive cure
  if conf.aillusion and not (affs.ninkharsag and passive_cure_paragraph) then return end

  sk.ninkharsag()
end


function valid.touched_treeoffbal()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, "offbal")
  end
end

-- special defences
function defs.got_deaf()
  checkaction(dict.waitingondeaf.waitingfor)
  if actions.waitingondeaf_waitingfor then
    lifevision.add(actions.waitingondeaf_waitingfor.p)
  end
end


function defs.got_blind()
  local r = checkany(dict.blind.herb)

  if not r then return end

  herb_cure = true
  lifevision.add(actions[r.name].p)
end

function defs.already_blind()
  local r = checkany(dict.blind.herb)

  if not r then return end

  herb_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "noeffect")
  end
end

-- a function to properly assign and ignore missing enchants - works with svo's "do all enchants at once" feature.
function missing_enchant()
  -- find out which actions are we doing, sort them - and see which one is missing (the top one)
  local t = {}
  if actions.magicresist_physical then t[#t+1] = "magicresist" end
  if actions.fireresist_physical then t[#t+1] = "fireresist" end
  if actions.coldresist_physical then t[#t+1] = "coldresist" end
  if actions.electricresist_physical then t[#t+1] = "electricresist" end

  if #t == 0 then return end

  t = prio.sortlist(t, "physical")

  local result = t[1]

  if not ignore[result] then
    setignore(result, { because = "you were missing the enchantment" })

    echo'\n' echofn("Looks like you don't have %s anymore - I'll put it on ignore then, take it off later with '", result)

    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)

    echoLink("vignore "..result, 'svo.ignore.'..result..' = nil svo.echof("Removed '..result..' from the ignore list (will be doing it now).")', 'Click here take '..result..' off the ignore list', true)
    setUnderline(false)
    echo"'.\n"

    killaction(dict[result].physical)
  end
end

-- a function to stop any light* actions and put all current non-artefact pipes on ignore
function missing_tinderbox()
  -- find which pipes were we lighting and kill those actions. We we were lighting at least one, figure out which pipes are non-arty, get a list, put them on ignore and say which ones we've added to ignore now

  local gotaction
  if actions.lightvalerian_physical then
    killaction(dict.lightvalerian.physical); gotaction = true
  end
  if actions.lightelm_physical then
    killaction(dict.lightelm.physical); gotaction = true
  end
  if actions.lightskullcap_physical then
    killaction(dict.lightskullcap.physical); gotaction = true
  end

  -- if we weren't lighting - then... this might not be real!
  if not gotaction then return end

  -- find out which pipes are not artefact & ignore
  local realthing, assumedname = {}, {}
  for id = 1, #pipes.pnames do
    local herb, pipe = pipes.pnames[id], pipes[pipes.pnames[id]]
    if not pipe.arty and not ignore["light"..herb] then
      realthing[#realthing+1] = "light"..herb
      assumedname[#assumedname+1] = pipe.filledwith
      setignore("light"..herb, { because = "you were missing a tinderbox" })
    end
  end

  if realthing[1] then
    echo"\n" echof("Looks like you don't have a tinderbox! I've put non-artefact pipes - %s on the ignore list (under the names of %s). To unignore them, check vshow ignore.", concatand(assumedname), concatand(realthing))
  end
end

function valid.restoration_noeffect()
  local r = checkany(
  dict.curingheartseed.waitingfor, dict.curingmangledleftleg.waitingfor, dict.curingmangledrightleg.waitingfor, dict.curingmangledrightarm.waitingfor, dict.curingmangledleftarm.waitingfor, dict.curingmutilatedrightarm.waitingfor, dict.curingmutilatedleftarm.waitingfor, dict.curingparestolegs.waitingfor, dict.curingmildtrauma.waitingfor, dict.curingserioustrauma.waitingfor, dict.curingmutilatedrightleg.waitingfor, dict.curingmutilatedleftleg.waitingfor, dict.curingseriousconcussion.waitingfor, dict.curingmildconcussion.waitingfor, dict.curinglaceratedthroat.waitingfor)

  if not r then return end

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "noeffect")
  end
end

function valid.ate_moss()
  local result = checkany(dict.healhealth.moss, dict.healmana.moss)

  if not result then return end

  herb_cure = true
  lifevision.add(actions[result.name].p)
end
valid.generic_ate_moss = valid.ate_moss

function valid.noeffect_moss()
  local r = checkany(dict.healhealth.moss, dict.healmana.moss)
  if not r then return end

  herb_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, "noeffect")
  end
end

function valid.got_waterbubble()
  checkaction(dict.waterbubble.herb)

  herb_cure = true
  if actions.waterbubble_herb then
    lifevision.add(actions.waterbubble_herb.p)
  end
end

function defs.gotherb_myrrh()
  checkaction(dict.myrrh.herb)

  herb_cure = true
  if actions.myrrh_herb then
    lifevision.add(actions.myrrh_herb.p)
  end
end

function defs.gotherb_kola()
  checkaction(dict.kola.herb)

  herb_cure = true
  if actions.kola_herb then
    lifevision.add(actions.kola_herb.p)
  end
end

function defs.gotherb_deathsight()
  checkaction(dict.deathsight.herb)

  herb_cure = true
  if actions.deathsight_herb then
    lifevision.add(actions.deathsight_herb.p)
  end
end

function defs.gotskill_deathsight()
  checkaction(dict.deathsight.physical)
  if actions.deathsight_physical then
    lifevision.add(actions.deathsight_physical.p)
  end
end

function defs.gotherb_thirdeye()
  checkaction(dict.thirdeye.herb)

  herb_cure = true
  if actions.thirdeye_herb then
    lifevision.add(actions.thirdeye_herb.p)
  end
end

function defs.gotskill_thirdeye()
  checkaction(dict.thirdeye.misc)
  if actions.thirdeye_misc then
    lifevision.add(actions.thirdeye_misc.p)
  end
end

function defs.gotherb_insomnia()
  checkaction(dict.insomnia.herb)

  herb_cure = true
  if actions.insomnia_herb then
    lifevision.add(actions.insomnia_herb.p)
  end
end

function defs.gotskill_insomnia()
  if actions.checkhypersomnia_misc then
    lifevision.add(actions.checkhypersomnia_misc.p, "onclear")
  end


  checkaction(dict.insomnia.misc)
  if actions.insomnia_misc then
    lifevision.add(actions.insomnia_misc.p)
  end
end

function valid.generic_insomnia()
  local r = checkany(dict.insomnia.herb, dict.insomnia.misc)

  if not r then return end

  herb_cure = true
  lifevision.add(actions[r.name].p)
end

function valid.insomnia_hypersomnia()
  local r = checkany(dict.insomnia.herb, dict.insomnia.misc)

  if r then
    herb_cure = true
    lifevision.add(actions[r.name].p, "hypersomnia")
  elseif actions.checkhypersomnia_misc then
    lifevision.add(actions.checkhypersomnia_misc.p, "hypersomnia")
    decho(getDefaultColor().." (hypersomnia confirmed)")
  elseif not conf.aillusion then
    valid.simplehypersomnia()
  elseif not affs.hypersomnia then
    checkaction(dict.checkhypersomnia.aff, true)
    lifevision.add(actions.checkhypersomnia_aff.p)
  end
end

function defs.salve_got_caloric()
  local r = checkany(dict.frozen.salve, dict.shivering.salve, dict.caloric.salve)

  if not r then return end

  apply_cure = true
  local hypothermia = find_until_last_paragraph("You are far too frozen to relieve your shivers.", "exact")
  lifevision.add(actions[r.name].p, "gotcaloricdef", hypothermia)
end

function defs.salve_got_mass()
  checkaction(dict.mass.salve)
  apply_cure = true
  if actions.mass_salve then
    lifevision.add(actions.mass_salve.p)
  end
end


local generic_cures_data = {
  "ablaze", "addiction", "aeon", "agoraphobia", "anorexia", "asthma", "blackout", "bleeding", "bound", "burning", "claustrophobia", "clumsiness", "mildconcussion", "confusion", "crippledleftarm", "crippledleftleg", "crippledrightarm", "crippledrightleg", "darkshade", "deadening", "dementia", "disloyalty", "disrupt", "dissonance", "dizziness", "epilepsy", "fear", "galed", "generosity", "haemophilia", "hallucinations", "healthleech", "heartseed", "hellsight", "hypersomnia", "hypochondria", "icing", "illness", "impale", "impatience", "inlove", "inquisition", "itching", "justice", "laceratedthroat", "lethargy", "loneliness", "lovers", "madness", "mangledleftarm", "mangledleftleg", "mangledrightarm", "mangledrightleg", "masochism", "mildtrauma", "mutilatedleftarm", "mutilatedleftleg", "mutilatedrightarm", "mutilatedrightleg", "pacifism", "paralysis", "paranoia", "peace", "prone", "recklessness", "relapsing", "roped", "selarnia", "sensitivity", "seriousconcussion", "serioustrauma", "shyness", "slashedthroat", "slickness", "stun", "stupidity", "stuttering", "transfixed", "unknownany", "unknowncrippledarm", "unknowncrippledleg", "unknownmental", "vertigo", "voided", "voyria", "weakness", "webbed", "healhealth", "healmana", "hamstring", "shivering", "frozen", "hallucinations", "stain", "rixil", "palpatar", "cadmus", "hecate", "spiritdisrupt", "airdisrupt", "firedisrupt", "earthdisrupt", "waterdisrupt",
}

for i = 1, #generic_cures_data do
  local aff = generic_cures_data[i]

  valid["generic_"..aff] = function ()

    -- passive curing...
    if passive_cure_paragraph and dict[aff].gone then
      checkaction(dict[aff].gone, true)
      if actions[aff .. "_gone"] then
        lifevision.add(actions[aff .. "_gone"].p)
      end
      return
    end

    -- ... or something we caused.
    if actions_performed[aff] then
      lifevision.add(actions[actions_performed[aff].name].p)

    -- if it's not something we were directly doing, try to link by balances
    else
      local result

      for j,k in actions:iter() do
        if k and k.p.balance ~= "waitingfor" and k.p.balance ~= "aff" and dict[aff][k.p.balance] then result = k.p break end
      end

      if not result then -- maybe tree?
        if actions.touchtree_misc then
          lifevision.add(actions.touchtree_misc.p, nil, aff)
          tree_cure = true
        elseif actions.restore_physical then
          lifevision.add(actions.restore_physical.p)
          valid.passive_cure()
        end
        return
      end

      killaction(dict[result.action_name][result.balance])

      checkaction(dict[aff][result.balance], true)
      lifevision.add(dict[aff][result.balance])
    end
  end
end

disable_generic_trigs = function ()
  disableTrigger("General cures")
  enableTrigger("Ate")
  enableTrigger("Sip")
  enableTrigger("Applied")
  enableTrigger("Smoke")
  enableTrigger("Focus mind")
end

enable_generic_trigs = function ()
  enableTrigger("General cures")
  disableTrigger("Ate")
  disableTrigger("Sip")
  disableTrigger("Applied")
  disableTrigger("Smoke")
  disableTrigger("Focus mind")
end

check_generics = function ()
  if affs.blackout and not generics_enabled then
    generics_enabled = true
    generics_enabled_for_blackout = true
    enable_generic_trigs()
    echo("\n")
    echof("Enabled blackout curing.")
  elseif generics_enabled and generics_enabled_for_blackout and not affs.blackout and not actions.blackout_aff then
    generics_enabled_for_blackout, generics_enabled = false, false
    disable_generic_trigs()
    echo("\n")
    echof("Out of blackout, disabled blackout curing.")
  elseif passive_cure_paragraph and not generics_enabled and not generics_enabled_for_passive then
    generics_enabled_for_passive, generics_enabled = true, true
    enable_generic_trigs ()
  elseif not passive_cure_paragraph and generics_enabled and generics_enabled_for_passive then
    generics_enabled_for_passive, generics_enabled = false, false
    disable_generic_trigs ()
  end
end
disable_generic_trigs()
check_generics()

signals.systemstart:connect(function ()
  disableTrigger("General cures")
  if conf.aillusion then enableTrigger("Pre-parse anti-illusion")
  else disableTrigger("Pre-parse anti-illusion") end
end)

-- passive cures
function valid.passive_cure()
  local affn = table.size(affs)
  passive_cure_paragraph = true
  check_generics()
  sk.onprompt_beforeaction_add("check for unknowns", function ()
    -- if the counts are the same, then we cured something we didn't know about
    -- this does not need lifevision validation, being done post-fact
    if affn == table.size(affs) then
      if affs.unknownmental then
        dict.unknownmental.count = dict.unknownmental.count - 1
        if dict.unknownmental.count <= 0 then removeaff("unknownmental"); dict.unknownmental.count = 0
        else updateaffcount(dict.unknownmental) end
      elseif affs.unknownany then
        dict.unknownany.count = dict.unknownany.count - 1
        if dict.unknownany.count <= 0 then removeaff("unknownany"); dict.unknownany.count = 0 else
          updateaffcount(dict.unknownany)
        end
      end
    end
  end)
  sk.onprompt_beforeaction_add("check generics", function () passive_cure_paragraph = false; check_generics() end)
  signals.after_lifevision_processing:unblock(cnrl.checkwarning)
end

function valid.underwater_nopear()
  if not conf.aillusion then eat(dict.waterbubble.herb) else
    local oldhealth = stats.currenthealth
    sk.onprompt_beforeaction_add("check for pear damage", function ()
      if stats.currenthealth < oldhealth then
        eat(dict.waterbubble.herb)
      end
    end)
  end
end

-- the voided timer at the moment account for multiple pommelstrikes occuring
function valid.pommelstrike()
end

function valid.dragonflex()
  checkaction (dict.dragonflex.misc)
  if actions.dragonflex_misc then
    lifevision.add(actions.dragonflex_misc.p)
  end
end

function valid.dwinnu()
  checkaction (dict.dwinnu.misc)
  if actions.dwinnu_misc then
    lifevision.add(actions.dwinnu_misc.p)
  end
end

function valid.got_blind()
  sk.onprompt_beforeaction_add("hypochondria_blind", function ()
    if not affs.blindaff and not defs.blind then
      valid.simplehypochondria()
    end
  end)
end

function valid.venom_crippledrightleg()
  if paragraph_length ~= 1 then
    valid.simplecrippledrightleg()
  else
    sk.hypochondria_symptom()
  end
end
function valid.venom_crippledleftleg()
  if paragraph_length ~= 1 then
    valid.simplecrippledleftleg()
  else
    sk.hypochondria_symptom()
  end
end
-- might not be hypochondria, but plague vibe
function valid.proper_clumsiness()
    valid.simpleclumsiness()
end
function valid.proper_weakness()
  if paragraph_length ~= 1 then
    valid.simpleweakness()
  else
    sk.hypochondria_symptom()
  end
end
function valid.proper_disloyalty()
  if paragraph_length ~= 1 then
    valid.simpledisloyalty()
  else
    sk.hypochondria_symptom()
  end
end
function valid.proper_illness()
  if paragraph_length ~= 1 then
    valid.simpleillness()
  else
    sk.hypochondria_symptom()
  end
end
function valid.proper_lethargy()
  if paragraph_length ~= 1 or affs.torntendons or find_until_last_paragraph("You stumble as you are afflicted with", "substring") then
    valid.simplelethargy()
  else
    sk.hypochondria_symptom()
  end
end
-- skullfractures makes the affliction come back on its own
function valid.proper_addiction()
  if paragraph_length ~= 1 or affs.skullfractures then
    valid.simpleaddiction()
  else
    sk.hypochondria_symptom()
  end
end
function valid.proper_anorexia()
  if not conf.aillusion then
    if paragraph_length ~= 1 or find_until_last_paragraph("With a characteristic Jaziran trill", "substring") then
      valid.simpleanorexia()
    else
      sk.hypochondria_symptom()
    end
  else
    checkaction(dict.checkanorexia.aff, true)
    lifevision.add(actions.checkanorexia_aff.p)
  end
end

-- traps can give this
function valid.proper_slickness()
  if paragraph_length ~= 1 then
    valid.simpleslickness()
  else
    sk.hypochondria_symptom()
  end
end
function valid.proper_recklessness(attacktype)
  if not conf.aillusion then
    valid.simplerecklessness()
  else
    checkaction(dict.recklessness.aff, true)
    if actions.recklessness_aff then
      lifevision.add(actions.recklessness_aff.p, nil, {oldhp = stats.currenthealth, oldmana = stats.currentmana, attacktype = attacktype, atline = getLastLineNumber("main")})
    end
  end
end
function valid.proper_recklessness2()
  if not conf.aillusion then
    valid.simplerecklessness()
  else
    checkaction(dict.recklessness.aff, true)
    if actions.recklessness_aff then
      if find_until_last_paragraph("wracks", "substring") or find_until_last_paragraph("points an imperious finger at you", "substring") or find_until_last_paragraph("A heavy burden descends upon your soul as", "substring") or find_until_last_paragraph("stares at you, giving you the evil eye", "substring") or find_until_last_paragraph("glowers at you with a look of repressed disgust before making a slight gesture toward you.", "substring") or find_until_last_paragraph("smashing your temple with a backhanded blow", "substring") then
        lifevision.add(actions.recklessness_aff.p, nil, {oldhp = stats.currenthealth, attacktype = attacktype, atline = getLastLineNumber("main")})
      else
        lifevision.add(actions.recklessness_aff.p, nil, {oldhp = stats.currenthealth, attacktype = attacktype, atline = getLastLineNumber("main")}, 1)
      end
    end
  end
end
function valid.venom_crippledleftarm()
  if paragraph_length ~= 1 then
    valid.simplecrippledleftarm()
  else
    sk.hypochondria_symptom()
  end
end
function valid.venom_crippledrightarm()
  if paragraph_length ~= 1 then
    valid.simplecrippledrightarm()
  else
    sk.hypochondria_symptom()
  end
end

function valid.lost_arena()
  echo"\n"
  echof("I'm sorry =(")

  reset.affs()
  reset.general()
  reset.defs()
end

function valid.lost_ffa()
  local oldroom = (atcp.RoomNum or gmcp.Room.Info.num)
  sk.onprompt_beforeaction_add("arena_death",
    function ()
      if oldroom ~= (atcp.RoomNum or gmcp.Room.Info.num) then
        reset.affs()
        reset.general()
        reset.defs()
      end
    end)
end

function valid.won_arena()
  echo"\n"
  if math.random(10) == 1 then echof("Winnar!")
  else echof("You won!") end

  -- rebounding coming up gets killed
  if actions.waitingonrebounding_waitingfor then
    killaction(dict.waitingonrebounding.waitingfor)
  end

  reset.affs()

  -- blind/insomnia/deaf get reset too
  defences.lost("blind") defences.lost("deaf") defences.lost("insomnia")
end

function valid.soulcaged()
  reset.affs()
  reset.general()
  reset.defs()
  if type(conf.burstmode) == "string" then
    echo"\n"echof("Auto-switching to %s defences mode.", conf.burstmode)
    defs.switch(conf.burstmode, false)
  end
end

function valid.died()
  if line == "Your starburst tattoo flares as the world is momentarily tinted red." then
    sk.onprompt_beforeaction_add("death",
      function ()
        if affs.recklessness or (stats.currenthealth == stats.maxhealth and stats.currentmana == stats.maxmana) then
          reset.affs()
          reset.general()
          reset.defs()
          rift.resetinvcontents()
          echo "\n" echof("We hit starburst!")
          signals.before_prompt_processing:unblock(valid.check_life)
          if type(conf.burstmode) == "string" then
            echof("Auto-switching to %s defences mode.", conf.burstmode)
            defs.switch(conf.burstmode, false)
          end

          -- rebounding coming up gets cancelled
          if actions.waitingonrebounding_waitingfor then killaction(dict.waitingonrebounding.waitingfor) end

          raiseEvent("svo died", "starburst")
        end
      end)
  elseif not conf.paused then
    sk.onprompt_beforeaction_add("death",
      function ()
        if affs.recklessness or stats.currenthealth == 0 then
          reset.affs()
          reset.general()
          reset.defs()
          rift.resetinvcontents()

          -- rebounding coming up gets cancelled
          if actions.waitingonrebounding_waitingfor then killaction(dict.waitingonrebounding.waitingfor) end

          echo "\n"
          if math.random(1,10) == 1 then
            echo[[



                   __, _ __,   _, _ __,
                   |_) | |_)   |\/| |_
                   | \ | |     |  | |
                   ~ ~ ~ ~     ~  ~ ~~~


 ]]
          elseif math.random(1, 25) == 1 then
            echo[[


             _     _      _     _      _     _      _     _
            (c).-.(c)    (c).-.(c)    (c).-.(c)    (c).-.(c)
             / x_x \      / x_x \      / x_x \      / x_x \
           __\( Y )/__  __\( Y )/__  __\( Y )/__  __\( Y )/__
          (_.-/'-'\-._)(_.-/'-'\-._)(_.-/'-'\-._)(_.-/'-'\-._)
             || D ||      || E ||      || A ||      || D ||
           _.' `-' '._  _.' `-' '._  _.' `-' '._  _.' `-' '._
          (.-./`-'\.-.)(.-./`-'\.-.)(.-./`-'\.-.)(.-./`-'\.-.)
           `-'     `-'  `-'     `-'  `-'     `-'  `-'     `-'


            ]]
          else
            echo"\n"echof("We died.") end
          conf.paused = true
          signals.before_prompt_processing:unblock(valid.check_life)
          raiseEvent("svo died")
          raiseEvent("svo config changed", "paused")
        elseif stats.currenthealth == stats.maxhealth and stats.currentmana == stats.maxmana and find_until_last_paragraph("Your starburst tattoo flares as the world is momentarily tinted red.", "exact") then -- in case something else came between "you died" and starburst
          reset.affs()
          reset.general()
          reset.defs()
          rift.resetinvcontents()

          -- rebounding coming up gets cancelled
          if actions.waitingonrebounding_waitingfor then killaction(dict.waitingonrebounding.waitingfor) end

          echo "\n" echof("We hit starburst!")
          signals.before_prompt_processing:unblock(valid.check_life)
          if type(conf.burstmode) == "string" then
            echof("Auto-switching to %s defences mode.", conf.burstmode)
            defs.switch(conf.burstmode, false)
          end
          raiseEvent("svo died", "starburst")
        end
      end)
  end
end

function valid.check_life()
  if stats.currenthealth ~= 0 then
    echo"\n" echof("Welcome back to life! System unpaused.")
    conf.paused = false
    raiseEvent("svo config changed", "paused")
    signals.before_prompt_processing:block(valid.check_life)
  end
end
signals.before_prompt_processing:connect(valid.check_life)
signals.before_prompt_processing:block(valid.check_life)


function valid.check_recklessness()
  local vitals = gmcp.Char.Vitals

  -- check against GMCP, as Svof modifies them
  if affs.recklessness and (vitals.mp < vitals.maxmp or vitals.hp < vitals.maxhp) then
    removeaff("recklessness")
  end
end
signals.before_prompt_processing:connect(valid.check_recklessness)
-- toggled inside svo.dict
signals.before_prompt_processing:block(valid.check_recklessness)


function valid.limb_hit(which, attacktype)
  if not sp_limbs[which] then return end

  me.lasthitlimb = which

  if selectString(which, 1) ~= -1 then
    fg(conf.highlightparryfg)
    bg(conf.highlightparrybg)
    deselect()
    resetFormat()
  else -- things like BM slashes don't say the limb, but say the plural name of it - legs, arms.
    local plural = which:sub(-3).."s"

    if selectString(plural, 1) ~= -1 then
      fg(conf.highlightparryfg)
      bg(conf.highlightparrybg)
      deselect()
      resetFormat()
    end
  end

  signals.after_lifevision_processing:unblock(sp_checksp)
  signals.limbhit:emit(which, attacktype)
  raiseEvent("svo limb hit", which, attacktype)
end

local function saw_tekura_in_paragraph()
  return
    -- punches
    find_until_last_paragraph("balls up one fist and hammerfists you", "substring") or
    find_until_last_paragraph("forms a spear hand and stabs out at you", "substring") or
    find_until_last_paragraph("launches a powerful uppercut at you", "substring") or
    find_until_last_paragraph("unleashes a powerful hook towards you", "substring") or

    -- kicks
    find_until_last_paragraph("lets fly at you with a snap kick", "substring") or
    find_until_last_paragraph("towards you with a lightning-fast moon kick", "substring") or
    find_until_last_paragraph("leg high and scythes downwards at you", "substring") or
    find_until_last_paragraph("pumps out at you with a powerful side kick", "substring") or
    find_until_last_paragraph("spins into the air and throws a whirlwind kick towards you", "substring") or
    find_until_last_paragraph("The blow sends a shock of pain through you, your muscles reflexively locking in response.", "exact")
end

-- count up how much tekura stuff have we seen in the paragraph so far. If more than two things, then count this as a combo.
local function all_in_one_tekura()
  local c =
    -- punches
    count_until_last_paragraph("balls up one fist and hammerfists you", "substring") +
    count_until_last_paragraph("forms a spear hand and stabs out at you", "substring") +
    count_until_last_paragraph("launches a powerful uppercut at you", "substring") +
    count_until_last_paragraph("unleashes a powerful hook towards you", "substring") +

    -- kicks
    count_until_last_paragraph("lets fly at you with a snap kick", "substring") +
    count_until_last_paragraph("drops to the floor and sweeps his legs round at you.", "substring") +
    count_until_last_paragraph("drops to the floor and sweeps her legs round at you.", "substring") +
    count_until_last_paragraph("knocks your legs out from under you and sends you sprawling to the floor.", "substring") +
    count_until_last_paragraph("towards you with a lightning-fast moon kick", "substring") +
    count_until_last_paragraph("leg high and scythes downwards at you", "substring") +
    count_until_last_paragraph("pumps out at you with a powerful side kick", "substring") +
    count_until_last_paragraph("spins into the air and throws a whirlwind kick towards you", "substring") +
    count_until_last_paragraph("The blow sends a shock of pain through you, your muscles reflexively locking in response.", "exact")

    return (c >= 2) and true or false
end


for _,name in ipairs({"rightarm", "leftarm", "leftleg", "rightleg"}) do
  for _, status in ipairs({"mangled", "mutilated"}) do
    valid["proper_"..status..name] = function ()
      -- idea: see if any previous lines contain the limb name; it would have to be included in the msg
      if conf.aillusion then
        local limb = string.format("%s %s", string.match(name, "(%w+)(%w%w%w)"))
        local plural = name:sub(-3).."s"

        -- last line doesn't work with stuff like bm breaks, where it is limb\anothermsg\actualbreak. So go until the prompt.
        local previouslinenumber, currentlinenumber = lastpromptnumber+1, getLastLineNumber("main")

        -- workaround for deleteLine() making lastpromptnumber's tracking get invalidated
        if currentlinenumber <= previouslinenumber then
          previouslinenumber = currentlinenumber - 1
        end

        -- this, with short enough wrapping, might not get the line that the rend starts on. So if this line doesn't start with a capital, pull in one more line
        local combined = table.concat(getLines(previouslinenumber, currentlinenumber))

        if not combined:sub(1,1):match("%u") then
          combined = table.concat(getLines(previouslinenumber-1, currentlinenumber))
        end

        -- remember blackout, don't check this in it
        if not affs.blackout and (combined:find(limb, 1, true) or combined:find(plural, 1, true)) then
          -- special exception for blademaster breaks, which do so little damage, you can regen it:
          --[[Spinning to the right as he draws 11 11 from its sheath, 11 delivers a precise slash across your arms.
              Your left arm is greatly damaged from the beating. (+65h, 0.8%, +75m, 1.1%) ]]
          if find_until_last_paragraph("^Spinning to the right as s?he draws %w+ %w+ from its sheath, %w+ delivers a precise slash across your arms%.$", "pattern") then
            valid["simple"..status..name]()
          elseif saw_tekura_in_paragraph() then
            checkaction(dict[status..name].aff, true)
            lifevision.add(actions[status..name.."_aff"].p, "tekura", stats.currenthealth)
          else
            checkaction(dict[status..name].aff, true)
            lifevision.add(actions[status..name.."_aff"].p, nil, stats.currenthealth)
          end

          tempLineTrigger(1,1, [[
            if line == "Your shield completely absorbs the damage." then
              svo.valid.simple]]..status..name..[[() end]]
          )
        else
          debugf("Didn't find limb (%s) or plural (%s) in combined (%s)", limb, plural, combined)
        end
      else -- anti-illusion off
        -- when we see a tekura combo, try to add all the mangles at the end of it, so the priorities take effect - instead of being dictated by first-hit
        if saw_tekura_in_paragraph() then

          -- if this is an all-in-one combo, don't queue up the hits
          if all_in_one_tekura() then
            checkaction(dict[status..name].aff, true)
            lifevision.add(actions[status..name.."_aff"].p, nil, stats.currenthealth)

            -- clear a delayed break if there was one
            if sk.delaying_break then
              killTimer(sk.delaying_break); sk.delaying_break = nil
              for _, aff in ipairs(sk.tekura_mangles) do
                addaff(dict[aff])
              end
              sk.tekura_mangles = nil
            end
          else
            -- not an all-in-one combo, or the first hit of it
            if not sk.delaying_break then
              sk.delaying_break = tempTimer(getNetworkLatency() + conf.tekura_delay, function() -- from the first hit, it's approximately getNetworkLatency() time until the second - add the conf.tekura_delay to allow for variation in ping
                sk.delaying_break = nil

                for _, aff in ipairs(sk.tekura_mangles) do
                  addaff(dict[aff])
                end
                sk.tekura_mangles = nil
                signals.after_lifevision_processing:unblock(cnrl.checkwarning)
                signals.canoutr:emit()
                make_gnomes_work()
              end)
            end

            sk.tekura_mangles = sk.tekura_mangles or {}
            sk.tekura_mangles[#sk.tekura_mangles+1] = status..name
          end
        else
          checkaction(dict[status..name].aff, true)
          lifevision.add(actions[status..name.."_aff"].p, nil, stats.currenthealth)
        end
      end
    end
  end
end

for _, name in ipairs({"serioustrauma", "mildtrauma", "mildconcussion", "seriousconcussion"}) do
  valid["proper_"..name] = function ()
    checkaction(dict[name].aff, true)
    lifevision.add(actions[name.."_aff"].p, nil, stats.currenthealth)
    tempLineTrigger(1,1, [[
      if line == "Your shield completely absorbs the damage." then
        svo.valid.simple]]..name..[[()
      end
    ]])
  end
end

valid.generic_burn = function (number)
  assert(not number or tonumber(number), "svo.valid.simpleburn: how many removals do you want to do? Must be a number")

  checkaction(dict.ablaze.gone, true)

  if lifevision.l.ablaze_gone then
    lifevision.add(actions.ablaze_gone.p, "generic_reducelevel", (number or 1) +(lifevision.l.ablaze_gone.arg or 1))
  else
    lifevision.add(actions.ablaze_gone.p, "generic_reducelevel", (number or 1))
  end
end

valid.low_willpower = sk.checkwillpower

valid.healercure = function () end
valid.healing_cured_insomnia = valid.healercure
valid.nohealbalance = valid.healercure
valid.bedevilheal = valid.healercure

valid.ragecure = function() end

valid.transmuted = function() end

-- possibly suspectible to sylvans double-doing it, or a sylvan doing & illusioning it?
function valid.sylvan_heartseed()
  if not conf.aillusion or affs.mildtrauma then
    valid.simpleheartseed()
  else
    tempTimer(5, function () sk.heartseed2window = true end)
    tempTimer(10, function () sk.heartseed2window = false end)
  end
end

function valid.sylvan_heartseed2()
  if not affs.heartseed and (not conf.aillusion or sk.heartseed2window) then
    valid.simpleheartseed()
  end
end

function valid.sylvan_eclipse()
  sk.sylvan_eclipse = true
  tempTimer(10, function () sk.sylvan_eclipse = nil end)
end

function valid.sylvan_lacerate1()
  checkaction(dict.slashedthroat.aff, true)
  lifevision.add(actions.slashedthroat_aff.p, "sylvanhit", stats.currenthealth)
end

function valid.sylvan_lacerate2()
  checkaction(dict.laceratedthroat.aff, true)
  lifevision.add(actions.laceratedthroat_aff.p, "sylvanhit", stats.currenthealth)
end

function svo.connected()
  signals.connected:emit()
end

function valid.stripped_caloric()
  checkaction(dict.caloric.gone, true)
  if actions.unknownany_aff then
    lifevision.add(actions.caloric_gone.p, nil, "unknownany")
  elseif actions.unknownmental_aff then
    lifevision.add(actions.caloric_gone.p, nil, "unknownmental")
  else
    lifevision.add(actions.caloric_gone.p)
  end
end

function valid.stripped_insomnia()
  checkaction(dict.insomnia.gone, true)
  if actions.unknownany_aff then
    lifevision.add(actions.insomnia_gone.p, nil, "unknownany")
  elseif actions.unknownmental_aff then
    lifevision.add(actions.insomnia_gone.p, nil, "unknownmental")
  else
    lifevision.add(actions.insomnia_gone.p)
  end
end

valid.lacking_channels = function() end

function valid.bubbleout()
  if not conf.aillusion then eat(dict.waterbubble.herb) end
end

-- check if we're the ones who got hit with it
function valid.aeon_card()
  if not affs.blackout then return end

  -- if sk.aeon_thrown then killTimer(sk.aeon_thrown) end
  -- sk.aeon_thrown = tempTimer(4, function() sk.aeon_thrown = nil end)

  -- account for lag between shuffle and throw, try and check for aeon
  tempTimer(0.2, function()
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, "aeon")
  end)

  tempTimer(0.7, function()
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, "aeon")
  end)
end

function valid.lust_card()
  if not affs.blackout then return end

  -- if sk.aeon_thrown then killTimer(sk.aeon_thrown) end
  -- sk.aeon_thrown = tempTimer(4, function() sk.aeon_thrown = nil end)

  -- account for lag between shuffle and throw, try and check for aeon
  tempTimer(0.2+getNetworkLatency(), function()
    if not sys.sync then echof("Checking allies for potential lust...") send("allies", conf.commandecho) end
  end)

  dict.blackout.check_lust = true
end

function defs.cant_empower()
  if actions.empower_physical then
    local off = {}

    if defkeepup[defs.mode].empower then
      svo.defs.keepup("empower", false)
      off[#off+1] = "keepup"
    end

    if defdefup[defs.mode].empower then
      svo.defs.defup("empower", false)
      off[#off+1] = "defup"
    end

    echo"\n" echof("Seems that you can't empower yet - so I took it off %s for you.", table.concat(off, ", "))
  end
end

function ignore_snake_bite()
  if not find_until_last_paragraph("You scream out in agony as a vicious venom tears through your body.", "exact")
    and not find_until_last_paragraph("You gasp as a terrible aching strikes all your limbs.", "exact")
   then ignore_illusion("Ignored the single-aff bite (vconfig ignoresinglebites is on)", true) return end
end

function valid.stop_wielding()
  checkaction(dict.rewield.physical)
  if actions.rewield_physical then
    lifevision.add(actions.rewield_physical.p, "clear")
  end
end

function valid.reflection_cancelled()
  if conf.aillusion and paragraph_length == 1 and not conf.batch then return end

  for _, action in pairs(lifevision.l:keys()) do
    if action:find("_aff", 1, true) then
      killaction(dict[action:match("(%w+)_")].aff)

      -- typically, you'd only have one aff per prompt - so no need to complicate by optimizing
      selectCurrentLine()
      fg("MediumSlateBlue")
      deselect()
      resetFormat()
    end
  end
end

function valid.homunculus_throat()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then ignore_illusion("This needs to be on it's own line.") return end

  lostbal_focus()
end

function valid.retardation_gone()
  checkaction(dict.retardation.gone, true)
  lifevision.add(actions["retardation_gone"].p)

  -- re-check to make sure it's true
  if conf.aillusion then
    checkaction(dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, "retardation")
  end
end

function valid.soa()
  if not conf.aillusion then return end

  if paragraph_length == 2 and (find_until_last_paragraph("greatly damaged from the beating", "substring") or find_until_last_paragraph("has been mutilated beyond repair by ordinary means", "substring")) then
    ignore_illusion("This looks pretty fake - can't get a limb-break and an SoA hit without anyone poking it", true)
  end
end

function valid.enmesh_start()
  if conf.aillusion and paragraph_length ~= 1 and not conf.batch then ignore_illusion("Enmesh can't be chained with other things at once") return end

  -- kill previous timers and set them for future. An enmesh hits at 5s after it was started
  if sys.enmesh1timer then killTimer(sys.enmesh1timer) end
  if sys.enmesh2timer then killTimer(sys.enmesh2timer) end

  sys.enmesh1timer = tempTimer(3, function() sys.enmesh1timer = nil end)

  sys.enmesh2timer = tempTimer(7+getNetworkLatency(), function() sys.enmesh2timer = nil end)
end

function valid.enmesh_hit()
  if not conf.aillusion or (sys.enmesh2timer and not sys.enmesh1timer) then
    valid.simpleroped()
  else
    ignore_illusion("We weren't getting enmeshed, this looks fake.")
  end
end

function valid.chaosrays()
  if not conf.aillusion then return end

  -- first and easiest case: you got hit by it directly, nobody died and bugged the game out
  if find_until_last_paragraph("Seven rays of different coloured light spring out from", "substring") then return end

  -- second, more difficult case - somebody died, go back until the previous prompt, see if anyone else died too
  if paragraph_length == 1 then
    local checking, getLines = getLineNumber()-1, getLines -- start checking lines 2 back, as 1 back will be prompt

    local line = getLines(checking-1, checking)[1]
    if line:find("Unable to withstand the rays of chaos", 1, true) or line:find("falls from", 1, true) then return end
  end

  ignore_illusion("This looks fake!")
end

function valid.proper_stain()
  if not conf.aillusion then
    valid.simplestain()
  else
    checkaction(dict.stain.aff, true)
    lifevision.add(actions.stain_aff.p, nil, stats.maxhealth)
  end
end

function valid.gothit(class, name)
  checkaction(dict.gothit.happened, true)
  dict.gothit.happened.tempmap[name or "?"] = class
  lifevision.add(actions.gothit_happened.p)
end

function valid.dcurse_start(whom)
  if not conf.aillusion or sk.dcurse_start then return end

  sk.dcurse_start = {tempTimer(10.5+getNetworkLatency(), function() sk.dcurse_start = nil end), whom}
end

function valid.dcurse_hit(aff)
  if conf.aillusion and not sk.dcurse_start then return end

  (valid["proper_"..aff] or valid["simple"..aff])()
end

function svo.valid.broken_legs()
  if not affs.crippledrightleg and not affs.mangledrightleg and not affs.mutilatedrightleg
    and not affs.crippledleftleg and not affs.mangledleftleg and not affs.mutilatedleftleg and not affs.unknowncrippledlimb and not affs.unknowncrippledleg and not affs.hamstring then
    valid.simpleunknowncrippledleg()

    -- cancel potential stand
    if actions.prone_misc then
      killaction(dict.prone.misc)
    end
  end
end

-- remove unknown level if the affliction from a symptom was not present before
valid.remove_unknownmental = function (affliction)
  if affs[affliction] then return end

  checkaction(dict.unknownmental.gone, true)
  lifevision.add(actions.unknownmental_gone.p, "lost_level")
end
valid.remove_unknownany = function (affliction)
  if affs[affliction] then return end

  checkaction(dict.unknownany.gone, true)
  lifevision.add(actions.unknownany_gone.p, "lost_level")
end

function valid.loki()
  valid.simpleunknownany()
end

--[[

|exp|91%H|93%M|cdb|[sleep st maso pr par hecate rop cl mad con ra1]
Your blood regains its ability to clot. -> claustrop
Thank Maya, the Great Mother! Your clumsiness has been cured. -> shyness
As a firelord glares at you, sudden agonising heat ignites in your veins. It is gone as swiftly as
it came, but you feel suddenly lightheaded. (i)

]]

-- Clumsiness to Shyness - Lethargy to Recklessness - Haemophilia to Claustrophobia - Health Leech to Agoraphobia - Sensitivity to Paranoia - Darkshade to Confusion
function valid.pyradius()
  local affmap = {
    ["clumsiness"]  = "shyness",
    ["darkshade"]   = "confusion",
    ["haemophilia"] = "claustrophobia",
    ["healthleech"] = "agoraphobia",
    ["lethargy"]    = "recklessness",
    ["sensitivity"] = "paranoia",
  }

  local cures = sk.getuntilprompt()
  local startline = getLineNumber()

  -- no affs cured?
  if #cures == 0 then return end

  for i = 1, #cures do
    moveCursor(0, startline-i)
    deleteLine()
  end
  moveCursorEnd()

  svo.valid.passive_cure() feedTriggers(table.concat(cures, "\n").."\n")

  sk.onprompt_beforelifevision_add("update pyradius", function()
    for _, action in pairs(lifevision.l:keys()) do
      local aff = action:match("^(%w+)")
      if affmap[aff] then
        (valid["proper_"..affmap[aff]] or valid["simple"..affmap[aff]])()
      end
    end
  end)

  -- have to force lifevision and all, since feedTriggers happens after the prompt
  send("\n")
end




function valid.proper_hamstring()
  checkaction(dict.hamstring.aff, true)
  lifevision.add(actions["hamstring_aff"].p, "renew")
end

function valid.alreadyprone()
  valid.simpleprone()

  if actions.lyre_physical then killaction(dict.lyre.physical) end
end

function valid.negation_gem()
  if not conf.aillusion then
    me.manualdefcheck = true
    defences.lost("shield")
  else
    prompttrigger("check negation gem", function()
      -- in cases where classes have +con/health adjusting buffs, test the line for a max health drop
      -- pending investigation on what happens to current health
    end)
  end
end

function valid.meta_glare()
  prompttrigger("check for stupidity or impatience", function()
    if find_until_last_paragraph("You shuffle your feet noisily, suddenly bored.", "exact") then
      addaff(dict.impatience)
    else
      addaff(dict.stupidity)
    end
  end)
end

function valid.bind_totem()
  if conf.aillusion and paragraph_length <= 1 and not conf.batch then ignore_illusion("This can't appear on its own, should only happen when you enter a room") end

  defs.lost_kola()
  valid.simplesleep()
  valid.simpletransfixed()
end

function valid.pummel()
  local oldhp = stats.hp
  aiprompt("check pummel damage", function()
    -- if the damage taken is more than 30%, then we are frozen
    if (oldhp - stats.hp) >= 25 then
      valid.simpleshivering()
      valid.simplefrozen()
    end
  end)
end

function valid.skirmish_drag()
  local result = checkany(dict.impale.misc, dict.curingimpale.waitingfor)

  if not result then return end
  lifevision.add(actions[result.name].p, "dragged")
end

function valid.cured_burn_health()
  local result = checkany(dict.ablaze.salve, dict.severeburn.salve, dict.extremeburn.salve, dict.charredburn.salve, dict.meltingburn.salve)

  if not result then return end

  apply_cure = true
  if actions[result.name] then
    lifevision.add(actions[result.name].p)
  end
end

function valid.cured_burns_health()
  local result = checkany(dict.ablaze.salve, dict.severeburn.salve, dict.extremeburn.salve, dict.charredburn.salve, dict.meltingburn.salve)

  if not result then return end

  apply_cure = true
  if actions[result.name] then
    lifevision.add(actions[result.name].p, "all")
  end
end

function valid.tree_cured_burn()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "burn")
    tree_cure = true
  end
end

function valid.tree_cured_burns()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "all burns")
    tree_cure = true
  end
end

function valid.tree_cure_skullfractures()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    tree_cure = true
    lifevision.add(actions.touchtree_misc.p, nil, "skullfractures")
  end
end

function valid.tree_cured_skullfractures()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "skullfractures cured")
    tree_cure = true
  end
end

function valid.generic_cure_skullfractures()
  checkaction(dict.skullfractures.gone, true)
  if lifevision.l.skullfractures_gone then
    lifevision.add(actions.skullfractures_gone.p, "general_cure", (number or 1) + (lifevision.l.skullfractures_gone.arg or 1))
  else
    lifevision.add(actions.skullfractures_gone.p, "general_cure", (number or 1))
  end
end

function valid.generic_cured_skullfractures()
  checkaction(dict.skullfractures.gone, true)
  lifevision.add(actions.skullfractures_gone.p, "general_cured")
end
function valid.tree_cure_crackedribs()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    tree_cure = true
    lifevision.add(actions.touchtree_misc.p, nil, "crackedribs")
  end
end

function valid.tree_cured_crackedribs()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "crackedribs cured")
    tree_cure = true
  end
end

function valid.generic_cure_crackedribs()
  checkaction(dict.crackedribs.gone, true)
  if lifevision.l.crackedribs_gone then
    lifevision.add(actions.crackedribs_gone.p, "general_cure", (number or 1) + (lifevision.l.crackedribs_gone.arg or 1))
  else
    lifevision.add(actions.crackedribs_gone.p, "general_cure", (number or 1))
  end
end

function valid.generic_cured_crackedribs()
  checkaction(dict.crackedribs.gone, true)
  lifevision.add(actions.crackedribs_gone.p, "general_cured")
end
function valid.tree_cure_wristfractures()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    tree_cure = true
    lifevision.add(actions.touchtree_misc.p, nil, "wristfractures")
  end
end

function valid.tree_cured_wristfractures()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "wristfractures cured")
    tree_cure = true
  end
end

function valid.generic_cure_wristfractures()
  checkaction(dict.wristfractures.gone, true)
  if lifevision.l.wristfractures_gone then
    lifevision.add(actions.wristfractures_gone.p, "general_cure", (number or 1) + (lifevision.l.wristfractures_gone.arg or 1))
  else
    lifevision.add(actions.wristfractures_gone.p, "general_cure", (number or 1))
  end
end

function valid.generic_cured_wristfractures()
  checkaction(dict.wristfractures.gone, true)
  lifevision.add(actions.wristfractures_gone.p, "general_cured")
end
function valid.tree_cure_torntendons()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    tree_cure = true
    lifevision.add(actions.touchtree_misc.p, nil, "torntendons")
  end
end

function valid.tree_cured_torntendons()
  checkaction(dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, "torntendons cured")
    tree_cure = true
  end
end

function valid.generic_cure_torntendons()
  checkaction(dict.torntendons.gone, true)
  if lifevision.l.torntendons_gone then
    lifevision.add(actions.torntendons_gone.p, "general_cure", (number or 1) + (lifevision.l.torntendons_gone.arg or 1))
  else
    lifevision.add(actions.torntendons_gone.p, "general_cure", (number or 1))
  end
end

function valid.generic_cured_torntendons()
  checkaction(dict.torntendons.gone, true)
  lifevision.add(actions.torntendons_gone.p, "general_cured")
end

function valid.expend_torso()
  checkaction(dict.waitingonrebounding.waitingfor)
  if actions.waitingonrebounding_waitingfor then
    lifevision.add(actions.waitingonrebounding_waitingfor.p, "expend")
  end
end

-- happens on wrist fracture levels 1-3
function valid.devastate_arms_cripple()
  checkaction(dict.wristfractures.gone, true)
  lifevision.add(actions.wristfractures_gone.p)

  valid.simplecrippledrightarm()
  valid.simplecrippledleftarm()
end

-- happens on wrist fracture levels 4,5
function valid.devastate_arms_mangle()
  checkaction(dict.wristfractures.gone, true)
  lifevision.add(actions.wristfractures_gone.p)

  valid.simplemangledrightarm()
  valid.simplemangledleftarm()
end

-- happens on wrist fracture levels 6,7
function valid.devastate_arms_mutilate()
  checkaction(dict.wristfractures.gone, true)
  lifevision.add(actions.wristfractures_gone.p)

  valid.simplemutilatedrightarm()
  valid.simplemutilatedleftarm()
end

-- happens on torn tendon levels 1-3
function valid.devastate_legs_cripple()
  checkaction(dict.torntendons.gone, true)
  lifevision.add(actions.torntendons_gone.p)

  valid.simplecrippledrightleg()
  valid.simplecrippledleftleg()
end

-- happens on torn tendon levels 4,5
function valid.devastate_legs_mangle()
  checkaction(dict.torntendons.gone, true)
  lifevision.add(actions.torntendons_gone.p)

  valid.simplemangledrightleg()
  valid.simplemangledleftleg()
end

-- happens on torn tendon levels 6,7
function valid.devastate_legs_mutilate()
  checkaction(dict.torntendons.gone, true)
  lifevision.add(actions.torntendons_gone.p)

  valid.simplemutilatedrightleg()
  valid.simplemutilatedleftleg()
end

function valid.smash_high()
  lostbal_focus()
end

function valid.proper_ablaze()
  if not affs.severeburn and not affs.extremeburn and not affs.charredburn and not affs.meltingburn then
    valid.simpleablaze()
  end
end

function valid.riding_alreadyon()
  checkaction(dict.riding.physical, true)
  lifevision.add(actions.riding_physical.p, "alreadyon")
end

function valid.recoverable_attack()
  checkaction(dict.footingattack.happened, true)
  lifevision.add(actions.footingattack_happened.p)
end

valid.recovered_footing = valid.stoodup

function knight_focused(who)
  me.focusedknights[who] = true
end
function valid.doublehander_hit(who)
  if me.focusedknights[who] then
    sk.doubleknightaff = true
    me.focusedknights[who] = nil
    prompttrigger("clear double knight affs", function() sk.doubleknightaff = false end)
  end
end

function valid.skirmish_lacerate()
  prompttrigger("check lacerate rebounding", function()
    if not find_until_last_paragraph("The attack rebounds back onto", "substring") then
      valid.simplehaemophilia()
    end
  end)
end

function valid.skirmish_gouge()
  prompttrigger("check gouge deafness", function()
    if not find_until_last_paragraph("Your hearing is suddenly restored.", "exact") then
      valid.simplesensitivity()
    end
  end)
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

pl.dir.makepath(getMudletHomeDir() .. "/svo/config")

-- conf has actual values, config data for them

wait_tbl = {
  [0] = {n = 0.7, m = "Systems lag tolerance level set to normal."},
  [1] = {n = 1.1, m = "The lag level was set to \"decent\" - make sure to set it to normal when it clears up."},
  [2] = {n = 1.9, m = "The lag level was set to \"severe\" - make sure to set it to normal when it clears up."},
  [3] = {n = 3.5, m = "The lag level was set to \"awfully terrible\" - make sure to set it to normal when it clears up. Don't even think about fighting in this lag."},
  [4] = {n = 3.5, m = "The lag level was set to \"you're on a mobile in the middle of nowhere\" - make sure to set it to normal when it clears up. Don't even think about fighting in this lag. Don't use this for bashing with dor either - use 3 instead. This is more useful for scripts that rely on do - enchanting and etc."}
}

local conf_printinstallhint = function (which)
  assert(config_dict[which] and config_dict[which].type, which.." is missing a type")

  if config_dict[which].type == "boolean" then
    echof("Use %s to answer.", tostring(green("vconfig "..which.." yep/nope")))
  elseif config_dict[which].type == "string" then
    echof("Use %s to answer.", tostring(green("vconfig "..which.." (option)")))
  elseif config_dict[which].type == "number" and config_dict[which].percentage then
    echof("Use %s to answer.", tostring(green("vconfig "..which.." (percent)")))
  elseif config_dict[which].type == "number" then
    echof("Use %s to answer.", tostring(green("vconfig "..which.." (number)")))
  end
end

local conf_installhint = function (which)
  assert(config_dict[which] and config_dict[which].type, which.." is missing a type")

  if config_dict[which].type == "boolean" then
    return "Use vconfig "..which.." yep/nope to answer."
  elseif config_dict[which].type == "string" then
    return "Use vconfig "..which.." (option) to answer."
  elseif config_dict[which].type == "number" and config_dict[which].percentage then
    return "Use vconfig "..which.." (percent) to answer."
  elseif config_dict[which].type == "number" then
    return "Use vconfig "..which.." (number) to answer."
  else return ""
  end
end

config_dict = pl.OrderedMap {
  {blockcommands = {
    vconfig2 = true,
    type = "boolean",
    onenabled = function ()
      echof("<0,250,0>Will%s block your commands in slow curing mode (aeon/retardation) if the system is doing something.", getDefaultColor())
      if not denyCurrentSend then echof("Warning: your version of Mudlet doesn't support this, so blockcommands won't actually work. Update to 1.2.0+") end
    end,
    ondisabled = function () echof("<250,0,0>Won't%s block your commands in slow curing mode, but instead allow them to override what the system is doing.", getDefaultColor())
    if not denyCurrentSend then echof("Warning: your version of Mudlet doesn't support this, so blockcommands won't actually work.") end end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if denyCurrentSend then
        echo "Override commands in slow-curing mode.\n" return
      else
        echo "Override commands in slow-curing mode (requires Mudlet 1.2.0+).\n" return end
    end,
    installstart = function () conf.blockcommands = true end,
  }},
  {autoslick = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Automatically prioritise slickness",
    onenabled = function () echof("<0,250,0>Will%s automatically swap asthma herb priority in times of danger - when you have paralysis or impatience above asthma in prios, and you have asthma+slickness on you, getting hit with a herbstack.", getDefaultColor()) end,
    ondisabled = function ()
      if swapped_asthma then
        svo.prio_swap("asthma", "herb", svo.swapped_asthma)
        svo.swapped_asthma = nil
        svo.echof("Swapped asthma priority back down.")
      end

      echof("<250,0,0>Won't%s automatically swap asthma herb priority in times of danger.", getDefaultColor()) end,
    installstart = function () conf.autoslick = true end
  }},
  {focus = {
    type = "boolean",
    vconfig1 = "focus",
    onenabled = function () echof("<0,250,0>Will%s use Focus to cure.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use Focus to cure.", getDefaultColor()) end,
    installstart = function () conf.focus = nil end,
    installcheck = function () echof("Can you make use of the Focus skill?") end
  }},
  {siprandom = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s sip by random vial IDs of a potion - note that this requires the elist sorter to know which vial IDs have which potions - and you'll need to check 'elist' after a vial runs out.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s make use of random vials - will be sipping the first available one by name.", getDefaultColor()) end,
  }},
    {autoclasses = {
      type = "boolean",
      onenabled = function () echof("<0,250,0>Will%s automatically enable the classes you seem to be fighting (used for class tricks).", getDefaultColor()) end,
      ondisabled = function () echof("<250,0,0>Won't%s automatically enable classes that you seem to be fighting (you can use tn/tf class instead).", getDefaultColor()) end,

      vconfig2 = true,
      onshow = function (defaultcolour)
        fg(defaultcolour)
        if conf.autoclasses then
          echo "Will auto-enable classes.\n"
        else
          echo "Won't auto-enable classes.\n"
        end
      end,
    }},
  {havelifevision = {
    type = "boolean",
    onenabled = function () defences.enablelifevision() echof("<0,250,0>Have%s Lifevision mask - added it to defup/keepup.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Don't%s have Lifevision mask - won't be adding it to defup/keepup.", getDefaultColor()) end,
  }},
  {autoarena = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s automatically enable/disable arena mode as you enter into the arena.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s automatically enable/disable arena mode as you enter/leave the arena..", getDefaultColor()) end,
  }},
  {haveshroud = {
    type = "boolean",
    onenabled = function () defences.enableshroud() echof("<0,250,0>Have%s a Shroudcloak - added it to defup/keepup.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Don't%s have a Shroudcloak - won't be adding it to defup/keepup.", getDefaultColor()) end,
  }},
  {focuswithcadmus = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Use Focus while you have cadmus",
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo "Use Focus while you have cadmus"
      if conf.focuswithcadmus then
        echo"    ("
        echoLink("adjust affs", "svo.config.set'cadmusaffs'", "View, enable and disable afflictions for which focus is allowed to be used while you've got cadmus")
        fg(defaultcolour) echo ")"
      end
      echo"\n"
      resetFormat()
    end,
    onenabled = function () echof("<0,250,0>Will%s focus for mental afflictions when you've got cadmus (this'll give you a physical affliction when you do).", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s focus when you've got cadmus.", getDefaultColor()) end,
  }},
  {cadmusaffs = {
    type = "custom",
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      echofn("Afflictions for which we will use focus even though we have ")
      underline(true)
      setFgColor(unpack(getDefaultColorNums))
      echoLink("cadmus", '', "Cadmus will give you a physical affliction if you focus with it (and still cure the mental one)", true)
      underline(false)
      echo(":\n")

      local temp = prio.getlist("focus")

      -- clear gaps so we can sort and display in 2 columns
      local t = {}
      for _, focusaff in ipairs(temp) do t[#t+1] = focusaff end

      table.sort(t) -- display alphabetically

      for i = 1, #t, 2 do
        local focusaff, nextaff = t[i], t[i+1]

        if me.cadmusaffs[focusaff] then
          dechoLink("  <153,204,204>[<0,204,0>X<153,204,204>]", [[svo.me.cadmusaffs["]]..focusaff..[["] = false; svo.config.set'cadmusaffs']], "Click to stop focusing for "..focusaff.." when you have camus", true)
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %s", focusaff))
        else
          dechoLink("  <153,204,204>[<0,204,0> <153,204,204>]", [[svo.me.cadmusaffs["]]..focusaff..[["] = true; svo.config.set'cadmusaffs']], "Click to start focusing for "..focusaff.." when you have camus and are able to focus", true)
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %s", focusaff))
        end

        -- equal out the spacing on the second column
        echo((" "):rep(30-#focusaff))

        if nextaff and me.cadmusaffs[nextaff] then
          dechoLink("  <153,204,204>[<0,204,0>X<153,204,204>]", [[svo.me.cadmusaffs["]]..nextaff..[["] = false; svo.config.set'cadmusaffs']], "Click to stop focusing for "..nextaff.." when you have camus", true)
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %s\n", nextaff))
        elseif nextaff then
          dechoLink("  <153,204,204>[<0,204,0> <153,204,204>]", [[svo.me.cadmusaffs["]]..nextaff..[["] = true; svo.config.set'cadmusaffs']], "Click to start focusing for "..nextaff.." when you have camus and are able to focus", true)
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %s\n", nextaff))
        end
      end

      _G.setUnderline = underline
      echo'\n'
    end
  }},
  {lyre = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Lyre mode",
    onenabled = function () defs.keepup("lyre", "on") echof("Lyre mode <0,250,0>ON%s.", getDefaultColor()) end,
    ondisabled = function () defs.keepup("lyre", "off") app("off", true) echof("Lyre mode <250,0,0>OFF%s.", getDefaultColor()) end,
  }},
  {ninkharsag = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Experimental Nin'kharsag tracking",
    onenabled = function () echof("Experimental Nin'kharsag tracking <0,250,0>enabled%s - will attempt to work out which affs Nin'kharsag hides, and diagnose otherwise.", getDefaultColor()) end,
    ondisabled = function () echof("Experimental Nin'kharsag <250,0,0>disabled%s.", getDefaultColor()) end,
  }},
  {shipmode = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Ship mode",
    onenabled = function () signals.newroom:connect(sk.check_shipmode) echof("Ship mode <0,250,0>enabled%s - this will allow the system to work properly with the 2-3 line prompts.", getDefaultColor()) end,
    ondisabled = function () signals.newroom:disconnect(sk.check_shipmode) echof("Ship mode <250,0,0>disabled%s.", getDefaultColor()) end,
  }},
  {lyrecmd = {
    type = "string",
    onset = function ()
      dict.lyre.physical.action = conf.lyrecmd
      echof("Will use the '%s' for the Lyre mode.", tostring(conf.lyrecmd))
    end
  }},
  {commandseparator = {
    type = "string",
    onset = function ()
      echof("Will use <0,250,0>%s%s as the in-game command separator.", tostring(conf.commandseparator), getDefaultColor())
    end
  }},
  {buckawns = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Have buckawns",
    onenabled = function () echof("<0,250,0>Do%s have buckawns.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Don't%s have buckawns.", getDefaultColor()) end,
    installstart = function () conf.buckawns = nil end,
    installcheck = function () echof("Have you got the buckawns artifact?") end
  }},
  {burrowpause = {
    type = "boolean",
    onenabled = function () signals.gmcproominfo:connect(sk.check_burrow_pause) echof("<0,250,0>Will%s auto-pause when we burrow.", getDefaultColor()) end,
    ondisabled = function () signals.gmcproominfo:disconnect(sk.check_burrow_pause) echof("<250,0,0>Won't%s auto-pause when we burrow.", getDefaultColor()) end,
    installstart = function () conf.burrowpause = true end,
  }},
  {freevault = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Vaulting doesn't take balance",
    onenabled = function ()
      if conf.freevault and dict.riding.physical.balanceful_act then
        dict.riding.physical.balanceless_act = true
        dict.riding.physical.balanceful_act = nil
        signals.dragonform:emit()
      elseif not conf.freevault and dict.riding.physical.balanceless_act then
        dict.riding.physical.balanceless_act = nil
        dict.riding.physical.balanceful_act = true
        signals.dragonform:emit()
      end
      echof("<0,250,0>Do%s have balanceless vaulting.", getDefaultColor())
    end,
    ondisabled = function ()
      if conf.freevault and dict.riding.physical.balanceful_act then
        dict.riding.physical.balanceless_act = true
        dict.riding.physical.balanceful_act = nil
        signals.dragonform:emit()
      elseif not conf.freevault and dict.riding.physical.balanceless_act then
        dict.riding.physical.balanceless_act = nil
        dict.riding.physical.balanceful_act = true
        signals.dragonform:emit()
      end
      echof("<250,0,0>Don't%s have balanceless vaulting.", getDefaultColor())
    end,
  }},
  {deathsight = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Have deathsight",
    onenabled = function () echof("<0,250,0>Do%s have deathsight.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Don't%s have deathsight.", getDefaultColor()) end,
    installstart = function () conf.deathsight = nil end,
    installcheck = function () echof("Have you got the deathsight skill?") end
  }},
  {tree = {
    type = "boolean",
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo "Use tree       ("
      echoLink("view scenarios", "svo.config.set'treefunc'", "View, enable and disable scenarios in which tree will be used")
      fg(defaultcolour) echo ")\n"
      resetFormat()
    end,
    onenabled = function () echof("<0,250,0>Will%s use of tree.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use of tree.", getDefaultColor()) end,
    installstart = function () conf.tree = nil end,
    installcheck = function () echof("Do you have a Tree tattoo?") end
  }},
  {treebalance = {
    type = "number",
    min = 0,
    max = 100000,
    onset = function ()
      if conf.treebalance == 0 then
        echof("Will use the default settings for tree balance length.")
      else
        echof("Set tree balance to be %ds - if it doesn't come back after that, I'll reset it.", conf.treebalance)
      end
    end,
    installstart = function () conf.treebalance = 0 end
  }},
  {restore = {
    type = "boolean",
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo "Use restore    ("
      echoLink("view scenarios", "svo.config.set'restorefunc'", "View, enable and disable scenarios in which restore will be used")
      fg(defaultcolour) echo ")\n"
      resetFormat()
    end,
    onenabled = function () echof("<0,250,0>Will%s use Restore to cure limbs when necessary.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use Restore to cure.", getDefaultColor()) end,
    installstart = function () conf.restore = nil end,
    installcheck = function () echof("Can you make use of the Restore skill?") end
  }},
  {dragonheal = {
    type = "boolean",
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo "Use dragonheal ("
      echoLink("view scenarios", "svo.config.set'dragonhealfunc'", "View, enable and disable scenarios in which dragonheal will be used")
      fg(defaultcolour) echo ")\n"
      resetFormat()
    end,
    onenabled = function () echof("<0,250,0>Will%s use dragonheal to cure when necessary.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use dragonheal to cure.", getDefaultColor()) end,
    installstart = function () conf.dragonheal = nil end,
    installcheck = function () echof("Can you make use of the Dragonheal?") end
  }},
  {breath = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Auto-enable breathing on Kai Choke",
    onenabled = function () echof("<0,250,0>Will%s automatically enabling breathing against Kai Choke and to check for asthma.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use survival breathing.", getDefaultColor()) end,
    installstart = function () conf.breath = nil end,
    installcheck = function () echof("Can you make use of the survival breath skill?") end
  }},
  {ignoresinglebites = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Ignore single serpent bites",
    onenabled = function () echof("<0,250,0>Will%s ignore all serpent bites that deliver only one affliction - most likely they'll be illusions, but may also be not against a smart Serpent who realizes that you're ignoring. So if you see them only biting, that's a warning sign that they're *really* biting, and you'd want to toggle this off & diagnose.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s ignore serpent bites that deliver only one affliction.", getDefaultColor()) end
  }},
  {ignoresinglestabs = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Ignore single serpent doublestabs",
    onenabled = function () echof("<0,250,0>Will%s ignore all serpent doublestabs that deliver only one affliction (most likely they'll be illusions, but may also be not).", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s ignore serpent doublestabs that deliver only one affliction.", getDefaultColor()) end
  }},
  {efficiency = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Have survival efficiency",
    onenabled = function () echof("<0,250,0>Have%s survival efficiency - tree tattoo balance will take shorter to come back.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Don't%s have efficiency - tree tattoo balance will take longer to come back.", getDefaultColor()) end,
    installstart = function () conf.efficiency = nil end,
    installcheck = function () echof("Do you have the survival efficiency skill?") end
  }},
  {clot = {
    type = "boolean",
    vconfig1 = "clot",
    onenabled = function () echof("<0,250,0>Will%s use clot to control bleeding.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use clot for bleeding.", getDefaultColor()) end,
    installstart = function () conf.clot = nil end,
    installcheck = function () echof("Can you make use of the Clot skill?") end
  }},
  {insomnia = {
    type = "boolean",
    vconfig1 = "insomnia",
    onenabled = function () echof("<0,250,0>Will%s use the Insomnia skill for insomnia.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use the Insomnia skill for insomnia, and will use cohosh instead.", getDefaultColor()) end,
    installstart = function () conf.insomnia = nil end,
    installcheck = function () echof("Can you make use of the Insomnia skill?") end
  }},
  {thirdeye = {
    type = "boolean",
    vconfig1 = "thirdeye",
    onenabled = function () echof("<0,250,0>Will%s use the thirdeye skill for thirdeye instead of echinacea.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use the thirdeye skill for thirdeye, and will use echinacea instead.", getDefaultColor()) end,
    installstart = function () conf.thirdeye = nil end,
    installcheck = function () echof("Can you make use of the Thirdeye skill?") end
  }},
  {moss = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s make use of moss/potash to heal.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s make use of moss/potash to heal.", getDefaultColor()) end,
    installstart = function ()
      conf.moss = nil end,
    installcheck = function ()
      echof("Do you want to make use of moss/potash to heal?") end,
  }},
  {showchanges = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s show changes in health/mana on the prompt.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s show changes in health/mana on the prompt.", getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Show h/m changes (in "..tostring(conf.changestype).." format).\n")
    end,
    installstart = function () conf.showchanges = nil end,
    installcheck = function () echof("Do you want to show changes about your health/mana in the prompt?") end
  }},
  {changestype = {
    type = "string",
    check = function (what)
      if what == "full" or what == "short" or what == "fullpercent" or what == "shortpercent" then return true end
    end,
    onset = function ()
      echof("Will use the %s health/mana loss echoes.", conf.changestype)
    end,
    installstart = function () conf.changestype = "shortpercent" end
  }},
  {showbaltimes = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s show balance times for balance, equilibrium and herbs.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s show balance times.", getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo "Show how long balances took.\n"
    end,
    installstart = function () conf.showbaltimes = true end,
    -- installcheck = function () echof("Do you want to show how long your balances take?") end
  }},
  {showafftimes = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s show how long afflictions took to cure.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s show times for curing afflictions.", getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo "Show how quickly afflictions are cured.\n"
    end,
    installstart = function () conf.showafftimes = true end,
  }},
  {doubledo = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s do actions twice under stupidity.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s do actions twice under stupidity.", getDefaultColor()) end,
    onshow = "Double do actions in stupidity",
    vconfig2 = true
  }},
  {repeatcmd = {
    type = "number",
    min = 0,
    max = 100000,
    onset = function ()
      if conf.repeatcmd == 0 then echof("Will not repeat commands.")
      elseif conf.repeatcmd == 1 then echof("Will repeat each command one more time.")
      else echof("Will repeat each command %d more times.", conf.repeatcmd)
    end end,
    installstart = function () conf.repeatcmd = 0 end
  }},
  {parry = {
    type = "boolean",
    vconfig1 = "parry",
    onenabled = function () echof("<0,250,0>Will%s make use of parry.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s make use of parry.", getDefaultColor()) end,
    installstart = function () conf.parry = nil end,
    installcheck = function () echof("Are you able to use parry?") end
  }},
  {singleprompt = {
    type = "boolean",
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if conf.singleprompt then
        echo(string.format("Use a singleprompt%s", (conf.singlepromptblank and ' (with a blank line)' or '')))
      else
        echo("Not using a singleprompt")
      end
      echo'.\n'
      resetFormat()
    end,
    onenabled = function ()
      echof("<0,250,0>Enabled%s the use of a single prompt.", getDefaultColor())

      sk.enable_single_prompt()
    end,
    ondisabled = function ()
      echof("<250,0,0>Disabled%s the use a single prompt.", getDefaultColor())
      if moveprompt then killTrigger(moveprompt) end
      if bottomprompt then bottomprompt:hide(); bottomprompt.reposition = function() end end
      setBorderBottom(0)
      bottom_border = 0
    end
  }},
  {singlepromptsize = {
    type = "number",
    min = 0,
    max = 100,
    onset = function ()
      if bottomprompt then
        bottomprompt:setFontSize(conf.singlepromptsize)
        if conf.singleprompt then
          -- svo.config.set("singleprompt", "off", false)
          -- svo.config.set("singleprompt", "on", false)

          if moveprompt then killTrigger(moveprompt) end
          if bottomprompt then bottomprompt:hide(); bottomprompt.reposition = function() end end
          setBorderBottom(0)
          bottom_border = 0

          sk.enable_single_prompt()
          clearWindow("bottomprompt")
        end
      end

      echof("Will be displaying the font at size %d.", conf.singlepromptsize)
    end
  }},
  {singlepromptblank = {
    type = "boolean",
    onenabled = function ()
      echof("<0,250,0>Enabled%s the single prompt to show a blank line for the prompt.", getDefaultColor())
      config.set("singlepromptkeep", false, false)
    end,
    ondisabled = function ()
      echof("<250,0,0>Disabled%s the blank line, will be deleting the prompt instead.", getDefaultColor())
    end
  }},
  {singlepromptkeep = {
    type = "boolean",
    onenabled = function ()
      echof("<0,250,0>Enabled%s the single prompt to keep the prompt%s.", getDefaultColor(), (conf.singleprompt and '' or ' (when vconfig singleprompt is on)'))
      config.set("singlepromptblank", false, false)
    end,
    ondisabled = function ()
      echof("<250,0,0>Disabled%s keeping the prompt, will be removing it.", getDefaultColor())
    end
  }},
  {waitherbai = {
    type = "boolean",
    vconfig2 = true,
    onenabled = function () echof("<0,250,0>Will%s pause eating of herbs while checking herb-cured illusions.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s pause eating of herbs while checking herb-cured illusions.", getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour) echo ("Don't eat while checking herb-cured illusions.\n")
    end,
    installstart = function () conf.waitherbai = true end
  }},
  {waitparalysisai = {
    type = "boolean",
    vconfig2 = true,
    onenabled = function () echof("<0,250,0>Will%s wait for balance/eq to confirm a suspect paralysis instead of accepting it - so if we get a suspect paralysis while off bal/eq, we'll cure other things and check the paralysis when we can.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s wait for balance/eq to confirm a possible paralysis - if we get one off bal/eq, we'll eat bloodroot asap. Otherwise if we have bal/eq, we'll check first.", getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour) echo ("Wait for balance/eq to check suspicious paralysis.\n")
    end,
    installstart = function () conf.waitparalysisai = false end
  }},
  {commandecho = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s show commands the system is doing.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s show commands the system is doing.", getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour) echo ("Show system commands ("..tostring(conf.commandechotype)..")\n")
    end,
    installstart = function () conf.commandecho = true end
  }},
  {commandechotype = {
    type = "string",
    check = function (what)
      if what == "plain" or what == "fancy" or what == "fancynewline" then return true end
    end,
    onset = function ()
      echof("Will use the %s command echoes.", conf.commandechotype)
    end,
    installstart = function () conf.commandechotype = "fancy" end
  }},
  {curemethod = {
    type = "string",
    check = function (what)
      if table.contains({"conconly", "transonly", "preferconc", "prefertrans", "prefercustom"}, what) then return true end
    end,
    onset = function ()
      signals.curemethodchanged:emit()
      if conf.curemethod == "conconly" then
        echof("Will only use the usual Concoctions herbs/potions/salve for curing.")
      elseif conf.curemethod == "transonly" then
        echof("Will only use Transmutation minerals for curing.")
      elseif conf.curemethod == "preferconc" then
        echof("Will use Concoctions and Transmutation cures as you have them, but prefer Concoctions cures.")
      elseif conf.curemethod == "prefertrans" then
        echof("Will use Concoctions and Transmutation cures as you have them, but prefer Transmutation cures.")
      elseif conf.curemethod == "prefercustom" then
        echof("Will use your preferred Concoctions or Transmutation cures, falling back to the alternatives if you run out. See 'vshow curelist' for the adjustment menu.")
      else
        echof("Will use Concoctions and Transmutation cures as you have them.")
      end
    end,
    -- onshow: done in vshow
    installstart = function () conf.curemethod = nil end,
    installcheck = function () echof("Would you like to use Concoctions or Transmutation cures?\n\n  You can answer with 'conconly' - which'll mean that you'd like to use Concoctions cures only, 'transonly' - which'll mean that you'd like to use Transmutation cures only, 'preferconc' - prefer Concoctions cures, but fall back to Transmutation cures should you run out, and lastly, 'prefertrans' - prefer Transmutation cures, but fall back to Concoctions should you run out.") end
  }},
  {customprompt = {
    type = "string",
    vconfig2 = true,
    onset = function ()
      if conf.customprompt == "none" or conf.customprompt == "off" or conf.customprompt == "of" then
        conf.customprompt = false
        echof("Custom prompt disabled.")
      elseif conf.customprompt == "on" then
        if conf.oldcustomprompt ~= "off" and conf.oldcustomprompt ~= "of" then
          conf.customprompt = conf.oldcustomprompt
          cp.makefunction()
          echof("Custom prompt restored.")
          if innews then
            innews = false
            echof("Disabled the news status and re-enabled the prompt.")
          end
        else
          echof("You haven't set a custom prompt before, so we can't revert back to it. Set it with 'vconfig customprompt <prompt line>.")
          conf.customprompt = false
        end
      else
        cp.makefunction()
        conf.oldcustomprompt = conf.customprompt
        echof("Custom prompt enabled and set; will replace the standard one with yours now.")
      end
    end,
    installstart = function () conf.customprompt = nil; conf.setdefaultprompt = nil end
  }},
  {relight = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s auto-relight non-artifact pipes.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s auto-relight pipes.", getDefaultColor()) end,
    installstart = function () conf.relight = true end,
    installcheck = function () echof("Should we keep non-artifact pipes lit?") end
  }},
  {gagrelight = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s hide relighting of pipes.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s hide relighting pipes.", getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(string.format("Re-light pipes quietly%s.\n", not conf.relight and " (when relighting is on)" or ""))
    end,
    installstart = function () conf.gagrelight = true end,
    installcheck = function () echof("Should we hide it when pipes are relit (it can get spammy)?") end
  }},
  {gagotherbreath = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s hide others breathing.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s hide others breathing.", getDefaultColor()) end,
    onshow = "Completely gag others breathing",
    installstart = function () conf.gagotherbreath = true end
  }},
  {gagbreath = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s hide the breathing defence.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s hide the breathing defence.", getDefaultColor()) end,
    onshow = "Completely gag breathing",
    installstart = function () conf.gagbreath = true end,
    -- installcheck = function () echof("Should we hide it when you use the breathing defence?") end
  }},
  {gageqbal = {
    type = "boolean",
    onenabled = function () echof("<0,250,0>Will%s hide the 'you're off eq/bal' messages.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s hide the 'you're off eq/bal' messages.", getDefaultColor()) end,
    onshow = "Completely gag off eq/bal messages",
    installstart = function () conf.gageqbal = true end,
    installcheck = function () echof("Should we hide the messages you get when you try and spam something off balance or equilibrium?") end
  }},
  {gagserverside = {
    type = "boolean",
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Gag Svof's use of serverside priorities/toggles.\n")
    end,
    onenabled = function () echof("<0,250,0>Will%s hide info lines from the serverside curing system.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s hide info lines from the serverside curing system.", getDefaultColor()) end,
    installstart = function () conf.gagserverside = true end,
  }},
  {gagservercuring = {
    type = "boolean",
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Gag serverside [CURING] messages.\n")
    end,
    onenabled = function () echof("<0,250,0>Will%s hide serverside's [CURING] messages.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s hide serverside's [CURING] messages.", getDefaultColor()) end,
    installstart = function () conf.gagservercuring = false end,
  }},
  {ccto = {
    type = "string",
    onset = function ()
      conf.ccto = conf.ccto:lower()
      if conf.ccto == "pt" or conf.ccto == "party" then
        echof("Will report stuff to party.")
      elseif conf.ccto == "clt" then
        echof("Will report stuff to the current selected clan.")
      elseif conf.ccto:find("^tell %w+") then
        echof("Will report stuff to %s via tells.", conf.ccto:match("^tell (%w+)"):title())
      elseif conf.ccto == "ot" then
        echof("Will report stuff to the Order channel.")
      elseif conf.ccto == "team" then
        echof("Will report stuff to the team channel.")
      elseif conf.ccto == "army" then
        echof("Will report stuff to the army channel.")
      elseif conf.ccto == "echo" then
        echof("Will echo ccto stuff back to you, instead of announcing it anywhere.")
      else
        echof("Will report stuff to the %s clan.", conf.ccto)
      end
    end,
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(string.format("Reporting stuff to %s.\n", tostring(conf.ccto)))
    end,
    installstart = function ()
      conf.ccto = "pt" end
  }},
  {mosshealth = {
    type = "number",
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxhealth:emit() echof("Will eat moss/potash for health if it falls below %d%% (%dh).", conf.mosshealth, sys.mosshealth) end,
    installstart = function () conf.mosshealth = nil end,
    installcheck = function () echof("At what %% of health do you want to start using moss/potash to heal, if enabled?") end
  }},
  {pagelength = {
    type = "number",
    vconfig2string = true,
    min = 1,
    max = 250,
    onset = function () echof("Will reset your pagelength to %d after changing it.", conf.pagelength) end,
    installstart = function () conf.pagelength = 20 end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Default pagelength to reset to is ") fg("a_cyan")
      echoLink(tostring(conf.pagelength), 'printCmdLine"vconfig pagelength "',
      "Set the default pagelength to reset to after changing it",
       true)
      cecho("<a_grey> lines.\n")
    end,
  }},
  {herbstatsize = {
    type = "number",
    min = 1,
    max = 100,
    onset = function () rift.update_riftlabel(); echof("Set the font size in the herbstat window to %d.", conf.herbstatsize) end,
    installstart = function () conf.herbstatsize = 9 end
  }},
  {mossmana = {
    type = "number",
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxmana:emit() echof("Will eat moss/potash for mana if it falls below %d%% (%dm).", conf.mossmana, sys.mossmana) end,
    installstart = function () conf.mossmana = nil end,
    installcheck = function () echof("At what %% of mana do you want to start using moss/potash to heal, if enabled?") end
  }},
  {siphealth = {
    type = "number",
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxhealth:emit() echof("Will start sipping health if it falls below %d%% (%dh).", conf.siphealth, sys.siphealth) end,
    installstart = function () conf.siphealth = nil end,
    installcheck = function () echof("At what %% of health do you want to start sipping health?") end
  }},
  {sipmana = {
    type = "number",
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxmana:emit() echof("Will start sipping mana if it falls below %d%% (%dm).", conf.sipmana, sys.sipmana) end,
    installstart = function () conf.sipmana = nil end,
    installcheck = function () echof("At what %% of mana do you want to start sipping mana?") end
  }},
  {refillat = {
    type = "number",
    min = 0,
    max = 30,
    onset = function () echof("Will start refilling pipes when they're at %d puffs.", conf.refillat) end,
    installstart = function () conf.refillat = 1 end
  }},
  {manause = {
    type = "number",
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxmana:emit() echof("Will use mana-draining skills if only above %d%% mana (%d).", conf.manause, sys.manause) end,
    installstart = function () conf.manause = 35 end,
    installcheck = function () echof("Above which %% of mana is the system allowed to use mana skills? Like focus, insomnia, etc. If you got below this %%, it'll revert to normal cures.") end
  }},
  {lag = {
    type = "number",
    min = 0,
    max = 4,
    onset = function () cnrl.update_wait() echof(wait_tbl[conf.lag].m) end,
    installstart = function () conf.lag = 0 end
  }},
  {unknownfocus = {
    type = "number",
    min = 0,
    onset = function () echof("Will diagnose after we have %d or more unknown, but focusable afflictions.", conf.unknownfocus) end,
    installstart = function ()
    conf.unknownfocus = 2
    end,
  }},
  {unknownany = {
    type = "number",
    min = 0,
    onset = function () echof("Will diagnose after we have %d or more unknown affs.", conf.unknownany) end,
    installstart = function ()
    conf.unknownany = 2
    end,
  }},
  {bleedamount = {
    type = "number",
    vconfig2string = true,
    min = 0,
    onset = function () echof("Will start clotting if bleeding for more than %d health.", conf.bleedamount) end,
    installstart = function () conf.bleedamount = 60 end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Will clot if bleeding for over ") fg("a_cyan")
      echoLink(tostring(conf.bleedamount), 'printCmdLine"vconfig bleedamount "', "Set the # of health bleeding above which the system will start clotting", true)
      fg(defaultcolour) echo(" health or ") fg("a_cyan")
      echoLink(tostring(conf.manableedamount), 'printCmdLine"vconfig manableedamount "', "Set the # of mana bleeding above which the system will start clotting", true)
      fg(defaultcolour) echo(" mana (and over ") fg("a_cyan")
      echoLink(tostring(conf.corruptedhealthmin).."%", 'printCmdLine"vconfig corruptedhealthmin "', "Set the % of health below which the system will not clot your mana bleeding (due tp Alchemist corruption, which makes bleeding lose mana and clotting it will use health)", true)
      fg(defaultcolour) echo(" health)\n")
    end,
  }},
  {manableedamount = {
    type = "number",
    vconfig2string = true,
    min = 0,
    onset = function () echof("Will start clotting if bleeding for more than %d mana.", conf.manableedamount) end,
    installstart = function () conf.manableedamount = 60 end,
  }},
  {corruptedhealthmin = {
    type = "number",
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxhealth:emit() echof("Will not clot your mana bleeding if your health falls below %d%% (%dh).", conf.corruptedhealthmin, sys.corruptedhealthmin) end,
    installstart = function () conf.corruptedhealthmin = 70 end
  }},
  {valerianid = {
    type = "number",
    min = 0,
    installstart = function () conf.valerianid = nil; pipes.valerian.id = 0 end,
    installcheck = function () echof("What pipe should we use for valerian? Answer with the ID, please.") end,
    onset = function ()
      pipes.valerian.id = tonumber(conf.valerianid)
      echof("Set the valerian pipe id to %d.", pipes.valerian.id) end,
  }},
  {skullcapid = {
    type = "number",
    min = 0,
    installstart = function () conf.skullcapid = nil; pipes.skullcap.id = 0 end,
    installcheck = function () echof("What pipe should we use for skullcap? Answer with the ID, please.") end,
    onset = function ()
      pipes.skullcap.id = tonumber(conf.skullcapid)
      echof("Set the skullcap pipe id to %d.", pipes.skullcap.id) end,
  }},
  {treefunc = {
    type = "custom",
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      echof("Scenarios to use tree in:")
      local sortednames = keystolist(tree)
      table.sort(sortednames)
      local longestfname = longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = tree[fname]

        if not me.disabledtreefunc[fname] then
          if dechoLink then
            dechoLink("  <153,204,204>[<0,204,0>X<153,204,204>]", [[svo.me.disabledtreefunc["]]..fname..[["] = true; svo.config.set'treefunc']], "Disable "..fname, true)
          else
            decho("  <153,204,204>[<0,204,0>X<153,204,204>]")
          end
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %-"..longestfname.."s - %s\n", fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink("  <153,204,204>[<0,204,0> <153,204,204>]", [[svo.me.disabledtreefunc["]]..fname..[["] = false; svo.config.set'treefunc']], "Enable "..fname, true)
          else
            decho("  <153,204,204>[<0,204,0> <153,204,204>]")
          end
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %-"..longestfname.."s - %s\n", fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline

      showprompt()
    end
  }},
  {restorefunc = {
    type = "custom",
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      echof("Scenarios to use restore in:")
      local sortednames = keystolist(restore)
      table.sort(sortednames)
      local longestfname = longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = restore[fname]

        if not me.disabledrestorefunc[fname] then
          if dechoLink then
            dechoLink("  <153,204,204>[<0,204,0>X<153,204,204>]", [[svo.me.disabledrestorefunc["]]..fname..[["] = true; svo.config.set'restorefunc']], "Disable "..fname, true)
          else
            decho("  <153,204,204>[<0,204,0>X<153,204,204>]")
          end
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %-"..longestfname.."s - %s\n", fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink("  <153,204,204>[<0,204,0> <153,204,204>]", [[svo.me.disabledrestorefunc["]]..fname..[["] = false; svo.config.set'restorefunc']], "Enable "..fname, true)
          else
            decho("  <153,204,204>[<0,204,0> <153,204,204>]")
          end
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %-"..longestfname.."s - %s\n", fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline
      showprompt()
    end
  }},
  {dragonhealfunc = {
    type = "custom",
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      echof("Scenarios to use dragonheal in:")

      local sortednames = keystolist(dragonheal)
      table.sort(sortednames)
      local longestfname = longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = dragonheal[fname]
        if not me.disableddragonhealfunc[fname] then
          if dechoLink then
            dechoLink("  <153,204,204>[<0,204,0>X<153,204,204>]", [[svo.me.disableddragonhealfunc["]]..fname..[["] = true; svo.config.set'dragonhealfunc']], "Disable "..fname, true)
          else
            decho("  <153,204,204>[<0,204,0>X<153,204,204>]")
          end
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %-"..longestfname.."s - %s\n", fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink("  <153,204,204>[<0,204,0> <153,204,204>]", [[svo.me.disableddragonhealfunc["]]..fname..[["] = false; svo.config.set'dragonhealfunc']], "Enable "..fname, true)
          else
            decho("  <153,204,204>[<0,204,0> <153,204,204>]")
          end
          setFgColor(unpack(getDefaultColorNums))
          echo(string.format(" %-"..longestfname.."s - %s\n", fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline
    end
  }},
  {elmid = {
    type = "number",
    min = 0,
    installstart = function () conf.elmid = nil; pipes.elm.id = 0 end,
    installcheck = function () echof("What pipe should we use for elm? Answer with the ID, please.") end,
    onset = function ()
      pipes.elm.id = tonumber(conf.elmid)
      echof("Set the elm pipe id to %d.", pipes.elm.id) end,
  }},
  {eventaffs = {
    type = "boolean",
    -- vconfig2 = true,
    -- onshow = "Raise Mudlet events on each affliction",
    onenabled = function () update_eventaffs() echof("<0,250,0>Will%s raise Mudlet events for gained/lost afflictions.", getDefaultColor()) end,
    ondisabled = function () conf.eventaffs = true; update_eventaffs() echof("eventaffs are on by default now - and this option is depreciated; there's no point in turning it off.") end,
    installstart = function () conf.eventaffs = true; update_eventaffs() end
  }},
  {gagclot = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Gag clotting",
    onenabled = function () echof("<0,250,0>Will%s gag the clotting spam.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s gag the clotting spam.", getDefaultColor()) end,
    installstart = function () conf.gagclot = true end,
  }},
  {autorewield = {
    type = "boolean",
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if next(gmcp) then
        echo "Rewield forced unwield.\n"
      else
        echo "Rewield forced unwield (requires GMCP)\n"
      end
    end,
    onenabled = function ()
      if sys.enabledgmcp then
        echof("<0,250,0>Will%s automatically rewield items that we've been forced to unwield.", getDefaultColor())
      else
        echof("<0,250,0>Will%s automatically rewield items that we've been forced to unwield (requires GMCP being enabled).", getDefaultColor())
      end
    end,
    ondisabled = function () echof("<250,0,0>Won't%s automatically rewield things.", getDefaultColor()) end
  }},
  {preclot = {
    type = "boolean",
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if conf.preclot and conf.clot then
        echo "Will preclot bleeding.\n"
      elseif conf.preclot and not conf.clot then
        echo "Will do preclotting (when clotting is enabled).\n"
      else
        echo "Won't preclot bleeding.\n"
      end
    end,
    onenabled = function () echof("<0,250,0>Will%s do preclotting (saves health at expense of willpower).", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s do preclotting (saves willpwer at expense of health).", getDefaultColor()) end,
    installstart = function () conf.preclot = true end,
    installcheck = function () echof("Should the system do preclotting? Doing so will save you from some bleeding damage, at the cost of more willpower.") end
  }},
  {org = {
    type = "string",
    check = function (what)
      if contains({"Ashtan", "Hashan", "Mhaldor", "Targossas", "Cyrene", "Eleusis", "None", "Rogue"}, what:title()) then return true end
    end,
    onset = function ()
      if conf.org == "none" or conf.org == "rogue" then
        conf.org = "none"
        -- reset echotype so the org change can have effect on echoes
        conf.echotype = nil
        signals.orgchanged:emit()
        echof("Will use the default plain echoes.")
      else
        conf.org = string.title(conf.org)
        -- reset echotype so the org change can have effect on echoes
        conf.echotype = nil

        -- if NameDB is present, set own city to be allied - in case you weren't a citizen of this city before and it was an enemy to you
        if ndb and ndb.conf and type(ndb.conf.citypolitics) == "table" then
          ndb.conf.citypolitics[conf.org] = "ally"
        end

        signals.orgchanged:emit()
        echof("Will use %s-styled echoes.", conf.org)
      end

    end,
    installstart = function ()
      conf.org = nil end,
    installcheck = function ()
      echof("What city do you live in? Select from: Ashtan, Hashan, Mhaldor, Targossas, Cyrene, Eleusis or none.") end
  }},
  {slowcurecolour = {
    type = "string",
    vconfig2string = true,
    check = function (what)
      if color_table[what] or what == "off" then return true end
    end,
    onset = function ()
      local r,g,b = unpack(color_table[conf.slowcurecolour])
      echof("Will colour your actions in <%d,%d,%d>%s%s when in aeon or retardation.", r,g,b, conf.slowcurecolour, getDefaultColor())
    end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Colouring aeon/retardation curing lines in ") fg(conf.slowcurecolour)
      echoLink(tostring(conf.slowcurecolour), 'printCmdLine"vconfig slowcurecolour "',
      "Set which colour you'd like curing lines to show as in aeon / retardation",
       true)
      cecho("<a_grey>.\n")
    end,
    installstart = function ()
      conf.slowcurecolour = "blue" end
  }},
  {hinderpausecolour = {
    type = "string",
    vconfig2string = true,
    check = function (what)
      if color_table[what] or what == "off" then return true end
    end,
    onset = function ()
      local r,g,b = unpack(color_table[conf.hinderpausecolour])
      echof("Will colour hindering afflictions in <%d,%d,%d>%s%s when paused.", r,g,b, conf.hinderpausecolour, getDefaultColor())
    end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Colouring hindering lines in ") fg(conf.hinderpausecolour)
      echoLink(tostring(conf.hinderpausecolour), 'printCmdLine"vconfig hinderpausecolour "',
      "Set which colour you'd like to see hindering lines in when paused",
       true)
      cecho("<a_grey> when paused.\n")
    end,
    installstart = function ()
      conf.hinderpausecolour = "orange" end
  }},
  {autoreject = {
    type = "string",
    check = function (what)
      if contains({"black", "white", "off", "on"}, what:sub(1,5):lower()) then sk.oldautoreject = conf.autoreject return true end
    end,
    onset = function ()
      conf.autoreject = string.lower(conf.autoreject):sub(1,5)

      if conf.autoreject == "off" then
        ignore.lovers = true
        conf.autoreject = sk.oldautoreject; sk.oldautoreject = nil
        echof("Disabled autoreject completely (ie, will ignore curing lovers aff).")
      elseif conf.autoreject == "on" then
        ignore.lovers = nil
        conf.autoreject = sk.oldautoreject; sk.oldautoreject = nil
        echof("Enabled autoreject (won't ignore curing lovers anymore) - right now it's in %slist mode.", conf.autoreject)
      elseif conf.autoreject == "white" then
        local c = table.size(me.lustlist)
        echof("Autoreject has been set to whitelist mode - that means we will be automatically rejecting everybody, except those on the lust list (%d %s).", c, (c == 1 and "person" or "people"))
      elseif conf.autoreject == "black" then
        local c = table.size(me.lustlist)
        echof("Autoreject has been set to blacklist mode - that means we will only be rejecting people on the lust list (%d %s).", c, (c == 1 and "person" or "people"))
      else
        echof("... how did you manage to set the option to '%s'?", tostring(conf.autoreject))
      end
    end,
    installstart = function ()
      conf.autoreject = "white" end
  }},
  {lustlist = {
    type = "string",
    check = function(what)
      if what:find("^%w+$") then return true end
    end,
    onset = function ()
      local name = string.title(conf.lustlist)
      if not me.lustlist[name] then me.lustlist[name] = true else me.lustlist[name] = nil end

      if me.lustlist[name] then
        if conf.autoreject == "black" then
          echof("Added %s to the lust list (so we will be autorejecting them).", name)
        elseif conf.autoreject == "white" then
          echof("Added %s to the lust list (so we won't be autorejecting them).", name)
        else
          echof("Added %s to the lust list.", name)
        end
      else
        if conf.autoreject == "black" then
          echof("Removed %s from the lust list (so we will not be autorejecting them now).", name)
        elseif conf.autoreject == "white" then
          echof("Removed %s from the lust list (so we will be autorejecting them).", name)
        else
          echof("Removed %s from the lust list.", name)
        end
      end
    end
  }},
  {echotype = {
    type = "string",
    check = function (what)
      if echos[what:title()] or echos[what] then return true end
    end,
    onset = function ()
      conf.echotype = echos[conf.echotype:title()] and conf.echotype:title() or conf.echotype
      signals.orgchanged:emit()
      echof("This is how system messages will look like now :)")
    end,
    vconfig2 = true,
    installstart = function ()
      conf.org = nil end,
  }},
  {dragonflex = {
    type = "boolean",
    vconfig1 = "dragonflex",
    onenabled = function () echof("<0,250,0>Will%s use dragonflex when we have balance.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use dragonflex.", getDefaultColor()) end,
    installstart = function () conf.dragonflex = nil end,
    installcheck = function () echof("Can you make use of the Dragonflex skill?") end
  }},
  {assumestats = {
    type = "number",
    vconfig2 = true,
    min = 0,
    max = 100,
    onset = function () echof("Will assume we're at %d%% of health and mana when under blackout or recklessness.", conf.assumestats) end,
    installstart = function () conf.assumestats = 15 end,
  }},
  {healthaffsabove = {
    type = "number",
    vconfig2 = true,
    min = 0,
    max = 100,
    onset = function () echof("Will apply health to cure afflictions only when above %d%% health.", conf.healthaffsabove) end,
    installstart = function () conf.healthaffsabove = 70 end,
  }},
  {warningtype = {
    type = "string",
    vconfig2 = true,
    check = function (what)
      if contains({"all", "prompt", "none", "right", "off"}, what) then return true end
    end,
    onset = function ()
      if conf.warningtype == "none" or conf.warningtype == "off" then
        conf.warningtype = false
        echof("Disabled extended instakill warnings.")
      elseif conf.warningtype == "all" then
        echof("Will prefix instakill warnings to all lines.")
        if math.random(1, 10) == 1 then echof("(muahah(") end
      elseif conf.warningtype == "prompt" then
        echof("Will prefix instakill warnings only to prompt lines.")
      elseif conf.warningtype == "right" then
        echof("Will place instakill warnings on all lines, aligned on the right side.")
      end
    end,
    installstart = function ()
      conf.warningtype = "right" end,
  }},
  {burstmode = {
    type = "string",
    vconfig2string = true,
    check = function (what)
      if defdefup[what:lower()] then return true end
    end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo("Upon starbursting, will go into ") fg("a_cyan")
      echoLink(tostring(conf.burstmode), 'printCmdLine"vconfig burstmode "',
      "Set the defences mode system should autoswitch to upon starburst/soulcage",
       true)
      cecho("<a_grey> defences mode.\n")
    end,
    onset = function ()
      conf.burstmode = conf.burstmode:lower()
      echof("Upon starburst/soulcage, will go into %s defences mode.", conf.burstmode)
    end,
    installstart = function ()
      conf.burstmode = "empty" end
  }},
  {oldts = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Touch shield only once on ts",
    onenabled = function () echof("<0,250,0>Will%s use oldschool ts - using ts one will shield once.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s use oldschool ts - using ts will enable shield keepup.", getDefaultColor()) end,
    installstart = function () conf.oldts = false end,
    installcheck = function () echof("In Svof, <0,255,0>ts%s is a toggle for <0,255,0>vkeep shield%s - it'll reshield you if the shield gets stripped. Previously it used to shield you once only. Would you like to be a toggle (<0,255,0>vconfig oldts no%s) or a one-time thing (<0,255,0>vconfig oldts yes%s)?", getDefaultColor(), getDefaultColor(), getDefaultColor(), getDefaultColor()) end
  }},
  {batch = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Batch multiple curing commands",
    onenabled = function () echof("<0,250,0>Will%s batch multiple curing commands to be done at once, without prompts inbetween.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s batch curing commands to be done at once, but instead send them separately at once.", getDefaultColor()) end,
    installstart = function () conf.batch = true end,
  }},
  {steedfollow = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Auto-order steed to follow us",
    onenabled = function () echof("<0,250,0>Will%s make the steed follow us when we dismount (via va).", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s make the steed follow us anymore when we dismount (via va).", getDefaultColor()) end,
    installstart = function () conf.steedfollow = true end
  }},
  {autotsc = {
    type = "boolean",
    vconfig2 = true,
    onshow = "Automatically toggle tsc in aeon/ret",
    onenabled = function () echof("<0,250,0>Will%s automatically toggle tsc - overrides in retardation and denies in aeon.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s automatically toggle tsc.", getDefaultColor()) end,
  }},
  {medprone = {
    type = "boolean",
    vconfig2string = true,
    onshow = function (defaultcolour)
      fg("a_cyan")
      echoLink((conf.medprone and "Do" or "Don't"), 'printCmdLine"vconfig medprone '..(conf.medprone and "nope" or "yep")..'"',
      "Click to set whenever you'd like the system to put prone on ignore while meditating for you, so you can sit down while doing it. The drawback is that if you're trying to meditate in combat and get proned, the system won't get up",
       true)
      fg(defaultcolour)
      echo(" ignore prone while meditating, and ")
      fg("a_cyan")
      echoLink((conf.unmed and "do" or "don't"), 'printCmdLine"vconfig unmed '..(conf.unmed and "nope" or "yep")..'"',
      "Click to set whenever you'd like the system take meditate off keepup when you reach full willpower",
       true)
      fg(defaultcolour)
      echo(" stop at full willpower.\n")
    end,
    installstart = function() conf.medprone = false end,
    onenabled = function () echof("<0,250,0>Will%s put prone on ignore when meditating, so you can be sitting.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s put prone on ignore when meditating.", getDefaultColor()) end,
  }},
  {unmed = {
    type = "boolean",
    onshow = "Automatically disable med with full wp",
    onenabled = function () echof("<0,250,0>Will%s take meditate off keepup when you reach full willpower.", getDefaultColor()) end,
    ondisabled = function () echof("<250,0,0>Won't%s take meditate off keepup when you reach full willpower - so we'll meditate again if you lose any mana/willpower.", getDefaultColor()) end,
  }},
  {classattacksamount = {
    type = "number",
    min = 0,
    vconfig2string = true,
    onset = function () echof("Will enable a class after they hit us with %d attacks (within %d seconds).", conf.classattacksamount, conf.classattackswithin) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      -- Enable class as fighting with after x attacks in x seconds
      echo("Enable class as fighting with after") fg("a_cyan")
      echoLink(" "..tostring(conf.classattacksamount), 'printCmdLine"vconfig classattacksamount "',
      "Set the amount of attacks an enemy will do to you within "..tostring(conf.classattackswithin).." seconds to enable the class tricks",
       true)
      cecho("<a_grey> attacks in") fg("a_cyan")
      echoLink(" "..tostring(conf.classattackswithin), 'printCmdLine"vconfig classattackswithin "',
      "Set the time within ".. tostring(conf.classattacksamount).. " attacks from a class will enable tricks for it",
       true)
      cecho(" seconds.\n")
    end,
    installstart = function () conf.classattacksamount = 3 end
  }},
  {classattackswithin = {
    type = "number",
    min = 0,
    onset = function () echof("Will enable a class when they hit us within %d seconds (with %d attacks).", conf.classattackswithin, conf.classattacksamount) end,
    installstart = function () conf.classattackswithin = 15 end
  }},
  {enableclassesfor = {
    type = "number",
    min = 0,
    vconfig2string = true,
    onset = function () echof("Will keep the class enabled for %s minutes after the fighting ends.", conf.enableclassesfor) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      -- Keep a class enabled for x minutes after fighting
      echo("Keep a class enabled for") fg("a_cyan")
      echoLink(" "..tostring(conf.enableclassesfor), 'printCmdLine"vconfig enableclassesfor "',
      "Set (in minutes) how long to keep a class enabled for after the fighting ends",
       true)
      cecho("<a_grey> minutes after fighting.\n")
    end,
    installstart = function () conf.enableclassesfor = 2 end
  }},
}

do
  local conf_t = {}
  local conf_path = getMudletHomeDir() .. "/svo/config/conf"

  if lfs.attributes(conf_path) then
    local ok, msg = pcall(table.load,conf_path, conf_t)
    if ok then
      update(conf, conf_t)
    else
      os.remove(conf_path)
      tempTimer(10, function()
        echof("Your vconfig file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-set all of the vconfig options again, though. (%q)", msg)
      end)
    end
  end

  if conf.ai_minherbbal == 0.7 or conf.ai_minherbbal == 1.2 then conf.ai_minherbbal = 1.1 end
  if conf.ai_resetherbbal == 5 then conf.ai_resetherbbal = 2.5 end
  -- recovered at 7.4s for Hirst for twohander aff
  if conf.ai_resetsipbal == 5 then conf.ai_resetsipbal = 7 end
  if conf.ai_resetsipbal == 7 then conf.ai_resetsipbal = 10 end
  if conf.org == "Shallam" then conf.org = "Targossas" end
  -- recovery was renamed as efficiency
  if conf.recovery then conf.efficiency = true; conf.recovery = nil end

  if conf.gagserverside == nil then conf.gagserverside = true end

  -- purgative used to be set at a default 5 before it was even used, it is now 7 for voyria
  if conf.ai_resetpurgativebal == 5 then conf.ai_resetpurgativebal = 10 end

  conf.eventaffs = true
  update_eventaffs()

  cnrl.update_wait()

  if conf.bashing then enableTrigger"svo Bashing triggers"
  else disableTrigger"svo Bashing triggers" end

  -- update whenever our riding takes up balance. If it doens't, then balanceless actions should be done asap
  if conf.freevault and dict.riding.physical.balanceful_act then
    dict.riding.physical.balanceless_act = true
    dict.riding.physical.balanceful_act = nil
    signals.dragonform:emit()
  elseif not conf.freevault and dict.riding.physical.balanceless_act then
    dict.riding.physical.balanceless_act = nil
    dict.riding.physical.balanceful_act = true
    signals.dragonform:emit()
  end

  if conf.burrowpause then
    signals.gmcproominfo:connect(sk.check_burrow_pause)
  end

  if not conf.customprompt and not conf.setdefaultprompt then
    tempTimer(math.random(10, 15), function()
      conf.setdefaultprompt = true
      setdefaultprompt()
      -- disabled -- spammy for new users
      -- echo"\n" echof("I've setup a custom prompt for you that mimics the normal Achaean one, but also displays which afflictions have you got. See http://doc.svo.vadisystems.com/#setting-a-custom-prompt on how to customize it if you'd like, or if you don't like it, do 'vconfig customprompt off' to disable it.")
      end)
  end

  if conf.singleprompt then
    sk.enable_single_prompt()
  end

  if conf.riftlabel then
    tempTimer(0, function()
      riftlabel:show()
      rift.update_riftlabel()
    end)
  end
end

for k,v in config_dict:iter() do
  -- pre-initialize values not declared
  if conf[k] == nil and v.type == "number" then
    conf[k] = 0
  elseif conf[k] == nil then
    conf[k] = false
  end
end

local tntf_tbl
tntf_tbl = {
  aillusion = { -- is used to change appropriate conf. option
    shortcuts = {"ai", "anti-illusion", "a", "antiillusion"},
    on = function () enableTrigger "Pre-parse anti-illusion";
          echof"Anti-illusion enabled." end,
    alreadyon = function () enableTrigger "Pre-parse anti-illusion";
          echof"Anti-illusion is already enabled." end,
    off = function () disableTrigger "Pre-parse anti-illusion";
          echof"Anti-illusion disabled." end,
    alreadyoff = function () disableTrigger "Pre-parse anti-illusion";
          echof"Anti-illusion is already disabled." end,
  },
  arena = {
    on = function()
      local echos = {"Arena mode enabled. Good luck!", "Beat 'em up! Arena mode enabled.", "Arena mode on.", "Arena mode enabled. Kill them all!"}
            echof(echos[math.random(#echos)])
    end,
    alreadyon = function() echof("Arena mode is already on.") end,
    off = function() echof("Arena mode disabled.") end,
    alreadyoff = function() echof("Arena mode is already off.") end
  },
  keepup = {
    on = function () echof"Auto keepup on." make_gnomes_work() end,
    alreadyon = function () echof"Auto keepup is already on." end,
    off = function () echof"Auto keepup is now off."make_gnomes_work() end,
    alreadyoff = function() echof"Auto keepup is already off." end
  },
  bashing = {
    on = function () enableTrigger"svo Bashing triggers" echof("Enabled bashing triggers.") end,
    alreadyon = function () echof("Bashing triggers are already on.") end,
    off = function() disableTrigger"svo Bashing triggers" echof("Disabled bashing triggers.") end,
    alreadyoff = function() echof("Bashing triggers are already off.") end,
  },
  raid = {
    on = function ()
      tntf_set("keepup", true, true)
      defs.switch("combat", true)
      echof("Switched into combat defence mode and keeping mass, cloak, insomnia, rebounding defences up.")
      defs.keepup("mass", true)
      defs.keepup("cloak", true)
      defs.keepup("mass", true)
      defs.keepup("insomnia", true)
      defs.keepup("rebounding", true)
    end,
    off = function ()
      defs.switch("basic", true)
      echof("Switched to basic defence mode.")
    end
  },
  serverside = {
    shortcuts = {"ss"},
    on = function()
      do
        -- if we've got nothing on the list, setup these defaults
        if not next(serverignore) then
          local list = sk.getallserversideactions()

          for _, action in ipairs(list) do
            serverignore[action] = true
          end

          serverignore.impale     = false -- serverside does not stack writhing atm
          serverignore.lovers     = false -- lust not handled by serverside
          serverignore.selfishness = false -- doesn't take selfish off
        end
      end

      -- take previous ignores off
      local removelist = {}
      for action, data in pairs(ignore) do
        if type(data) == "table" and data.because == "using server-side curing" then
          removelist[#removelist+1] = action
        end
      end

      for _, action in ipairs(removelist) do
        ignore[action] = nil
      end

      if next(removelist) then
        tempTimer(5, [[svo.echof("Took all affs set for serverside curing off ignore. 'vshow ignore' really means ignore again (both in Svof and serverside), use 'vshow server' to toggle what should be done by serverside or Svof.")]])
      end

      echof("Serverside curing enabled (augmented with Svof's).")
      setupserverside()
      sendcuring("afflictions on")
      sendcuring("sipping on")
      sendcuring("defences on")
      sendcuring("focus on")
      sendcuring("batch on")
      sendc("config advancedcuring on")
      sendcuring("reporting on")
      if not conf.paused then sendcuring("on") end
    end,
    off = function()
      echof("Serverside curing disabled.")
      sendcuring("off")
    end,
    alreadyon = function() echof("Serverside affliction curing is already on.") end,
    alreadyoff = function() echof("Serverside affliction curing is already off.") end,
  }
}

for k,v in pairs(tntf_tbl) do
  if v.shortcuts then
    for _,shortcut in pairs(v.shortcuts) do
      tntf_tbl[shortcut] = k
    end
    v.real = k
  end
end

function tntf_set(what, option, echoback)
  local sendf
  if echoback then sendf = echof else sendf = errorf end

  option = convert_string(option)
  assert(what and (option ~= nil), "syntax is: svo.tntf(what, option)", sendf)

  if not tntf_tbl[what] then
    if echoback ~= "noerrors" then sendf("%s isn't something you can change.", what) end
    return
  end

  local oldechof, oldshowprompt = echof, showprompt

  if echoback == false then
    echof = function() end
    oldshowprompt = echof
  end

  if type(tntf_tbl[what]) == "string" then what = tntf_tbl[what] end
  if option and conf[what] then
    (tntf_tbl[what].alreadyon or tntf_tbl[what].on)()
  elseif not option and not conf[what] then
    (tntf_tbl[what].alreadyoff or tntf_tbl[what].off)()
  elseif not option then
    conf[what] = false
    tntf_tbl[what].off()
    raiseEvent("svo config changed", what)
  else
    conf[what] = true
    tntf_tbl[what].on()
    raiseEvent("svo config changed", what)
  end

  if echoback == false then
    echof = oldechof
    showprompt = oldshowprompt
  end

  if echoback then showprompt() end

  return true
end

-- just display all options in 4 tabs
function sk.show_all_confs()
  local count = 0
  local t = {}; for name, _ in config_dict:iter() do t[#t+1] = name end; table.sort(t)

  for _, name in ipairs(t) do
    if printCmdLine then
      echoLink(string.format("%-20s", tostring(name)), 'printCmdLine("vconfig '..name..' ")', conf_installhint(name), true)
    else
      echo(string.format("%-20s", tostring(name))) end
    count = count + 1
    if count % 4 == 0 then echo "\n" end
  end
end

function config.setoption(name, data)
  config_dict:set(name, data)
  if conf[name] == nil and config_dict[name].type == "number" then
    conf[name] = conf[name] or 0
  elseif conf[name] == nil then
    conf[name] = conf[name] or false
  end
end

function config.deloption(name)
  if config_dict[name] then
    config_dict:set(name, nil)
  end
end

function config.set(what, option, echoback)
  local sendf
  local showprompt = showprompt
  local oldechof
  if echoback then
    sendf = echof
  else
    sendf = errorf
    -- hide echoes and prompt
    showprompt = function() end
    oldechof = echof
    echof = function() end
  end

  local function raiseevent(what)
    tempTimer(0, function() raiseEvent("svo config changed", what) end)
  end

  if not config_dict[what] or what == "list" or what == "options" then
    sendf("%s - available ones are:", (what == "list" or what == "option") and "Listing all options" or "Don't know about such an option")
    sk.show_all_confs()
    echo"\n"
    showprompt()
    if not echoback then echof = oldechof end
    return
  end
  if config_dict[what].type == "boolean" then
    if (type(option) == "boolean" and option == true) or convert_string(option) or (option == nil and not conf[what]) then
      conf[what] = true
      config_dict[what].onenabled()
      raiseevent(what)
    elseif (type(option) == "boolean" and option == false) or not convert_string(option) or (option == nil and conf[what]) then
      conf[what] = false
      config_dict[what].ondisabled()
      raiseevent(what)
    else
      sendf("don't know about that option - try 'yes' or 'no' for %s.", what)
    end

  elseif config_dict[what].type == "number" then
    if not option or tonumber(option) == nil then
      if config_dict[what].percentage then
        sendf("What percentage do you want to set %s to?", what)
      else
        sendf("What number do you want to set %s to?", what)
      end
      if not echoback then echof = oldechof end
      return
    end

    local num = tonumber(option)
    if config_dict[what].max and num > config_dict[what].max then
      sendf("%s can't be higher than %s.", what, config_dict[what].max)
    elseif config_dict[what].min and num < config_dict[what].min then
      sendf("%s can't be lower than %s.", what, config_dict[what].min)
    else
      conf[what] = num
      config_dict[what].onset()
      raiseevent(what)
    end

  elseif config_dict[what].type == "string" then
    if not option then sendf("What do you want to set %s to?", what)
      showprompt()
      if not echoback then echof = oldechof end
      return
    end

    if config_dict[what].check and not config_dict[what].check(option) then
      sendf("%s isn't something you can set %s to be.", option, what)
      showprompt()
      if not echoback then echof = oldechof end
      return
    end

    conf[what] = option
    config_dict[what].onset()
    raiseevent(what)

  elseif config_dict[what].type == "custom" then
    if not option then
      if config_dict[what].onmenu then
        config_dict[what].onmenu()
      else
        sendf("What do you want to set %s to?", what)
        showprompt()
      end

    else
      if config_dict[what].onset then
        config_dict[what].onset()
        raiseevent(what)
      end
    end

  else
    sendf("meep... %s doesn't have a type associated with it. Tis broken.", what)
    showprompt()
  end

  if not echoback then echof = oldechof end
  showprompt()
  if install.installing_system then install.check_install_step() end
  make_gnomes_work()
end

signals.saveconfig:connect(function () table.save(getMudletHomeDir() .. "/svo/config/conf", conf) end)

function config.showcolours()
  echof("Here's a list of available colors you can pick. To select, click on the name or use the %s command.", green("vconfig echotype <name>"))

  for name, f in pairs(echos) do
    local s = "  pick "..tostring(name).." -  "
    echo("  pick ")
    echoLink(tostring(name), 'svo.config.set("echotype", "'.. tostring(name) ..'", true)', 'Set it to '..tostring(name)..' colour style.', true)
    echo(" -  ")
    echo((" "):rep(30-#s)) f(true, "this is how it'll look")
  end
end

function config.showprompt()
  if not conf.customprompt then
    echof("You don't have a custom prompt set currently.")
  else
    echof("This is the script behind your custom prompt:\n")
    echo(conf.customprompt)
  end
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

install.ids = install.ids or {}

-- same name as conf
-- function to say have/don't have
local installdata = {
  parry = {
    gmcp = {group = "weaponry", name = "parrying"},
  },
  thirdeye = {
    gmcp = {group = "vision", name = "thirdeye"},
  },
  deathsight = {
    gmcp = {group = "vision", name = "deathsight"},
  },
  focus = {
    gmcp = {group = "survival", name = "focusing"},
  },
  efficiency = {
    gmcp = {group = "survival", name = "efficiency"}
  },
  restore = {
    gmcp = {group = "survival", name = "restoration"},
  },
  breath = {
    gmcp = {group = "survival", name = "breathing"},
  },
  pipes = {
    command = "ii pipe",
    item = true,
    other = {
      pattern = [[^You are wielding:$]],
      script = [[
        svo.deleteAllP()
        svo.pipetrig = tempRegexTrigger([=[^ +pipe(\d+)]=],
          [=[
            tempTimer(0.02, [==[
              local r = svo.pipe_assignid(]==]..matches[2]..[==[)
              killTrigger(svo.pipetrig)
              if r then send("empty "..r, false) svo.echof("Set the %s pipe id to %d.", r, ]==]..matches[2]..[==[) end
            ]==])
          ]=])
      ]]
    }
  },
  insomnia = {
    gmcp = {group = "survival", name = "insomnia"},
  },
  clot = {
    gmcp = {group = "survival", name = "clotting"},
  },
}

function installclear(what)
  if type(install.ids[what]) == "table" then

    for _, id in pairs(install.ids[what]) do
      killTrigger(id)
      install.ids[what][_] = nil
    end
    install.ids[what] = nil

  else
    install.ids[what] = nil
  end

  if installtimer then killTimer(installtimer) end
  tempTimer(5+getNetworkLatency(), function ()
    if next(install.ids) then
      for thing, _ in pairs(install.ids) do
        if config_dict[thing] and config_dict[thing].type == "boolean" then
          config.set(thing, false, true)
        end

        installclear(thing)
      end
    end

    installtimer = nil

    if not next(install.ids) and not install.installing_system then
      echo"\n"
      echof("auto-configuration done. :) question time!")
      echo"\n"
      install.ask_install_questions()
    end
  end)
end

function installstart(fresh)
  if fresh and not sk.installwarning then
    echof("Are you really sure you want to wipe everything (all remove all non-default defence modes, clear basic+combat defup/keepup to blank, remove all configuration options)? If yes, do vinstall fresh again.")
    if selectString("really", 1) ~= -1 then setUnderline(true) resetFormat() end
    sk.installwarning = true
    return
  elseif fresh and sk.installwarning then
    local s, m = os.remove(getMudletHomeDir() .. "/svo")
    if not s then echof("Couldn't remove svo folder because of: %s", m) end

    defdefup = {
      basic = {},
      combat = {},
    }

    defkeepup = {
      basic = {},
      combat = {},
    }

    echof("Vacuumed everything up!")
    sk.installwarning = nil
  end

  for _, skill in pairs(install.ids) do
    if type(skill) == "table" then
      for _, id in pairs(skill) do
        installclear(id)
      end
    end
  end

  install.ids = {}
  local ids = install.ids

    for skill, skilldata in pairs(installdata) do
      if skilldata.gmcp then
        sendGMCP("Char.Skills.Get "..yajl.to_string(skilldata.gmcp))
        ids[skill] = true
      end
    end

    sendGMCP("Char.Skills.Get "..yajl.to_string{group = "survival"})
    sendGMCP("Char.Items.Inv")
    signals.gmcpcharskillsinfo:unblock(install.checkskillgmcp)
    signals.gmcpcharitemslist:unblock(install.checkinvgmcp)
    signals.gmcpcharskillslist:unblock(install.checkskilllist)


  if sys.enabledgmcp then
    echof("Starting auto-configuration - going to detect which skills and pipes you've got. Please wait 5 seconds for the questions to start.")
    printCmdLine("Please wait, doing auto-configuration...")
    echo"\n"
  else
    echof("Please enable GMCP in Mudlet settings and restart before installing.")

    signals.gmcpcharskillsinfo:block(install.checkskillgmcp)
    signals.gmcpcharitemslist:block(install.checkinvgmcp)
    signals.gmcpcharskillslist:block(install.checkskilllist)

    for _, skill in pairs(install.ids) do
      if type(skill) == "table" then
        for _, id in pairs(skill) do
          installclear(id)
        end
      end
    end

    install.ids = {}

    return
  end

  send("config screenwidth 0", true)
  -- some newbies don't have the full prompt, just a -, which does not have the required info for the system
  -- for priests, make the balance show on the prompt - as healing others of blind/deaf takes no balance, while other other similar-looking lines do
  -- anyone else can see the class balance
  send(sys.ingamecustomprompt, false)

  -- defaults/reset
  for name, tbl in config_dict:iter() do
    if tbl.installstart then tbl.installstart(); raiseEvent("svo config changed", name) end
  end
  pipes.elm.id, pipes.skullcap.id, pipes.valerian.id = 0,0,0

  if sys.enabledgmcp then
    local city = gmcp.Char.Status.city:match("^(%w+)")
    if city then config.set("org", city, true) end

    if gmcp.Char.Status.level and tonumber(gmcp.Char.Status.level:match("^(%d+)")) >= 99 then
      config.set("dragonflex", true, true)
      config.set("dragonheal", true, true)
    else
      config.set("dragonflex", false, true)
      config.set("dragonheal", false, true)
    end
  end
end

-- logic: set relevant conf's to nil, go through a table of specific ones - if one is nil, ask the relevant question for it. inside alias to toggle it, call install again.

install.ask_install_questions = function ()
  if install.installing_system then return end

  install.installing_system = true
  install.check_install_step()
end

install.check_install_step = function()
  for name, tbl in config_dict:iter() do
    if conf[name] == nil and tbl.installcheck then
      echo "\n"
      tbl.installcheck()
      conf_printinstallhint(name)

      if printCmdLine then
        printCmdLine("vconfig "..name.." ")
      end

      return
    end
  end

  install.installing_system = false
  signals.gmcpcharskillsinfo:block(install.checkskillgmcp)
  signals.gmcpcharitemslist:block(install.checkinvgmcp)
  signals.gmcpcharskillslist:block(install.checkskilllist)
  echo"\n"
  echof("All done installing! Congrats.")
  signals.saveconfig:emit()

  decho(getDefaultColor().."If you'd like, you can also optionally setup the ")
  echoLink("parry", 'svo.sp.setup()', 'parry')
  decho(getDefaultColor().." system and the ")
  echoLink("herb precache", 'svo.showprecache()', 'herb precache')
  decho(getDefaultColor().." system. You can adjust the ")
  echoLink("echo colours", 'svo.config.showcolours()', 'echo colours')
  decho(getDefaultColor().." as well!")
  echo "\n"
  echof("I'd recommend that you at least glimpse through my docs as well so you sort of know what are you doing :)")

  if not conf.customprompt and not conf.setdefaultprompt then
    conf.setdefaultprompt = true
    setdefaultprompt()
    echo"\n" echof("I've setup a custom prompt for you that mimics the normal Achaean one, but also displays which afflictions have you got. See http://doc.svo.vadisystems.com/#setting-a-custom-prompt on how to customize it if you'd like, or if you don't like it, do 'vconfig customprompt off' to disable it.")
  end

  tempTimer(math.random(1,2), function ()
    echo"\n"
    echof("Oh, and one last thing - QQ, restart Mudlet and login again, so all changes can take effect properly.")
  end)
end

function install.checkskillgmcp()
  local t = _G.gmcp.Char.Skills.Info
  if not t then return end

  if t.skill == "clotting" then t.skill = "clot" end
  if t.skill == "parrying" then t.skill = "parry" end

  if conf[t.skill] == nil and t.info == "" then
    conf[t.skill] = false
    echof("Don't have %s, so <250,0,0>won't%s be using it whenever possible.", t.skill, getDefaultColor())
    raiseEvent("svo config changed", t.skill)
  elseif conf[t.skill] == nil then
    conf[t.skill] = true
    echof("Have %s, so <0,250,0>will%s be using it whenever possible.", t.skill, getDefaultColor())
    raiseEvent("svo config changed", t.skill)
  end

  installclear(t.skill)
end
signals.gmcpcharskillsinfo:connect(install.checkskillgmcp)
signals.gmcpcharskillsinfo:block(install.checkskillgmcp)

function install.checkinvgmcp()
  local t = _G.gmcp.Char.Items.List
  if not t.location == "inv" then return end

  -- feh! Easier to hardcode it for such a miniscule amount of items.
  -- If list enlarges, fix appopriately.
  for _, it in pairs(t.items) do
    if string.find(it.name, "%f[%a]pipe%f[%A]") then
      local r = pipe_assignid(it.id)
      if r then echof("Set the %s pipe id to %d.", r, it.id) end
    end
  end

end
signals.gmcpcharitemslist:connect(install.checkinvgmcp)
signals.gmcpcharitemslist:block(install.checkinvgmcp)


function install.checkskilllist()
  local t = _G.gmcp.Char.Skills.List
  if t.group == "survival" then
    for _, k in ipairs{{"focus", "focusing"}, {"restore", "restoration"}, {"insomnia", "insomnia"}, {"clot", "clotting"}, {"breath", "breathing"}, {"efficiency", "efficiency"}} do
      if contains(t.list, k[2]:title()) then
        config.set(k[1], true, true)
        installclear(k[1])
      end
    end

  end
end
signals.gmcpcharskillslist:connect(install.checkskilllist)
signals.gmcpcharskillslist:block(install.checkskilllist)
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

function togglesip(what)
  assert(what == nil or what == "health" or what == "mana", "svo.togglesip wants 'health' or 'mana' as an argument")

  local beforestate = sk.getbeforestateprios()

  local hp = dict.healhealth.sip.aspriority
  local mp = dict.healmana.sip.aspriority
  if what == nil or
    what == "health" and hp < mp or
    what == "mana" and mp < hp then
      hp, mp = mp, hp
  end
  dict.healhealth.sip.aspriority = hp
  dict.healmana.sip.aspriority = mp

  local function getstring(name)
    if name == "healmana_sip" then return "<13,19,180>mana"
    elseif name == "healhealth_sip" then return "<18,181,13>health"
    end
  end

  local prios = {}
  local links = {}
  for _, j in ipairs({dict.healhealth.sip, dict.healmana.sip}) do
    prios[j.name] = j.aspriority
    links[j.name] = j
  end

  local result = getHighestKey(prios)

  echof("Swapped to "  .. getstring(result) .. getDefaultColor() .. " sipping priority.")

  make_gnomes_work()

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

function aupdate()
  (openUrl or openURL)("http://doc.svo.vadisystems.com/#updating-the-system")
  -- echof("While we can't automatically update yet, here's the URL for you to download it at:")

  -- setFgColor(unpack(getDefaultColorNums))
  -- for os, url in pairs(sys.downloadurl) do
  --   echo("  "..os.." - ")
  --   setUnderline(true) echoLink(url, [[(openURL or openUrl)("]]..url..[[")]], "Download "..os.." version", true) setUnderline(false)
  -- end
  -- resetFormat()
  -- showprompt()
end

function toggle_ignore(action)
  if not dict[action] then
    echofn("%s isn't something you can ignore - see ", action)
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("vshow ignorelist", 'svo.ignorelist()', 'Click to see things you can ignore', true)
    setUnderline(false)
    echo(".\n")
    showprompt()
    return
  end

  if svo.ignore[action] then
    unsetignore(action)
    svo.echof("Won't ignore %s anymore.", action)
  else
    setignore(action)
    svo.echof("Will ignore curing %s now.", action)
  end
  svo.showprompt()
  make_gnomes_work()
end

function show_ignore()
  echof("Things we're ignoring:%s", not next(svo.ignore) and " (none)" or '')

  setFgColor(unpack(getDefaultColorNums))
  for key in pairs(ignore) do
    echo(string.format("  %-18s", tostring(key)))
    echo("(")
    setUnderline(true)
    echoLink("remove", 'svo.ignore.'..tostring(key)..' = nil; svo.echof("Took '..tostring(key)..' off ignore.")', 'Remove '..tostring(key)..' from the ignore list', true)
    setUnderline(false)
    echo(")")

    if dict[key] and dict[key].description then
      echo(" - "..dict[key].description)

      if type(ignore[key]) == 'table' and ignore[key].because then
        echo(", ignoring because "..ignore[key].because)
      end
      echo("\n")
    else
      if type(ignore[key]) == "table" and ignore[key].because then
        echo(" - because "..ignore[key].because)
      end
      echo("\n")
    end
  end
  showprompt()
end

function aconfigs()
  echof("Doesn't do anything yet!")
end

function aconfig()
  cecho("<a_darkblue>--<purple>(svo) <a_grey>Configuration<a_darkblue>" .. ("-"):rep(59) .. "\n")

  cecho("<a_darkcyan>  Automated healing:\n")
  cecho("<a_darkgrey>    Sipping:              Moss:\n")

  cecho(string.format(
    "%s    (%s%-2d%%%s) %s%-4d %shealth%s %-4s"
  .."(%s%-2d%%%s) %s%-4d %shealth%s %-4s\n",
    "<a_darkgrey>", "<a_darkcyan>", tostring(conf.siphealth), "<a_darkgrey>", "<a_cyan>", tostring(sys.siphealth), "<a_grey>", "<a_darkgrey>", " ",
    "<a_darkcyan>", tostring(conf.mosshealth), "<a_darkgrey>", "<a_cyan>", tostring(sys.mosshealth), "<a_grey>", "<a_darkgrey>", " "
  ))

  cecho(string.format(
    "%s    (%s%-2d%%%s) %s%-4d %smana%s %-6s"
  .."(%s%-2d%%%s) %s%-4d %smana%s %-6s\n",
    "<a_darkgrey>", "<a_darkcyan>", conf.sipmana, "<a_darkgrey>", "<a_cyan>", sys.sipmana, "<a_grey>", "<a_darkgrey>", " ",
    "<a_darkcyan>", conf.mossmana, "<a_darkgrey>", "<a_cyan>", sys.mossmana, "<a_grey>", "<a_darkgrey>", " "
  ))

  echo("\n")

  cecho("<a_darkcyan>  Curing status:\n")

  for k,v in config_dict:iter() do
    if v.vconfig1 and conf[k] and not v.vconfig2 then
      cecho("  ") fg("a_green")
      echoLink('  o  ', 'svo.config.set("'..k..'", false, true)', 'Click to disable '..k, true)
      cecho("<a_grey>Use "..(type(v.vconfig1) == "string" and v.vconfig1 or v.vconfig1())..".\n")
    elseif v.vconfig1 and not conf[k] and not v.vconfig2 then
      cecho("  ") fg("a_red")
      echoLink('  x  ', 'svo.config.set("'..k..'", true, true)', 'Click to enable '..k, true)
      cecho("<a_darkgrey>Use "..(type(v.vconfig1) == "string" and v.vconfig1 or v.vconfig1())..".\n")
    end
  end

  echo"\n"

  for k,v in config_dict:iter() do
    if not v.vconfig1 and type(v.onshow) == "string" and conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_green")
      echoLink('  o  ', 'svo.config.set("'..k..'", false, true)', 'Click to disable '..k, true)
      cecho("<a_grey>"..v.onshow..".\n")
    elseif not v.vconfig1 and type(v.onshow) == "string" and not conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_red")
      echoLink('  x  ', 'svo.config.set("'..k..'", true, true)', 'Click to enable '..k, true)
      cecho("<a_darkgrey>"..v.onshow..".\n")
    elseif not v.vconfig1 and type(v.onshow) == "function" and conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_green")
      echoLink('  o  ', 'svo.config.set("'..k..'", false, true)', 'Click to disable '..k, true)
      v.onshow("a_grey")
    elseif not v.vconfig1 and type(v.onshow) == "function" and not conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_red")
      echoLink('  x  ', 'svo.config.set("'..k..'", true, true)', 'Click to enable '..k, true)
      v.onshow("a_darkgrey")
    end
  end

  echo"\n"

  if not printCmdLine or not type(conf.unknownany) == "number" then
    cecho(string.format("    <a_blue>- <a_grey>Diagnosing after <a_cyan>%s <a_grey>unknown (any) afflictions.\n", tostring(conf.unknownany)))
  else
    cecho("    <a_blue>- <a_grey>Diagnosing after") fg("a_cyan")
    echoLink(' '..conf.unknownany..' ', "printCmdLine'vconfig unknownany '", "Click to set the # of any affs to diagnose at", true)
    cecho("<a_grey>unknown (any) afflictions.\n")
  end
  if not printCmdLine or not type(conf.unknownfocus) == "number" then
    cecho(string.format("    <a_blue>- <a_grey>Diagnosing after <a_cyan>%s <a_grey>unknown (focusable) afflictions.\n", tostring(conf.unknownfocus)))
  else
    cecho("    <a_blue>- <a_grey>Diagnosing after") fg("a_cyan")
    echoLink(' '..conf.unknownfocus..' ', "printCmdLine'vconfig unknownfocus '", "Click to set the # of focusable affs to diagnose at - this is in addition to focusing on each unknown, but focusable affliction", true)
    cecho("<a_grey>unknown (focusable) afflictions.\n")
  end

  fg("a_darkblue")
  echo(string.rep("-", 62))
  fg("purple") setUnderline(true) echoLink("vconfig2", [[svo.aconfig2()]], "View vconfig2 for advanced options", true) setUnderline(false)
  fg("a_darkblue") echo(string.rep("-", 9))
  resetFormat()
  echo"\n"
  showprompt()
  echo"\n"
end

function aconfig2()
  cecho("<a_darkblue>--<purple>(svo) <a_grey>Configuration, continued<a_darkblue>" .. string.rep("-", 48) .. "\n")

  cecho("<a_darkcyan>  Pipes:\n")
  -- cecho("<a_darkgrey>    Skullcap           Valerian           Elm\n")
  cecho(string.format(
    "%s    %-21s"
  .."   %-21s"
  .."   %s\n",
    "<a_darkgrey>",
    (pipes.skullcap.filledwith and pipes.skullcap.filledwith:title() or "Skullcap") .. (pipes.skullcap.id2 == 0 and '' or ' ('..pipes.skullcap.filledwith2:title()..')'),
    (pipes.valerian.filledwith and pipes.valerian.filledwith:title() or "Valerian") .. (pipes.valerian.id2 == 0 and '' or ' ('..pipes.valerian.filledwith2:title()..')'),
    (pipes.elm.filledwith and pipes.elm.filledwith:title() or "Elm") .. (pipes.elm.id2 == 0 and '' or ' ('..pipes.elm.filledwith2:title()..')')
  ))

  cecho(string.format(
    "%s    ID %s%-21s"
  .."%sID %s%-21s"
  .."%sID %s%s\n",
    "<a_grey>", "<a_cyan>", pipes.skullcap.id .. (pipes.skullcap.id2 == 0 and '' or ' ('..pipes.skullcap.id2..')'),
    "<a_grey>", "<a_cyan>", pipes.valerian.id .. (pipes.valerian.id2 == 0 and '' or ' ('..pipes.valerian.id2..')'),
    "<a_grey>", "<a_cyan>", pipes.elm.id .. (pipes.elm.id2 == 0 and '' or ' ('..pipes.elm.id2..')')
  ))

  cecho(string.format(
    "%s    Puffs %s%-18s"
  .."%sPuffs %s%-18s"
  .."%sPuffs %s%-2s\n",
    "<a_grey>", "<a_cyan>", pipes.skullcap.puffs .. (pipes.skullcap.id2 == 0 and '' or ' ('..pipes.skullcap.puffs2..')'),
    "<a_grey>", "<a_cyan>", pipes.valerian.puffs .. (pipes.valerian.id2 == 0 and '' or ' ('..pipes.valerian.puffs2..')'),
    "<a_grey>", "<a_cyan>", pipes.elm.puffs .. (pipes.elm.id2 == 0 and '' or ' ('..pipes.elm.puffs2..')')
  ))

local c1,s1 =
    unpack(pipes.skullcap.arty and
        {"<gold>", "Arty"} or
            (pipes.skullcap.lit and {"<a_yellow>", "Lit!"} or {"<a_darkgrey>", "Unlit."})

    )
local c2,s2 =
    unpack(pipes.valerian.arty and
        {"<gold>", "Arty"} or
            (pipes.valerian.lit and {"<a_yellow>", "Lit!"} or {"<a_darkgrey>", "Unlit."})

    )
local c3,s3 =
    unpack(pipes.elm.arty and
        {"<gold>", "Arty"} or
            (pipes.elm.lit and {"<a_yellow>", "Lit!"} or {"<a_darkgrey>", "Unlit."})

    )

  cecho(string.format("    %s%-24s%s%-24s%s%s\n\n",
    c1,s1,
    c2,s2,
    c3,s3
   ))

  cecho("<a_darkcyan>  Advanced options:\n")

  for k,v in config_dict:iter() do
    if not v.vconfig1 and type(v.onshow) == "string" and conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_green")
      echoLink('  o  ', 'svo.config.set("'..k..'", false, true)', 'Click to disable '..k, true)
      cecho("<a_grey>"..v.onshow..".\n")
    elseif not v.vconfig1 and type(v.onshow) == "string" and not conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_red")
      echoLink('  x  ', 'svo.config.set("'..k..'", true, true)', 'Click to enable '..k, true)
      cecho("<a_darkgrey>"..v.onshow..".\n")
    elseif not v.vconfig1 and type(v.onshow) == "function" and conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_green")
      echoLink('  o  ', 'svo.config.set("'..k..'", false, true)', 'Click to disable '..k, true)
      v.onshow("a_grey")
    elseif not v.vconfig1 and type(v.onshow) == "function" and not conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho("  ") fg("a_red")
      echoLink('  x  ', 'svo.config.set("'..k..'", true, true)', 'Click to enable '..k, true)
      v.onshow("a_darkgrey")
    end
  end

  echo"\n"

  cecho("    <a_blue>- <a_grey>Using ") setFgColor(unpack(getDefaultColorNums))
  echoLink(tostring(conf.echotype and conf.echotype or conf.org), 'svo.config.showcolours()', "View other available styles", true)
  cecho("<a_grey>-style echos.\n")

  if not printCmdLine then
    cecho(string.format("    <a_blue>- <a_grey>%s\n", (function ()
      if not conf.warningtype then
        return "Extended instakill warnings are disabled."
      elseif conf.warningtype == "all" then
        if math.random(1, 10) == 1 then
          return "Will prefix instakill warnings to all lines on the left. (muahah)"
        else
          return "Will prefix instakill warnings to all lines on the left." end
      elseif conf.warningtype == "prompt" then
        return "Will prefix instakill warnings only to prompt lines."
      elseif conf.warningtype == "right" then
        return "Will align instakill warnings to all lines on the right."
      end
    end)()))
  else
    cecho("    <a_blue>- ")
    fg("a_grey")
    echoLink((function ()
      if not conf.warningtype then
        return "Extended instakill warnings are disabled."
      elseif conf.warningtype == "all" then
        if math.random(1, 10) == 1 then
          return "Will prefix instakill warnings to all lines on the left. (muahah)"
        else
          return "Will prefix instakill warnings to all lines on the left." end
      elseif conf.warningtype == "prompt" then
        return "Will prefix instakill warnings only to prompt lines."
      elseif conf.warningtype == "right" then
        return "Will align instakill warnings to all lines on the right."
      end
    end)(), 'printCmdLine"vconfig warningtype "', "Change the warningtype - can be all, prompt, right or none", true)
    cecho("\n")
  end

  if not printCmdLine then
    cecho(string.format("    <a_blue>- <a_grey>Assuming <a_cyan>%s%% <a_grey>of stats under blackout/recklessness.\n", tostring(conf.assumestats)))
  else
    cecho("    <a_blue>- <a_grey>Assuming ") fg("a_cyan")
    echoLink(tostring(conf.assumestats).."%", 'printCmdLine"vconfig assumestats "', "Set the % of health and mana to assume under blackout or recklessness", true)
    cecho(" <a_grey>of stats under blackout/recklessness.\n")
  end

  cecho("    <a_blue>- <a_grey>Applying for health affs only above ") fg("a_cyan")
  echoLink(tostring(conf.healthaffsabove).."%", 'printCmdLine"vconfig healthaffsabove "', "Set the % of health below which we'll be sipping, and above we'll be applying for health afflictions", true)
  cecho(" <a_grey>health.\n")

  if not printCmdLine then
    cecho(string.format("    <a_blue>- <a_grey>Won't use mana skills below <a_cyan>%s%%<a_grey> mana.\n", tostring(conf.manause)))
  else
    cecho("    <a_blue>- <a_grey>Won't use mana skills below ") fg("a_cyan")
    echoLink(tostring(conf.manause).."%", 'printCmdLine"vconfig manause "', "Set the % of mana below which the system won't use mana-draining skills", true)
    cecho("<a_grey> mana.\n")
  end

  if not conf.customprompt then
    cecho("    <a_blue>- ") fg("a_grey")
    echoLink("Standard prompt is in use.", 'svo.config.set("customprompt", "on", true)', "Enable custom prompt", true)
    echo("\n")
  else
    cecho("    <a_blue>- ") fg("a_grey")
    echoLink("Custom prompt is in use", 'svo.config.set("customprompt", "off", true)', "Disable custom prompt", true)
    echo(" (")
    echoLink("view", 'svo.config.showprompt(); printCmdLine("vconfig customprompt "..tostring(svo.conf.customprompt))', "View the custom prompt you've currently set")
    echo(")")

    echo(" (")
    echoLink("reset", 'svo.setdefaultprompt(); svo.echof("Default custom prompt restored.")', "Reset the custom prompt to default")
    cecho("<a_grey>)\n")
  end

  for k,v in config_dict:iter() do
    if v.vconfig2string and type(v.onshow) == "string" then
      cecho("    <a_blue>- ")
      cecho("<a_grey>"..v.onshow..".\n")

    elseif v.vconfig2string and type(v.onshow) == "function" then
      cecho("    <a_blue>- ")
      v.onshow("a_grey")
    end
  end


  fg("a_darkblue")
  echo(string.rep("-", 62))
  fg("purple") setUnderline(true) echoLink("vconfig", [[svo.aconfig()]], "View vconfig for basic options", true) setUnderline(false)
  fg("a_darkblue") echo(string.rep("-", 10))
  resetFormat()

  echo"\n"
  showprompt()
  echo"\n"
end


function asave()
  signals.saveconfig:emit()
  showprompt()
end

function ashow()
  echof("Defence modes:")
  echo "  " defences.print_def_list()

  if sys.deffing then
    echof("Currently deffing up; waiting on %s to come up.", sk.showwaitingdefup())
  end

  echo"\n"

  echofn("View priorities (")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink("reset all to default", 'svo.prio.usedefault(true)', "Click here to reset all of the systems curing/defup priorities back to default", true)
  setUnderline(false)
  echo(", ")
  setUnderline(true)
  echoLink("import", 'svo.prio.list(true); printCmdLine"vimportprio "', "Click here select a priority list to import", true)
  setUnderline(false)
  echo(", ")
  setUnderline(true)
  echoLink("export", 'printCmdLine"vexportprio " ', "Click here to give your priorities a name & export them", true)
  setUnderline(false)
  echo("):\n")
  echo("  ")
  setUnderline(true)
  echoLink("herb", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("herb")]])', 'View herb balance priorities', true)
  setUnderline(false) setUnderline(false) echo", " setUnderline(true) setUnderline(true)
  echoLink("focus", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("focus")]])', 'View focus balance priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("salve", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("salve")]])', 'View salve balance priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("purgative", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("purgative")]])', 'View purgative balance priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("smoke", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("smoke")]])', 'View smoke priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("sip", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("sip")]])', 'View sip balance priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("balance/equilibrium", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("physical")]])', 'View balance priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("misc", 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder("misc")]])', 'View miscellaneous priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("aeon/retardation", 'tempTimer(0, [[echo([=[ \n]=]); svo.printordersync()]])', 'View slow curing priorities', true)
  setUnderline(false) echo", " setUnderline(true)
  echoLink("parry", 'tempTimer(0, [[echo([=[ \n]=]); svo.sp.show()]])', 'View the parry setup', true)
  resetFormat()
  echo"\n"

  echofn("Serverside use:   ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.serverside and "enabled" or "disabled", "svo.tntf_set('serverside', "..(conf.serverside and "false" or "true").. ', false); svo.ashow()', (conf.serverside and "Disable" or "Enable")..' use of serverside by Svof', true)
  resetFormat()
  echo"\n"


  echofn("Anti-illusion:    ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.aillusion and "enabled" or "disabled", "svo.tntf_set('ai', "..(conf.aillusion and "false" or "true").. ', false); svo.ashow()', (conf.aillusion and "Disable" or "Enable")..' anti-illusion', true)
  resetFormat()
  echo"\n"

  echofn("Defence keepup:   ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.keepup and "enabled" or "disabled", "svo.tntf_set('keepup', "..(conf.keepup and "false" or "true").. ', false); svo.ashow()', (conf.keepup and "Disable" or "Enable")..' keepup', true)
  resetFormat()
  echo"\n"

  echofn("Bashing triggers: ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.bashing and "enabled" or "disabled", "svo.tntf_set('bashing', "..(conf.bashing and "false" or "true").. ', false); svo.ashow()', (conf.bashing and "Disable" or "Enable")..' bashing triggers', true)
  resetFormat()
  echo"\n"

  echofn("Arena mode:       ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.arena and "enabled" or "disabled", "svo.tntf_set('arena', "..(conf.arena and "false" or "true").. ', false); svo.ashow()', (conf.arena and "Disable" or "Enable")..' arena triggers', true)
  resetFormat()
  echo"\n"

echo"\n"
  echofn("Cure method: ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink(tostring(conf.curemethod), [=[
    svo.echof([[Possible options are:
  * conconly - default - uses only the usual Concoctionist potions, salves and herbs
  * transonly - uses only the new Alchemy cures
  * preferconc - uses either available cures that you have, but prefers Concoctions ones. This method does optimize for curing speed - if you don't have a herb in your inventory but have an equivalent mineral, it'll eat the mineral since it's quicker (don't have to outr the herb)
  * prefertrans - similar to preferconc, but prefers Transmutation cures
  * prefercustom - allows you to individually select which cures would you prefer over which, using the vshow curelist menu. Similar to other prefers, the system will use your preferred cure if you have it and fall back to the alternative if you don't. If the cure is a herb/mineral and your preferred cure is in the rift but the alternative is already available in the inventory, then the system will eat the alternative, because that is faster than outring it.]]);
    printCmdLine"vconfig curemethod "]=], "Set the curemethod to use - conconly, transonly, preferconc, prefertrans or prefercustom", true)
  setUnderline(false)

  if conf.curemethod and conf.curemethod == "prefercustom" then
    echo(" (")
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("configure it", 'svo.showcurelist()', "Setup which cures would you prefer over which for prefercustom - also accessible via vshow curelist", true)
    setUnderline(false)
    setFgColor(unpack(getDefaultColorNums))
    echo(")")
  end
  echo"\n"

  echofn("Current parry strategy is:  ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  local spname
  if not sp_config.parry or sp_config.parry == '' then
    spname = "(none)"
  elseif type(sp_config.parry) == "function" then
    spname = "(custom "..tostring(sp_config.parry)..")"
  else
    spname = tostring(sp_config.parry)
  end

  echoLink(spname, 'svo.sp.setparry(nil, true)', 'Click to change the parry strategy. When in "manual", use the p* (pra, pla, ph, etc...) alises to parry/guard with', true)
  setUnderline(false)
  echo'\n'

  if me.doqueue.repeating then
    echof("Do-Repeat is enabled: %s", tostring(me.doqueue[1]) or "(nothing yet)") end


  if conf.curemethod and (conf.curemethod == "preferconc" or conf.curemethod == "prefertrans") then
    echofn("Cure method is %s: ", tostring(conf.curemethod))
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("reset sip alternatives", [[
      svo.es_potions = svo.es_potions or {}
      for thing, category in pairs(svo.es_categories) do
        svo.es_potions[category] = svo.es_potions[category] or {}
        if category ~= "venom" then
          svo.es_potions[category][thing] = {sips = 1, vials = 1, decays = 0}
        end
      end
      svo.echof("Reset alternatives, will use the preferred potions now.")
    ]], 'Reset sipping alternatives for '..tostring(conf.curemethod)  , true)
    setUnderline(false)
    echo("\n")
  end

  if conf.lag ~= 0 then
    echof("Lag tolerance level: %d", conf.lag)
  end

  local c = table.size(me.lustlist)
  if conf.autoreject == "black" then
    echofn("People we're autorejecting:  %s ", (c ~= 0 and c or 'none'))
  elseif conf.autoreject == "white" then
    echofn("People we're not autorejecting: %s ", (c ~= 0 and c or 'none'))
  end

  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink("(view)", 'echo"\\n" expandAlias"vshow lustlist"', 'Click here view the names', true)
  echo"\n"

  if next(me.unparryables) then
    echofn("Things we can't use for parrying: %s ", oneconcat(me.unparryables))

    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("(reset)", 'echo"\\n" svo.me.unparryables = {} svo.echof"Cleared list of stuff we can\'t parry with."', 'Click here to reset', true)
    echo"\n"
  end

  do
    local c = 0
    for herb, count in pairs(rift.precache) do
      c = c + count
    end

    echofn("# of herbs we're precaching: %d ", c)

    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("(view)", 'echo"\\n" svo.showprecache()', 'Click here open the menu for precache', true)
    echo"\n"
  end

  do
    local c = table.size(ignore)

    echofn("# of things we're ignoring:  %d ", c)

    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("(view)", 'echo"\\n" svo.show_ignore()', 'Click here open the ignore list menu', true)
    echo"\n"
  end

  if next(affs) then
    showaffs()
  end

  if conf.customprompt and (affs.blackout or innews) then
    echofn("Custom prompt is enabled, but not showing due to %s. ",
      (function ()
        local t = {}
        if affs.blackout then t[#t+1] = "blackout" end
        if innews then t[#t+1] = "being in the editor" end
        return concatand(t)
      end
    )())
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("(reset)", 'svo.config.set("customprompt", "on")', 'Click here to re-enable the custom prompt', true)
    echo"\n"
  end

  if conf.paused then
    echof("System is currently paused.") end
  if me.dopaused then
    echof("Do system is currently paused.") end

  if sk.gettingfullstats then
    echof("Healing health and mana to up to full stats (cancel).") end

  -- warn people if they have mana above health as sip priority by accident
  if prio.getnumber("healmana", "sip") > prio.getnumber("healhealth", "sip") then
    echofn("Your mana sip priority is above health sipping (")
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true) echoLink("change", 'svo.togglesip("health")', 'Click to change to health', true) setUnderline(false)
    echo(")\n")
  end

  raiseEvent("svo onshow")

  showprompt()
end


function showaffs(window)
  if sys.sync then echof(window or "main", "Slow curing mode enabled.") end
  echof(window or "main", "Current list of affs: " .. tostring(affs))
end

function showbals(window)
  echof(window or "main", "Balance state: " ..
    (function (tbl)
      local result = {}
      for i,j in pairs(tbl) do
        if j then
          result[#result+1] = string.format("<50,205,50>%s%s", i,getDefaultColor())
        else
          result[#result+1] = string.format("<205,201,201>%s (off)%s", i,getDefaultColor())
        end
      end

      table.sort(result)
      return table.concat(result, ", ")
    end)(bals))
    showprompt()
end

function showserverside()
  local function echoaction(action, last)
    dechoLink(string.format("<153,204,204>[<0,204,0>%s<153,204,204>] %"..(last and '' or '-23').."s",
      serverignore[action] and ' ' or 'x', action),
      string.format([[svo.%ssetserverignore("%s"); svo.showserverside()]], serverignore[action] and 'un' or '', action),
      serverignore[action] and ('Make Svof handle '..action..' instead of serverside') or ('Make serverside handle '..action..' instead of Svof'), true)
  end

  local actions = sk.getallserversideactions()

  echof("Things serverside can do but Svof will be handling instead:")
  for i = 1, #actions, 3 do
    local action1, action2, action3 = actions[i], actions[i+1], actions[i+2]

    echoaction(action1)
    if action2 then echoaction(action2) end
    if action3 then echoaction(action3, true) end
    echo'\n'
  end

  echo'\n'

  if not conf.serverside then
    dechoLink(getDefaultColor().."  (enable serverside use)", 'svo.tntf_set("serverside", true)', 'Serverside use is disabled - click here to enable it', true)
    echo'\n'
  end

  dechoLink(getDefaultColor().."  (disable all)", 'svo.enableallserverside()', 'Click here to make serverside handle everything', true)
  dechoLink(getDefaultColor().."  (restore defaults)", 'svo.enabledefaultserverside()', 'Click here to restore default options', true)
  echo'\n'
  showprompt()
end

function svo.enableallserverside()
  local actions = sk.getallserversideactions()

  for i = 1, #actions do
    local action = actions[i]

    setserverignore(action)
  end

  echof("Disabled all serverside overrides; serverside will now handle everything.")
  showprompt()
end

function svo.enabledefaultserverside()
  unsetserverignore"impale"
  unsetserverignore"lovers"
  unsetserverignore"roped"
  unsetserverignore"transfixed"
  unsetserverignore"webbed"
  unsetserverignore"selfishness"

  echof("Restored defaults on what should Svof handle instead of serverside.")
  showprompt()
end

function showcurelist()
  local herb_list  = rift.curativeherbs
  local herbs      = rift.herb_conversions
  local vials_list = rift.forestalvials
  local vials      = rift.vial_conversions

  local function showfor(list, conversion)
    for i = 1, #list do
      local forestal, alchy = list[i], conversion[list[i]]
      local preferred = me.curelist[forestal]

      if forestal == preferred then -- split the logic instead of stuffing into one uncomprehensible string.format
        cecho(string.format("<white>%15s", forestal))
      else
        cechoLink(string.format("<dim_grey>%15s", forestal), [[svo.me.curelist.]]..forestal..[[ = "]]..forestal..[["; svo.showcurelist()]], "Click to prefer "..forestal.." over "..alchy, true)
      end

      cechoLink(" <royal_blue><<BlueViolet>-<royal_blue>> ", [[svo.me.curelist.]]..forestal..[[ = "]]..(forestal == preferred and alchy or forestal)..[["; svo.showcurelist()]], "Click to swap "..forestal.." and "..alchy.." cures", true)

      if alchy == preferred then
        cecho(string.format("<white>%-15s", alchy))
      else
        cechoLink(string.format("<dim_grey>%-15s", alchy), [[svo.me.curelist.]]..forestal..[[ = "]]..alchy..[["; svo.showcurelist()]], "Click to prefer "..alchy.." over "..forestal, true)
      end

      echo("\n")
    end
  end

  echof("Click on what you'd like to be preferred in prefercustom curemethod:\n")
  decho(string.format("%s            herbs/minerals\n", getDefaultColor()))

  showfor(herb_list, herbs)

  if conf.curemethod ~= "prefercustom" then
    echo"\n"
    echofn("This is the setup for the prefercustom curemethod - which you aren't currently using (you're using %s).\n  Do you want to change to prefercustom? Click here if so: ", conf.curemethod)

    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("vconfig curemethod prefercustom", 'svo.config.set("curemethod", "prefercustom", true); svo.showcurelist()', 'Click to change the curemethod from '..conf.curemethod..' to prefercustom, which allows you to individually specify which cures you prefer', true)
    setUnderline(false)
    echo'\n'
  end

  echo"\n"
  showprompt()
end


function app(what, quiet)
  assert(what == nil or what == "on" or what == "off" or type(what) == "boolean", "svo.app wants 'on' or 'off' as an argument")

  if what == "on" or what == true or (what == nil and not conf.paused) then
    conf.paused = true
  elseif what == "off" or what == false or (what == nil and conf.paused) then
    conf.paused = false
    sk.paused_for_burrow = nil
  end

  if not quiet then echof("System " .. (conf.paused and "paused" or "unpaused") .. ".") end
  raiseEvent("svo config changed", "paused")

  make_gnomes_work()
end

function dop(what, echoback)
  assert(what == nil or what == "on" or what == "off" or type(what) == "boolean", "svo.dop wants 'on' or 'off' as an argument")

  if what == "on" or what == true or (what == nil and not me.dopaused) then
    me.dopaused = true
  elseif what == "off" or what == false or (what == nil and me.dopaused) then
    me.dopaused = false
  end

  if echoback then echof("Do system " .. (me.dopaused and "paused" or "unpaused") .. ".") end

  make_gnomes_work()
end

function dv()
  sys.manualdiag = true
  make_gnomes_work()
end

function inra()
  if not sys.enabledgmcp then echof("You need to enable GMCP for this alias to work.") return end

  sk.inring = true
  sendGMCP("Char.Items.Inv")
  sendSocket"\n"
end

function get_herbs()
  if not sys.enabledgmcp then echof("You need to enable GMCP for this alias to work.") return end

  if (affs.blindaff or defc.blind) and not defc.mindseye then echof("vget herbs doesn't work when you're true blind (if you do have mindseye, perhaps check def?)") return end

  sk.retrieving_herbs = true
  send("ql", false)
end

function adf()
  me.manualdefcheck = true
  make_gnomes_work()
end

function manualdef()
  doaction(dict.defcheck.physical)
end

function manualdiag()
  if sys.sync then sk.gnomes_are_working = true end
  killaction(dict.diag.physical)
  doaction(dict.diag.physical)
  if sys.sync then sk.gnomes_are_working = false end
end

function reset.affs(echoback)
  for aff in pairs(affs) do
    if aff ~= "lovers" then
      removeaff(aff)
    end
  end

  affsp = {}

  if echoback then
    if math.random(10) == 1 then
      echof("BEEP BEEP! Affs reset.")
    else
      echof("All afflictions reset.")
    end
  end
end

function reset.general()
  actions = pl.OrderedMap()
  lifevision.l = pl.OrderedMap()

  for bal in pairs(bals_in_use) do
    bals_in_use[bal] = {}
  end

  actions_performed = {}
  sk.onpromptfuncs = {}
  sk.checkaeony()
  signals.aeony:emit()
  signals.canoutr:emit()
  innews = false
  passive_cure_paragraph = false
  check_generics()
end

function reset.defs(echoback)
  for def, status in pairs(defc) do
    if not defs_data[def] or (defs_data[def] and not defs_data[def].stays_on_death) then
      defc[def] = nil
    end
  end

  -- parry is also counted as a def and is reset on burst/death, so clear it here as well
  local t = sps.parry_currently
  for limb, _ in pairs(t) do t[limb] = false end

  if echoback then echof("all defences reset.") end
end

signals.charname:connect(function() reset.defs() end)
signals.gmcpcharname:connect(function() reset.defs() end)

function reset.bals(echoback)
  -- create a new table instead of resetting the values in the old, because if you
  -- screw up and delete some balances - you'd expect reset to restore them
  bals = {
    herb = true, sip = true, moss = true,
    purgative = true, salve = true,
    balance = true, equilibrium = true, focus = true,
    tree = true, leftarm = "unset", rightarm = "unset",
    dragonheal = true, smoke = true,
  }

  for balance in pairs(bals) do raiseEvent("svo got balance", balance) end

  if echoback then echof("All balances reset.") end
end

function ignorelist()
  local t = {}
  local count = 0

  local skip
  for k,v in pairs(dict) do
    for balance, _ in pairs(v) do
      if balance == "waitingfor" or balance == "happened" then skip = true end
    end

    if not skip then t[#t+1] = k end
    skip = false
  end
  table.sort(t)
  echof("Things we can ignore:") echo"  "

  for _, name in ipairs(t) do
    echo(string.format("%-20s", name))
    count = count + 1
    if count % 4 == 0 then echo "\n  " end
  end
  echo'\n' showprompt()
end

function afflist()
  local function getaffs()
    local t = {}

    for k,v in pairs(dict) do
      if v.aff and not v.aff.notagameaff then t[#t+1] = k end
    end
    table.sort(t)

    return t
  end

  -- key-value table with an explanation message
  local function getuncurables(affs)
    local uncurables = {}
    local type = type

    -- check all balances, and if any get flagged, add with a message listing all balances
    for _, affname in ipairs(affs) do
      local uncurablebalances = {}
      for balancename, balancedata in pairs(dict[affname]) do
        if type(balancedata) == "table" and balancedata.uncurable then uncurablebalances[#uncurablebalances+1] = balancename end
      end

      if uncurablebalances[1] then
        uncurables[affname] = string.format("%s affliction doesn't have a cure on the %s balance%s", affname, concatand(uncurablebalances), (#uncurablebalances > 1 and 's' or ''))
      end
    end

    return uncurables
  end

  local t = getaffs()
  local uncurables = getuncurables(t)
  local count = 0

  echof("Affliction list (%d):", #t) echo"  "

  local underline = setUnderline; _G.setUnderline = function () end

  local function getspacecount(name)
    if not valid["proper_"..name] and not uncurables[name] then
      return 23
    elseif valid["proper_"..name] and not uncurables[name] then
      return 37
    elseif valid["proper_"..name] and uncurables[name] then
      return 47
    elseif not valid["proper_"..name] and uncurables[name] then
      return 37
    end
  end

  local function gettext(name)
    if not valid["proper_"..name] and not uncurables[name] then
      return name
    elseif valid["proper_"..name] and not uncurables[name] then
      return name.." <0,128,128>pr<r>"
    elseif valid["proper_"..name] and uncurables[name] then
      return name.." <0,128,128>pr uc<r>"
    elseif not valid["proper_"..name] and uncurables[name] then
      return name.." <0,128,128>uc<r>"
    end
  end

  local function gethinttext(name)
    if not uncurables[name] then
      return "Click to the the function to use for "..name
    else
      return "Click to the the function to use for "..name..". Note also that this action has no in-game equivalent (UnCurable), so server-side priority can't be set for this"
    end
  end

  for _, name in ipairs(t) do
    dechoLink(string.format("%-"..getspacecount(name).."s", gettext(name)),
        string.format([[svo.echof("Function to use for this aff:\nsvo.valid.%s()")]], not valid["proper_"..name] and "simple"..name or "proper_"..name), gethinttext(name), true)
    count = count + 1
    if count % 3 == 0 then echo "\n  " end
  end
  if count % 3 == 0 then echo "\n  " end
  echo'\n' showprompt()
  _G.setUnderline = underline
end

function adddefinition(tag, func)
  assert(type(tag) == "string" and type(func) == "string", "svo.adddefinition: need both tag and function to be strings")
  cp.adddefinition(tag, func)
end

function vaff(aff)
  if not dict[aff] or not dict[aff].aff then echof(aff.." isn't a known affliction to add.") return end

  if debug.traceback():find("Trigger", 1, true) then
    (svo.valid["proper_"..aff] or svo.valid["simple"..aff])()
  else
    if dict[aff].aff and dict[aff].aff.forced then
      dict[aff].aff.forced()
    elseif dict[aff].aff then
      dict[aff].aff.oncompleted()
    else
      addaff(dict[aff])
    end

    if aff == "aeon" then removeaff("retardation") end
    signals.after_lifevision_processing:unblock(cnrl.checkwarning)
    sk.checkaeony()
    signals.aeony:emit()
    make_gnomes_work()
  end
end

function vrmaff(aff)
  if not dict[aff] or not dict[aff].aff then echof(aff.." isn't a known affliction to remove.") return end

  if lifevision.l[aff.."_aff"] then
    lifevision.l:set(aff.."_aff", nil)
  end

  if dict[aff].gone then
    dict[aff].gone.oncompleted()
  else
    removeaff(aff)
  end
  signals.after_lifevision_processing:unblock(cnrl.checkwarning)
  sk.checkaeony()
  signals.aeony:emit()
  make_gnomes_work()
end

  transmute = function()
  end

-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

pl.dir.makepath(getMudletHomeDir() .. "/svo/defup+keepup")

--[[ a small dictionary to know which defences belong to which skillset ]]
defences.def_types = {}

-- the list from 'def'
defences.def_def_list = {}
defences.defup_timer = createStopWatch()

function defences.gettime(defence, max)
  if not defc[defence] then return "" end

  local time = max-math.ceil(getStopWatchTime(dict[defence].stopwatch)/max)
  if time < 0 then return "" else
    return time.."m"
  end
end

-- functions to handle the defc table events updates
function defences.got(def)
  if not defc[def] then defc[def] = true; raiseEvent("svo got def", def) end
end

function defences.lost(def)
  if defc[def] then defc[def] = false; raiseEvent("svo lost def", def) end
end

-- custom def types like channels
defences.custom_types = {}

defences.nodef_list = phpTable()

defdefup = {
  basic  = {},
  combat = {},
  empty  = {},
}

defkeepup = {
  basic  = {},
  combat = {},
  empty  = {},
}

-- set an initial mode to something, as it always needs to be a valid mode
defs.mode = "basic"

-- defc = current defs

-- specialskip: if this function returns true, that defence will be ignored for defup
defs_data = pl.OrderedMap {}
  defs_data:set("softfocus", { type = "general",
    mana = "lots",
    def = "You have softened the focus of your eyes.",
    on = {"You let your eyes go out of focus, causing you to miss some details.", "Your eyes are already out of focus."},
    off = {"You bring your eyes back into focus.", "Your eyes are already in focus."}})
  defs_data:set("metawake", { type = "general",
    def = "You are concentrating on maintaining distance from the dreamworld.",
    mana = "lots",
    on = {"You order your mind to ensure you will not journey far into the dreamworld.", "You already have metawake turned on."},
    off = {"You cease concentrating on maintaining distance from the dreamworld.", "You already have metawake turned off."}})
  defs_data:set("mass", { type = "general",
    def = "You are extremely heavy and difficult to move.",
    offr = {[[^You are pulled out of the room by \w+ and (?:his|her) whip\!$]],
            [[^A large handaxe comes flying into the room, arcs toward you, and carries you away with it to \w+!$]]},
    off = {"You feel your density return to normal.", "The savage winds pick you up and toss you through the air."}})
  defs_data:set("magicresist", { type = "general",
    on_only = "That resistance already suffuses your form.",
    def = "You are enchanted against magic damage."})
  defs_data:set("fireresist", { type = "general",
    on_only = "That resistance already suffuses your form.",
    def = "You are enchanted against fire damage."})
  defs_data:set("electricresist", { type = "general",
    on_only = "That resistance already suffuses your form.",
    def = "You are enchanted against electric damage."})
  defs_data:set("coldresist", { type = "general",
    on_only = "That resistance already suffuses your form.",
    def = "You are enchanted against cold damage."})
  defs_data:set("skywatch", { type = "general",
    mana = "little",
    def = "You are aware of movement in the skies.",
    on = {"You are now watching the skies.", "You are already watching the skies."},
    off = "You are no longer watching the skies."})
  defs_data:set("toughness", { nodef = true,
    def = "Your skin is toughened." })
  defs_data:set("chivalry defended", { nodef = true,
    def = "You are being defended by a stalwart ally." })
  defs_data:set("pear", { nodef = true,
    def = "You are surrounded by a pocket of air."})
  defs_data:set("resistance", { nodef = true,
    def = "You are resisting magical damage."})
  defs_data:set("empower", { nodef = true,
    ondef = function () return "("..matches[2]..")" end,
    on = "You are already empowered by astronomical energies.",
    defr = [[^You are resonating with (?:the )?(?:Nebula )?(\w+)'s energy\.$]]})
  defs_data:set("reflection", { nodef = true,
    def = "You are surrounded by one reflection of youself.",
    defr = [[^You are surrounded by \d+ reflections? of yourself\.$]]})
  defs_data:set("shipwarning", { nodef = true,
    def = "You are aware of all nearby ship movements."})
  defs_data:set("constitution", { nodef = true,
    def = "You are using your superior constitution to prevent nausea." })
  defs_data:set("preaching", { nodef = true,
    def = "You have accepted a blessing for aid in times of need." })
  defs_data:set("frostblessing", { nodef = true,
    def = "You are protected by the power of a Frost Spiritshield."})
  defs_data:set("willpowerblessing", { nodef = true,
    def = "You are regenerating willpower at an increased rate."})
  defs_data:set("thermalblessing", { nodef = true,
    def = "You are protected by the power of a Thermal Spiritshield."})
  defs_data:set("earthblessing", { nodef = true,
    def = "You are protected by the power of an Earth Spiritshield."})
  defs_data:set("harmony", { nodef = true,
    ondef = function () return "("..matches[2]..")" end,
    defr = [[^You are under the blessing of the (\w+) environment\.$]]})
  defs_data:set("enduranceblessing", { nodef = true,
    def = "You are regenerating endurance at an increased rate.",})
  defs_data:set("thirdeye", { type = "general", def = "You possess the sight of the third eye.",
    on = {"You now possess the gift of the third eye.", "You already possess the thirdeye.", "You already possess the gift of the third eye."}})
  defs_data:set("treewatch", { type = "general",
    mana = "little",
    def = "You are watching the trees or rigging above for signs of movement.",
    on = {"You begin to keep a watchful eye on the treeline.", "You begin to keep a watchful eye on the rigging."},
    off = "You cease to watch the treeline."})
  defs_data:set("groundwatch", { type = "general",
    mana = "little",
    def = "You are aware of movement on the ground.",
    on = {"You begin to keep a watchful eye on the ground below.", "You are already keeping a watchful eye on the ground."},
    off = "You cease keeping a watchful eye on the ground below."})
  defs_data:set("alertness", { type = "general",
    mana = "little",
    def = "Your senses are attuned to nearby movement.",
    on = {"You prick up your ears.", "Alertness is already on!", "Your sense of hearing is already heightened."},
    off = {"You cease your watchful alertness.", "Alertness is already off!"}})
  defs_data:set("curseward", { type = "general",
    def = "A curseward has been established about your person.",
    off = "Your curseward has been breached!",
    on = {"You bring a curseward into being to protect you from harm.", "You already have curseward up."}})
  defs_data:set("bell", { type = "general",
    on = {"You will now attempt to detect attempts to spy on your person.", "You touch the bell tattoo."},
    def = "You are protected by the bell tattoo."})
  defs_data:set("cloak", { type = "general",
    on = {"You caress the tattoo and immediately you feel a cloak of protection surround you.", "You are already protected by the cloak tattoo."},
    def = "You are surrounded by a cloak of protection."})
  defs_data:set("favour", { nodef = true,
    ondef = function () return string.format("(%s by %s, %sh)",matches[2],matches[3], matches[4]) end,
    defr = [[^You are (\w+)favoured by (\w+) for over \d+ Achaean month \(which is about (\d+) hours?\)$]] })
  defs_data:set("telesense", { type = "general",
    mana = "little",
    def = "You are attuned to local telepathic interference.",
    on = {"You attune your mind to local telepathic interference.", "Your mind is already attuned to local telepathic interference."},
    off = {"Your mind is no longer concentrating on telepathic interference.", "Your mind is already not attuned to local telepathic interference."}})
  defs_data:set("hypersight", { type = "general",
    mana = "little",
    def = "You are utilising hypersight.",
    on = {"You concentrate your mind and engage your ability of hypersight.", "You are already concentrating on hypersight."},
    off = {"You cease to concentrate on hypersight.", "You are already not concentrating on hypersight."}})
  defs_data:set("parry", { nodef = true,
    ondef = function ()
      local t = sps.parry_currently
      for limb, _ in pairs(t) do t[limb] = false end
      t[matches[2]] = true
      check_sp_satisfied()

      return "("..matches[2]..")"
    end,
    tooltip = "Completely blocks health and wound damage on a limb if you aren't hindered.",
    defr = [[^You will attempt to parry attacks to your (.+)\.$]]
  })

  defs_data:set("nightsight", { type = "general",
    def = "Your vision is heightened to see in the dark.",
    on = {"Your vision sharpens with light as you gain night sight.", "Your eyes already have the benefit of night sight."},
    off = {"Your eyes lose the benefit of night sight.", "Your eyes cannot lose the benefit of night sight, since they do not already have it!"}})
  defs_data:set("block", { type = "general",
    specialskip = function ()
      return (not sys.enabledgmcp) or not (gmcp.Room and gmcp.Room.Info.exits[conf.blockingdir])
    end,
    ondef = function ()
      dict.block.physical.blockingdir = sk.anytoshort(matches[2])
      return "("..dict.block.physical.blockingdir..")"
    end,
    defr = [[^You are blocking the exit (.+)\.$]],
    off = {"You stop blocking.", "You were not blocking.", "You cease blocking the exit.", "You begin to flap your wings powerfully, and rise quickly up into the firmament."},
    })
  defs_data:set("targetting", { nodef = true,
    ondef = function () return "("..matches[2]..")" end,
    tooltip = "Focuses hits on the targetted limb.",
    defr = [[^You are aiming your attacks to the (.+)\.$]]
  })
  defs_data:set("breath", { type = "general",
    onenable = function (mode, newdef, whereto, echoback)
      if svo["def"..whereto][mode].meditate then
        svo["def"..whereto][mode].meditate = false
        if echoback then echof("Removed meditate from %s, it's incompatible with %s to have simultaneously up.", whereto, newdef) end
      end

      return true
    end}) -- added in xml w/ conf.gagbreath
  defs_data:set("vigilance", { type = "general",
    on = {"You squint your eyes, more alert to potential danger.", "You are already vigilant."},
    mana = "little",
    def = "You are vigilantly watching for potential danger.",
    off = {"You relax your vigilance.", "You are not maintaining vigilance."}})
  defs_data:set("satiation", { type = "general",
    invisibledef = true,
    on = {"You begin concentrating on efficient digestion.", "You are already concentrating on efficient digestion."},
    off = "Your digestive efficiency returns to normal."})
  defs_data:set("clinging", { type = "general",
    on = {"You begin to use your entire body to cleverly cling to the branches of the tree while still maintaining a great deal of freedom of action.","You are already clinging to the trees.", "You must be in the trees to cling to branches, or in the rigging of a ship to cling to the ropes."},
    off = "You cease your clinging behaviour and release the tree.",
    def = {"You are clinging tightly to the trees.", "You are clinging tightly to a ship's rigging."}})
  defs_data:set("selfishness", { type = "general", def = "You are feeling quite selfish.",
    onenable = function (mode, newdef, whereto, echoback)
      if conf.serverside and svo.serverignore.selfishness then
        svo.serverignore.selfishness = nil
        echof("Setting Selfishness to be handled by Svof - serverside can't auto-generosity.")
      end

      return true
    end,
    on = {"You rub your hands together greedily.", "You already are a selfish bastard."},
    off = {"A feeling of generosity spreads throughout you.", "No worries. You're not a selfish bastard as is."}})
  defs_data:set("flying", { nodef = true,
    def = "You are soaring high above the ground." })
  defs_data:set("starburst", { nodef = true,
    def = "You are walking with the grace of the stars." })
  defs_data:set("chameleon", { nodef = true,
    ondef = function () return "("..matches[2]..")" end,
    defr = [[^You are assuming the identity of (\w+)\.$]]})
  defs_data:set("insomnia", { type = "general",
    def = "You have insomnia, and cannot easily go to sleep.",
    -- insomnia curing it is done in trigs as well
    -- "Your insomnia has cleared up.": done in triggers for loki
  })
  defs_data:set("kola", { type = "general",
    def = "You are feeling extremely energetic." })
  defs_data:set("extra crits", { nodef = true,
    def = "You are surrounded by a lucky green aura."})
  defs_data:set("rebounding", { type = "general",
    def = "You are protected from hand-held weapons with an aura of rebounding.",
    off = {"Your defensive barriers disappear.", "Your aura of weapons rebounding disappears.", "A small brown lemming rips apart your aura of rebounding defence with its claws.", "The vines rip apart the aura of rebounding surrounding you."},
    offr = {[[^\w+'s cantata shatters the defences surrounding you\.$]], [[^\w+ delivers a single, powerful blow to the aura of rebounding surrounding you, shattering it\.$]], [[^\w+ brings .+? down in a single diagonal stroke, carving cleanly through your aura of rebounding\.$]], [[^\w+ whirls .+? over (?:her|his) head, before bringing it down upon your aura of rebounding, shattering it instantly\.$]], [[^The point of .+? strikes your aura of rebounding, and rapid cracks begin to spread outward from the point of impact\. Moments later, the protection shatters\.$]]}})
  defs_data:set("blind", { type = "general",
    def = "You are blind." })
  defs_data:set("xpboost", { nodef = true,
    ondef = function () return "("..matches[2]..")" end,
    defr = [[^You are experiencing a (\d+) percent experience boost\.$]] })
  defs_data:set("xpbonus", { nodef = true,
    ondef = function () return "("..matches[2]..")" end,
    defr = [[^You are benefitt?ing from a (\d+)% experience bonus\.$]] })
  defs_data:set("deaf", { type = "general",
    def = "You are deaf.",
    off = "The unnatural sound rips through your defences against auditory attacks." })
  defs_data:set("xp gain", { nodef = true,
    def = "You are surrounded by a vibrant white aura." })
  defs_data:set("myrrh", { type = "general",
    def = "Your mind is racing with enhanced speed." })
  defs_data:set("deathsight", { type = "general",
    def = "Your mind has been touched by Thoth, the Lord of Death.",
    on = {"Your mind is already touched by the Deathgod.", "You shut your eyes and concentrate on Thoth, the God of Death. A moment later, you feel inextricably linked with Death itself.", "A miasma of darkness passes over your eyes and you feel a link to Thoth, the God of Death, form in your mind."},
    off = {"You relax your link with the realm of Death.", "You are not linked with the realm of Death."}})
  defs_data:set("mindseye", { type = "general",
    on = {"Touching the mindseye tattoo, your senses are suddenly heightened.", "You already possess the mindseye defence."},
    def = "Your senses are magically heightened."})
  defs_data:set("lyre", { type = "general",
    specialskip = function() return not conf.lyre end,
    onenable = function (mode, newdef, whereto, echoback)
      if svo["def"..whereto][mode].meditate then
        svo["def"..whereto][mode].meditate = false
        if echoback then echof("Removed meditate from %s, it's incompatible with %s to have simultaneously up.", whereto, newdef) end
      end
      if svo["def"..whereto][mode].breath then
        svo["def"..whereto][mode].breath = false
        if echoback then echof("Removed breath from %s, it's incompatible with %s to have simultaneously up.", whereto, newdef) end
      end

      return true
    end,
    on = {"You strum a Lasallian lyre, and a prismatic barrier forms around you.", "You deftly shape the wall of light into a barrier surrounding yourself.", "You strum a darkly glowing mandolin, and a prismatic barrier forms around you.", "You strum a glittering lyre of ice, and a prismatic barrier forms around you."},
    def = "You are standing within a prismatic barrier.",
    off = {"Your prismatic barrier dissolves into nothing.", "The stream hits your prismatic barrier, shattering it.", "The breath weapon rips apart your prismatic barrier.", "The breath weapon rips through both your shield and prismatic barrier.", "The spear shatters your prismatic barrier."}})
  defs_data:set("speed", { type = "general",
    def = "Your sense of time is heightened, and your reactions are speeded."})
  defs_data:set("frost", { type = "general", def = "You are tempered against fire damage.",
    on = "A chill runs over your icy skin.",
    off = "Forks of flame lick against your skin, melting away your protection against fire."})
  defs_data:set("venom", { type = "general", def = "Your resistance to damage by poison has been increased.",
    on = "You feel a momentary dizziness as your resistance to damage by poison increases."})
  defs_data:set("levitation", { type = "general", def = "You are walking on a small cushion of air.",
    on = {"Your body begins to feel lighter and you feel that you are floating slightly.", "Your body grows light and buoyant as you touch the feather tattoo, and you begin hovering above the ground."}})
  defs_data:set("caloric", { type = "general",
    def = "You are coated in an insulating unguent."})
  defs_data:set("sileris", { type = "general",
    def = "You are protected from the fangs of serpents."})
  defs_data:set("chargeshield", { nodef = true,
    def = "You are surrounded by a non-conducting chargeshield."})
  defs_data:set("meditate", { type = "general",
    onenable = function (mode, newdef, whereto, echoback)
      if svo["def"..whereto][mode].breath then
        svo["def"..whereto][mode].breath = false
        if echoback then echof("Removed breath from %s, it's incompatible with %s to have simultaneously up.", whereto, newdef) end
      end

      return true
    end,
    on = "You close your eyes, bow your head, and empty your mind of all thought.",
    off = {"You snap your head up as you break your meditation.", "You cease your meditation having achieved full will and mana."}})
  defs_data:set("shield", { type = "general",
    on = {"You touch the tattoo and a nearly invisible magical shield forms around you.", "You bid your guardian angel to raise an aura to shield you."},
    onr = [[^(\w+)'s angel surrounds you with a protective shield\.$]],
    off = {"Your movement causes your magical shield to dissipate.", "The breath weapon rips through your shield.", "The point of the weapon comes to a sudden stop as its tip impacts your magical shield. Originating at the point of impact, fractures spread across the barrier before it shatters.", "Your action causes the nearly invisible magical shield around you to fade away.", "The stream hits your magical shield, shattering it.", "The spout of molten lava surges against your shield, which shatters under the intense force and heat.", "Your defensive barriers disappear.", "A glowing spear comes flying in towards you. The spear shatters your shield.", "The breath weapon rips through both your shield and prismatic barrier.", "With a mad cackle, a gremlin leaps at you and batters your shield with a flurry of blows, fracturing it in moments.", "A dissonant tone shatters the magical shield surrounding you."},
    offr = {[[^\w+ razes your magical shield with ]],
        [[^A massive, translucent hammer rises out of .+'s tattoo and smashes your magical shield\.]],
        [[^\w+'s cantata shatters your magical shield\.$]],
        [[^The meteor, shot by \w+, slams into your shield, shattering it\.$]],
        [[^\w+ flays away your shield defence\.$]],
        [[^\w+ sends myriad russet streams towards you, shattering your shield\.$]],
        [[^\w+'s cantata shatters the defences surrounding you\.$]],
        [[^\w+'s many heads lash out around you, shattering your protective shield\.$]],
        [[^\w+ delivers a single, powerful blow to the magical shield surrounding you, shattering it\.$]],
        [[^\w+ continues (?:his|her) assault, coming around for a second blow that scythes straight through your magical shield\.$]],
        [[^\w+ brings .+? down in a single diagonal stroke, carving cleanly through your magical shield\.$]],
        [[^\w+ continues (?:his|his) attack, coming back around with a bone rattling blow with .+? that causes your magical shield to explode in a shower of twinkling shards\.$]],
        [[^\w+ whirls .+ over (?:her|his) head, before bringing it down upon your magical shield, shattering it instantly\.$]],
        [[^\w+ summons a blade of condensed air and shears cleanly through the magical shield surrounding you\.$]],
    },
    def = "You are surrounded by a nearly invisible magical shield."})
  defs_data:set("riding", { type = "general",
    specialskip = function() return defc.dragonform end,
    ondef = function ()
      if tostring(conf.ridingsteed) and tostring(conf.ridingsteed):match("([A-Za-z]+)") and string.find(matches[2], tostring(conf.ridingsteed):match("([A-Za-z]+)"), nil, true) then
        return "("..tostring(conf.ridingsteed):match("([A-Za-z]+)")..")"
      else
        return "("..matches[2]..")"
      end
    end,
    defr = [[^You are riding (.+)\.$]],
    onr = {[[^You climb up on .+\.$]], [[^You easily vault onto the back of .+\.$]]},
    on = {"You step aboard the chariot and firmly grasp the reins."},
    offr = {[[^You step down off of .+\.$]], [[^You lose purchase on .+\.$]], [[^\w+ waves (?:his|her) palm in your direction, and you can only watch as your surroundings dissolve and fade from existence\.$]], [[^You feel your blessed soul drawn toward \w+ as you are delivered out of harm's way\.$]], [[^\w+ steps into the attack, grabs your arm, and throws you violently to the ground\.$]]},
    off = {"You are not currently riding anything.", "You are not currently riding that.", "You must be mounted to trample.", "You are thrown from the room by the sheer force of the fiery blast.", "You're drawn screaming into its hellish maw.", "The ring of shining metal carries you up into the skies.", "You clamber off of your mount.",
          "You call upon your dark power, and instantly a black wind descends upon you. In seconds your body begins to dissipate, and you are one with the odious vapour.",
    }})

  defs_data:set("grove vigour", { nodef = true,
    def = "You are bathed in an aura of radiant sunlight."})

-- Dragoncraft: everyone gets it
  defs_data:set("dragonform", { type = "dragoncraft",
    offline_defence = true,
    invisibledef = true,
    stays_on_death = true,
    on = "You already maintain the form of the Dragon.",
    off = "Your draconic form melts away, leaving you suddenly weaker and more vulnerable." })
  defs_data:set("dragonarmour", { type = "dragoncraft",
    specialskip = function() return not defc.dragonform end,
    def = "You are surrounded by draconic armour.",
    off = "You relax your draconic armour.",
    on = {"With a low rumbling from deep within your belly, you beseech Ashaxei for protection. Your skin ripples as a web of crackling magical energy dances like fire across its surface, settling to solidify into a flexible, translucent shell.", "You are already surrounded by draconic armour, Wyrm."}})
  defs_data:set("dragonbreath", { type = "dragoncraft",
    specialskip = function() return not defc.dragonform end,
    def = "You have summoned your draconic breath weapon.",
    off = {"You have not summoned your breath weapon.", "As the strain on your inflated lungs reaches extremity, you open your glistening, tooth-lined maw wide and rain a great tempest of venom down upon the ground below."},
    offr = {[[^As the strain on your inflated lungs reaches extremity, you open your glistening, tooth-lined maw wide and rain .+]], [[^Focusing your breath into a concentrated stream, you direct a blast of]], [[^Opening your great maw, you unleash an overpowering blast of flesh-searing lightning at .+, whose body goes rigid as s?he screams in agony\.$]], [[^Opening your dragon's mouth to its fullest, you blast .+ with your toxic wrath, damaging (?:her|his) very essence\.$]], [[^Opening your massive maw, you throw your head forward and blast wave after wave of deadly, all-consuming cold at .+\.$]], [[^Opening your maw, you force out a tremendous stream of acid, blasting the flesh from the very bones of .+\.$]], [[^Drawing a mighty breath to fill your lungs, you crane your neck backwards and send a screaming volley of \w+-infused vapour into the air\.$]], [[^You rear back your head, and with a keening roar unleash incandescent hell upon]], [[^With a roar of triumph, you unleash a cataclysm of crushing psi energy, laying waste to .+'s mind\.]], [[^Summoning a torpid cloud of \w+ deep within your belly, you expel your breath toward]] }})

  defs_data:set("deathsight", { type = "necromancy",
    staysindragon = true,
    availableindragon = true,
    def = "Your mind has been touched by Thoth, the Lord of Death.",
    off = {"You relax your link with the realm of Death.", "You are not linked with the realm of Death."},
    on = {"Your mind is already touched by the Deathgod.", "You shut your eyes and concentrate on Thoth, the God of Death. A moment later, you feel inextricably linked with Death itself.", "You already possess the deathsight.", "A miasma of darkness passes over your eyes and you feel a link to Thoth, the God of Death, form in your mind."}})
  defs_data:set("soulcage", { type = "necromancy",
    staysindragon = true,
    offline_defence = true,
    on = {"Your soul is already protected by the soulcage.", "You lower the barrier between your spirit and the soulcage.", "You begin to spin a web of necromantic power about your soul, drawing on your vast reserves of life essence. Moment by moment the bonds grow stronger, until your labours are complete. Your soul is entirely safe from harm, fortified in a cage of immortal power."},
    off = {"You have not caged your soul in life essence.", "You carefully raise a barrier between your spirit and the soulcage.", "As you feel the last remnants of strength ebb from your tormented body, you close your eyes and let darkness embrace you. Suddenly, you feel your consciousness wrenched from its pitiful mortal frame and your soul is free. You feel your form shifting, warping and changing as you whirl and spiral outward, ever outward. A jolt of sensation awakens you, and you open your eyes tentatively to find yourself trapped within a physical body once more."},
    onr = [[^You may not use soulcage for another \d+ Achaean day\(s\)\.$]],
    def = "Your being is protected by the soulcage."})
  defs_data:set("deathaura", { type = "necromancy",
    on = {"You let the blackness of your soul pour forth.", "You already possess an aura of death."},
    def = "You are emanating an aura of death.",
    off = "Your aura of death has worn off."})
  defs_data:set("shroud", { type = "necromancy",
    on = {"Calling on your dark power, you draw a thick shroud of concealment about yourself to cover your every action.", "You draw a Shadowcloak about you and blend into your surroundings."},
    def = "Your actions are cloaked in secrecy.",
    off = {"Your shroud dissipates and you return to the realm of perception.", "The flash of light illuminates you - you have been discovered!"}})
  defs_data:set("lifevision", { type = "necromancy",
    on = {"You narrow your eyes and blink rapidly, enhancing your vision to seek out sources of lifeforce in others.", "You already possess enhanced vision."},
    def = "You have enhanced your vision to be able to see traces of lifeforce."})
  defs_data:set("putrefaction", { type = "necromancy",
    on = {"You concentrate for a moment and your flesh begins to dissolve away, becoming slimy and wet.", "You have already melted your flesh. Why do it again?"},
    def = "You are bathed in the glorious protection of decaying flesh.",
    off = "You concentrate briefly and your flesh is once again solid."})
  defs_data:set("vengeance", { type = "necromancy",
    staysindragon = true,
    offline_defence = true,
    on = {"You swear to yourself that you will wreak vengeance on your slayer.", "Vengeance already burns within your heart, Necromancer."},
    def = "You have sworn vengeance upon those who would slay you.",
    off = {"You forswear your previous oath for vengeance, sudden forgiveness entering your heart.", "You have sworn vengeance against none, Necromancer."}})


  defs_data:set("truestare", { type = "evileye",
    on = {"A sharp pain spikes through your skull, before settling into a dull throbbing just behind your eyes.", "You are already enhancing your ocular prowess. Lost: Your truestare defence erodes away."},
    def = "You are enhancing your ocular prowess."})
















  defs_data:set("armour", {
    type = "apostasy",
    stays_on_death = true,
    on = {"You already are surrounded by unholy armour.", "You ask your Baalzadeen for its protection, and it summons a thin black protecting sheen over you."},
    def = "Your person is surrounded by black demonic armour."})
  defs_data:set("syphon", {
    type = "apostasy",
    invisibledef = true,
    on = {"Your Baalzadeen begins to shimmer with a demonic red light.", "Your Baalzadeen is already syphoning your diseases."}})
  defs_data:set("mask", {
    type = "apostasy",
    invisibledef = true,
    stays_on_death = true,
    on = {"You wrap your Baalzadeen in a mask of impenetrable obscurity.", "Your Baalzadeen is already masked."}})
  defs_data:set("daegger", {
    type = "apostasy",
    invisibledef = true,
    on = {"You call upon the Lords of Hell to bestow the living weapon, the daegger, unto you.", "Your daegger comes racing towards you, stopping unnaturally quickly to land in your grasp."}})
  defs_data:set("pentagram", {
    type = "apostasy",
    on = {"Using your daegger, you open a vein in your wrist, and let the blood drip to outline a pentagram, floating waist-high.", "There is already a pentagram here."}
  })
  defs_data:set("baalzadeen", {
    type = "apostasy",
    off = "You must be leading your Baalzadeen.",
    on = {"Imposing your will on Hell itself, you summon forth a Baalzadeen to serve your whim.", "You call out, ordering your Baalzadeen to return to serve your whim."},
    invisibledef = true,
    stays_on_death = true,
  })















do
  function defences.enablelifevision()
    if dict.lifevision then return end

    defs_data:set("lifevision", { type = "general",
      on = {"You narrow your eyes and blink rapidly, enhancing your vision to seek out sources of lifeforce in others.", "You already possess enhanced vision."},
      def = "You have enhanced your vision to be able to see traces of lifeforce."})

    dict.lifevision = {
      physical = {
        name = "lifevision_physical",
        balance = "physical",
        action_name = "lifevision",
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,

        isadvisable = function ()
          return (not defc.lifevision and ((sys.deffing and defdefup[defs.mode].lifevision) or (conf.keepup and defkeepup[defs.mode].lifevision)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("lifevision")
        end,

        action = "lifevision",
        onstart = function ()
          send("lifevision", conf.commandecho)
        end
      }
    }

    for mode,modet in pairs(defdefup) do
      defdefup[mode].lifevision = defdefup[mode].lifevision or false
      defkeepup[mode].lifevision = defkeepup[mode].lifevision or false
    end

    sk.ignored_defences.general.t.lifevision = sk.ignored_defences.general.t.lifevision or false
    sk.ignored_defences_map["lifevision"] = "general"

    defences.def_types["general"][#defences.def_types["general"]+1] = "lifevision"

    local v = defs_data.lifevision;
    local k = "lifevision";
    if v.on and type(v.on) == "table" then
      for n,m in ipairs(v.on) do
        (tempExactMatchTrigger or tempTrigger)(m, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
      end
    elseif v.on then
      (tempExactMatchTrigger or tempTrigger)(v.on, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
    end

    (tempExactMatchTrigger or tempTrigger)(v.def, 'svo.defs.def_' .. sk.sanitize(k) .. '()');

    defs["def_"..sk.sanitize(k)] = function ()
      if not v.ondef then
        defences.def_def_list[k] = true
      else
        defences.def_def_list[k] = v.ondef()
      end
      deleteLine()
    end
    defs["got_" .. k] = function ()
      defences.got(k)
    end
    defs["lost_" .. k] = function ()
      defences.lost(k)
    end

    -- create a snapshot of the before state for all balances, since dict_setup might mess with any
    local beforestate = sk.getbeforestateprios()

    dict_setup()
    dict_validate()

    -- notify any prio diffs
    local afterstate = sk.getafterstateprios()
    sk.notifypriodiffs(beforestate, afterstate)

    signals.dragonform:emit()

    echof("Have lifevision mask - enabled it for defup/keepup.")
  end

  function defences.checklifevision()
    local t = _G.gmcp.Char.Items.List
    if not t.location == "inv" then return end

    -- feh! Easier to hardcode it for such a miniscule amount of items.
    -- If list enlarges, fix appopriately.
    for _, it in pairs(t.items) do
      -- if it.name == "a Veil of the Sphinx" then
      if it.name == "a mask of lifevision" or it.name == "a painted basilisk mask" or it.name == "a silver mask with gold reliefs" then
        defences.enablelifevision()
        conf.havelifevision = true
        raiseEvent("svo config changed", "havelifevision")
        signals.gmcpcharitemslist:disconnect(defences.checklifevision)
      end
    end

  end
  signals.systemstart:connect(function()
    tempTimer(0, function()
      if conf.havelifevision then
        defences.enablelifevision()
        signals.gmcpcharitemslist:disconnect(defences.checklifevision)
      end
    end)
  end)
  signals.gmcpcharitemslist:connect(defences.checklifevision)
end

do
  function defences.enableshroud()
    if dict.shroud then return end

    defs_data:set("shroud", { type = "general",
      on = {"You draw your Shadowcloak about you and blend into your surroundings.", "You draw a Shadowcloak about you and blend into your surroundings."},
      def = "Your actions are cloaked in secrecy.",
      off = {"Your shroud dissipates and you return to the realm of perception.", "The flash of light illuminates you - you have been discovered!"}})

    dict.shroud = {
      physical = {
        name = "shroud_physical",
        balance = "physical",
        action_name = "shroud",
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,

        isadvisable = function ()
          return (not defc.shroud and ((sys.deffing and defdefup[defs.mode].shroud) or (conf.keepup and defkeepup[defs.mode].shroud)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got("shroud")
        end,

        action = "shroud",
        onstart = function ()
          send("shroud", conf.commandecho)
        end
      }
    }

    for mode,modet in pairs(defdefup) do
      defdefup[mode].shroud = defdefup[mode].shroud or false
      defkeepup[mode].shroud = defkeepup[mode].shroud or false
    end

    sk.ignored_defences.general.t.shroud = sk.ignored_defences.general.t.shroud or false
    sk.ignored_defences_map["shroud"] = "general"

    defences.def_types["general"][#defences.def_types["general"]+1] = "shroud"

    local v = defs_data.shroud;
    local k = "shroud";
    -- FIXME not to be such a hack!
    (tempExactMatchTrigger or tempTrigger)(v.on[1], 'svo.defs.got_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.on[2], 'svo.defs.got_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.def, 'svo.defs.def_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.off[1], 'svo.defs.lost_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.off[2], 'svo.defs.lost_' .. sk.sanitize(k) .. '()');

    defs["def_"..sk.sanitize(k)] = function ()
      if not v.ondef then
        defences.def_def_list[k] = true
      else
        defences.def_def_list[k] = v.ondef()
      end
      deleteLine()
    end
    defs["got_" .. k] = function ()
      defences.got(k)
    end
    defs["lost_" .. k] = function ()
      defences.lost(k)
    end

    -- create a snapshot of the before state for all balances, since dict_setup might mess with any
    local beforestate = sk.getbeforestateprios()

    dict_setup()
    dict_validate()

    -- notify any prio diffs
    local afterstate = sk.getafterstateprios()
    sk.notifypriodiffs(beforestate, afterstate)

    signals.dragonform:emit()

    echofn("Have Shadowcloak - enabled it for defup/keepup (")
    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("disable", [[svo.conf.haveshroud = nil; svo.echof("Alright - won't add shroud to defup/keepup next time.") raiseEvent("svo config changed", "haveshroud")]], 'Click to disable shroud from getting added to defup/keepup next time', true)
    setUnderline(false)
    echo(")\n")
  end

  function defences.checkshroud()
    local t = _G.gmcp.Char.Items.List
    if not t.location == "inv" then return end

    for _, it in pairs(t.items) do
      if it.name:find("Shadowcloak", 1, true) then
        defences.enableshroud()
        conf.haveshroud = true
        raiseEvent("svo config changed", "haveshroud")
        signals.gmcpcharitemslist:disconnect(defences.checkshroud)
      end
    end

  end
  signals.systemstart:connect(function()
    tempTimer(0, function()
      if conf.haveshroud then
        defences.enableshroud()
        signals.gmcpcharitemslist:disconnect(defences.checkshroud)
      end
    end)
  end)
  signals.gmcpcharitemslist:connect(defences.checkshroud)
end

-- check for both shadowcloak and mask of lifevision
function detect_lifevision()
  sendGMCP("Char.Items.Inv")
  send("")
end

-- TODO: add a validator to make sure all defs have a type

-- quick debug validation
--~ for def, deft in defs_data:iter() do
  --~ if not deft.on and not deft.onr and not deft.nodef then
    --~ echo(def..", ")
  --~ end
--~ end

defences.urlify = function (self)
  local t = string.split(self, " ")
  for i = 1, #t do
    t[i] = string.title(t[i])
  end

  return table.concat(t, "_")
end


defences.complete_def = function(tbl)
  local name, def, defr, tooltip = tbl.name, tbl.def, tbl.defr, tbl.tooltip
  local name = name:lower()

  if not defs_data[name] then return end

  defs_data[name].def = def or defs_data[name].def
  defs_data[name].defr = defr or defs_data[name].defr
  defs_data[name].tooltip = tooltip
end

sk.showwaitingdefup = function()
  return concatand(select(2, sk.have_defup_defs()))
end

-- def setup & def-related controllers

-- used in 'vshow' to get the list of available defences
defences.print_def_list = function ()
  local t = {}; for defmode, _ in pairs(defdefup) do t[#t+1] = defmode end
  table.sort(t)

  -- echo each def mode: defence (-),
  for i = 1, #t do
    local defmode = t[i]

    if defmode ~= defs.mode then
      setFgColor(unpack(getDefaultColorNums))
      setUnderline(true) echoLink(defmode, 'svo.defs.switch("'..defmode..'", true)', 'Switch to '..defmode..' defences mode', true) setUnderline(false)
    else
      fg"a_darkgreen"
      setUnderline(true) echoLink(defmode, 'svo.defs.switch("'..defmode..'", true)', 'Currently in this defence mode. Click to redo defup', true) setUnderline(false)
    end

    if sys.deffing and defmode == defs.mode then
      echo(" (currently deffing)")
    end

    echo" ("
    fg"orange_red"setUnderline(true) echoLink('-', 'svo.delete_defmode("'..defmode..'", true)', 'Delete '..defmode.. ' defences mode', true) setUnderline(false) setFgColor(unpack(getDefaultColorNums))
    echo", "
    fg"a_darkgreen" setUnderline(true) echoLink("c", 'printCmdLine("vcopy defmode '..defmode..' TO ")', "Copy "..defmode.." into a new or existing defence mode", true) setUnderline(false) setFgColor(unpack(getDefaultColorNums))
    echo")"

    if i == #t then echo " " else
      echo", "
    end
  end

  -- then an add the (+ add new), if we can
  if printCmdLine then
    echo("(")
    fg"a_darkgreen" setUnderline(true) echoLink("+ add new", 'printCmdLine("vcreate defmode ")', "Create a new defences mode", true) setUnderline(false) setFgColor(unpack(getDefaultColorNums))
    echo(")")
  end

  echo"\n"
end

defences.get_def_list = function ()
  local s = oneconcat(defdefup)

  if sys.deffing then
    s = string.gsub(s, "("..defs.mode..")", "(currently deffing) <0,250,0>%1" .. getDefaultColor())
  else
    s = string.gsub(s, "("..defs.mode..")", "<0,250,0>%1" .. getDefaultColor())
  end
  return s
end

-- nodefup is useful for relogging in, where you don't do defup, but you want keepup to be active
function defs.switch(which, echoback, nodefup)
  local sendf; if echoback then sendf = echof else sendf = errorf end

  if not which then
    sendf("To which mode do you want to switch to?") return
  end

  if not defdefup[which] then
    sendf("%s defence mode doesn't exist - the list is: %s", which, oneconcat(defdefup)) return
  end

  defs.mode = which

  if not nodefup and echoback then
    echof("Deffing up in %s defence mode.", defs.mode)
  end

  rift.precache = rift.precachedata[defs.mode]
  if not nodefup then sys.deffing = true end
  sk.fix_affs_and_defs()
  startStopWatch(defences.defup_timer)

  raiseEvent("svo switched defence mode", defs.mode)
  if not nodefup then raiseEvent("svo started defup", defs.mode) end

  make_gnomes_work()
  if not nodefup then defupfinish() end
end

function defs.quietswitch(which, echoback)
  local sendf; if echoback then sendf = echof else sendf = errorf end

  if not which then
    sendf("To which mode do you want to switch to?") return
  end

  if not defdefup[which] then
    sendf("%s defence mode doesn't exist - the list is: %s", which, oneconcat(defdefup)) return
  end

  defs.mode = which

  if echoback then
    echof("Deffing up in %s defence mode.", defs.mode)
  end

  rift.precache = rift.precachedata[defs.mode]
  sk.fix_affs_and_defs()
end

defupfinish = function ()
  if not sys.deffing then return end

  -- serverside doesn't support defup and Svof doesn't emulate it at the moment
  if sk.have_defup_defs() then
    sys.deffing = false
    local time = stopStopWatch(defences.defup_timer)
    local timestring

    if time > 60 then
      timestring = string.format("%dm, %.1fs", math.floor(time/60), time%60)
    else
      timestring = string.format("%.1fs", time)
    end

    echo"\n"
    echof("Ready for combat! (%s defences mode, took %s)", defs.mode, (timestring == "0.0s" and "no time" or timestring))
    raiseEvent("svo done defup", defs.mode)
    signals.donedefup:emit()
    showprompt()
  end
end

defupcancel = function(echoback)
  if sys.deffing then
    sys.deffing = false
    if echoback then echof("Cancelled defup.") end
  else
    if echoback then echof("Weren't doing defup already.") end
  end

  stopStopWatch(defences.defup_timer)
end

function defs.keepup(which, status, mode, echoback, reshow)
  local sendf; if echoback then sendf = echof else sendf = sendf end

  if not mode then mode = defs.mode end

  if not mode then
    sendf("We aren't in any defence mode yet - switch to one first.")
    return
  end

  if defkeepup[mode][which] == nil then
    sendf("Don't know about a %s defence.", which)
    return
  end

  -- if we were given an explicit option...
  if type(status) == "string" then
    status = convert_string(status)
  end

  -- if it's invalid or wasn't given to us, toggle
  if status == nil then
    if defkeepup[mode][which] then status = false
    else status = true end
  end

  if status == true and defs_data[which].onenable then
    local s,m = defs_data[which].onenable(mode, which, "keepup", echoback)
    if not s then echof(m) return end
  end

  defkeepup[mode][which] = status
  raiseEvent("svo keepup changed", mode, which, status)

  if echoback then
    if defkeepup[mode][which] then
      echof("Will keep %s up%s.", which, (ignore[which] and ' (however it\'s on ignore right now)' or ''))
    else
      echof("Won't keep %s up anymore.", which)
    end

    if sys.deffing then
      echof("You're still in defup however, and keepup is after defup. Still waiting on: %s to be put up.", sk.showwaitingdefup())
    elseif not conf.keepup and status == true then
      echof("Keepup needs to be on, though.")
    end
  end

  sk.fix_affs_and_defs()
  make_gnomes_work()

  if reshow then show_keepup() echo"\n" end
end

function defs.defup(which, status, mode, echoback, reshow)
  local sendf; if echoback then sendf = echof else sendf = errorf end

  if not mode then mode = defs.mode end

  if not mode then
    sendf("We aren't in any defence mode yet - switch to one first.")
    return
  end

  if defdefup[mode][which] == nil then
    sendf("Don't know about a %s defence.", which)
    return
  end

  -- if we were given an explicit option...
  if type(status) == "string" then
    status = convert_string(status)
  end

  -- if it's invalid or wasn't given to us, toggle
  if status == nil then
    if defdefup[mode][which] then status = false
    else status = true end
  end

  if status == true and defs_data[which].onenable then
    local s,m = defs_data[which].onenable(mode, which, "defup", echoback)
    if not s then echof(m) return end
  end

  defdefup[mode][which] = status
  raiseEvent("svo defup changed", mode, which, status)

  if echoback then
    if defdefup[mode][which] then
      echof("Will put %s up in %s mode.", which, mode)
    else
      echof("Won't put %s up anymore in %s mode.", which, mode)
    end
  end

  if reshow then show_defup() echo"\n" end

  sk.fix_affs_and_defs()
  make_gnomes_work()
end


function create_defmode(which, echoback)
  local sendf; if echoback then sendf = echof end

  assert(which, "Which defences mode do you want to create?", sendf)
  assert(not (defdefup[which] and defkeepup[which]), which .. " defences mode already exists.", sendf)

  defdefup[which] = {}
  defkeepup[which] = {}

  for k,v in defs_data:iter() do
    defdefup[which][k] = false
    defkeepup[which][k] = false
  end

  rift.precachedata[which] = {}
  for _,herb in pairs(rift.herbsminerals) do
    rift.precachedata[which][herb] = 0
  end

  if echoback then
    sendf("Defences mode created. You may now do vdefs %s!", which)
    printCmdLine("vdefs "..which)
  end
end

function copy_defmode(which, newname, echoback)
  local sendf; if echoback then sendf = echof end

  assert(which, "Which defences mode do you want to copy?", sendf)
  assert(defdefup[which] and defkeepup[which], which .. " defences mode doesn't exist.", sendf)
  assert(newname, "To which name do you want to rename " .. which .. " to?", sendf)

  defdefup[newname] = deepcopy(defdefup[which])
  defkeepup[newname] = deepcopy(defkeepup[which])
  rift.precachedata[newname] = deepcopy(rift.precachedata[which])
  if echoback then echof("Copied %s to %s.", which, newname) end
end

function rename_defmode(which, newmode, echoback)
  local sendf; if echoback then sendf = echof end

  assert(which, "Which defences mode do you want to rename?", sendf)
  assert(defdefup[which] and defkeepup[which], which .. " defences mode doesn't exist.", sendf)
  assert(newmode, "To which name do you want to rename " .. which .. " to?", sendf)

  if defs.mode == which then
    defs.mode = newmode
    if echoback then
      echof("Changed your current defence mode to %s", defs.mode)
    end
  end

  defdefup[newmode], defdefup[which] = defdefup[which], defdefup[newmode]
  defkeepup[newmode], defkeepup[which] = defkeepup[which], defkeepup[newmode]
  rift.precachedata[which], rift.precachedata[newmode] = rift.precachedata[newname], rift.precachedata[which]
  if echoback then echof("Renamed %s to %s.", which, newmode) end
end

function delete_defmode(which, echoback)
  local sendf; if echoback then sendf = echof end

  assert(which, "Which defences mode do you want to delete?", sendf)
  assert(defdefup[which] and defkeepup[which], which .. " defences mode doesn't exist.", sendf)
  assert(which ~= defs.mode, "You're currently in " .. which .. " defmode already - switch to another one first, and then delete this one.", sendf)

  defdefup[which], defkeepup[which], rift.precachedata[which] = nil, nil, nil

  if math.random(1, 10) == 1 then
    echof("Deleted '%s' defences mode.", which)
  else
    echof("Deleted '%s' defences mode. Forever!", which) end
end



function defload()
  local defdefup_t, defkeepup_t = {}, {}
  local defup_path, keepup_path = getMudletHomeDir() .. "/svo/defup+keepup/defup", getMudletHomeDir() .. "/svo/defup+keepup/keepup"

  if lfs.attributes(defup_path) then table.load(defup_path, defdefup_t) end
  if lfs.attributes(keepup_path) then table.load(keepup_path, defkeepup_t) end
  if lfs.attributes(getMudletHomeDir() .."/svo/defup+keepup/ignored_defences") then table.load(getMudletHomeDir() .."/svo/defup+keepup/ignored_defences", sk.ignored_defences) end

  if lfs.attributes(getMudletHomeDir() .."/svo/defup+keepup/offline_defences") then
    local t = {}
    table.load(getMudletHomeDir() .."/svo/defup+keepup/offline_defences", t)

    for i = 1, #t do
      defences.got(t[i])
    end

    signals.dragonform:emit()
  end

  return defdefup_t, defkeepup_t
end

signals.relogin:connect(function()
  -- reset defs at login
  local t = {}
  for def in pairs(defc) do
    if def ~= "dragonform" then
      t[#t+1] = defc
    end
  end

  for i = 1, #t do
    defences.lost(t[i])
  end
end)

-- re-set defences mode to basic upon qqing and relogging in without closing Mudlet
function sk.loginonbasic()
  -- defs.mode = "" -- small hack to have the defup start event be raised when logging in for the first time, can't have the value on "" to begin with because the mode is always expected to be valid
  defs.switch("basic", true, true)

  -- disable initial connect and only use relogin after the first time
  signals.charname:disconnect(sk.loginonbasic)
  signals.gmcpcharname:disconnect(sk.loginonbasic)
end
signals.relogin:connect(sk.loginonbasic)
signals.charname:connect(sk.loginonbasic)
signals.gmcpcharname:connect(sk.loginonbasic)

signals.saveconfig:connect(function ()
  table.save(getMudletHomeDir() .. "/svo/defup+keepup/defup", defdefup)
  table.save(getMudletHomeDir() .. "/svo/defup+keepup/keepup", defkeepup)
  table.save(getMudletHomeDir() .. "/svo/defup+keepup/ignored_defences", sk.ignored_defences)

  local t = {}
  for k,v in defs_data:iter() do if v.offline_defence and defc[k] then t[#t+1] = k end end
  table.save(getMudletHomeDir() .. "/svo/defup+keepup/offline_defences", t)
end)

function sk.sanitize(self)
  return string.gsub(self, " ", "_")
end

function sk.desanitize(self)
  return string.gsub(self, "_", " ")
end

signals.systemstart:connect(function ()
  local defdefup_t, defkeepup_t = {}, {}
  defdefup_t, defkeepup_t = defload()

  -- create blank defup modes
  for k,v in pairs(defdefup_t) do
    defdefup[k] = defdefup[k] or {}
    defkeepup[k] = defkeepup[k] or {}
  end


  for k,v in defs_data:iter() do
    -- sort into def types if applicable
    if v.custom_def_type then
      defences.custom_types[v.custom_def_type] = defences.custom_types[v.custom_def_type] or {}
      defences.custom_types[v.custom_def_type][k] = true
    end

    if v.onr and type(v.onr) == "table" then
      for n,m in ipairs(v.onr) do
        tempRegexTrigger(m, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
      end
    elseif v.onr then
      tempRegexTrigger(v.onr, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
    end

    if v.on and type(v.on) == "table" then
      for n,m in ipairs(v.on) do
        (tempExactMatchTrigger or tempTrigger)(m, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
      end
    elseif v.on then
      (tempExactMatchTrigger or tempTrigger)(v.on, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
    end

    if v.on_only and type(v.on_only) == "table" then
      for n,m in ipairs(v.on_only) do
        (tempExactMatchTrigger or tempTrigger)(m, 'svo.defs.gotonly_' .. sk.sanitize(k) .. '()')
      end
    elseif v.on_only then
      (tempExactMatchTrigger or tempTrigger)(v.on_only, 'svo.defs.gotonly_' .. sk.sanitize(k) .. '()')
    end

    if v.on_free then (tempExactMatchTrigger or tempTrigger)(v.on_free, 'svo.defs.got_' .. sk.sanitize(k) .. '()') end

    if v.offr and type(v.offr) == "string" then
        tempRegexTrigger(v.offr, 'svo.defs.lost_' .. sk.sanitize(k) .. '()')
    elseif v.offr then
      for n,m in ipairs(v.offr) do
        tempRegexTrigger(m, 'svo.defs.lost_' .. sk.sanitize(k) .. '()')
      end
    end

    if v.off and type(v.off) == "string" then
        (tempExactMatchTrigger or tempTrigger)(v.off, 'svo.defs.lost_' .. sk.sanitize(k) .. '()')
    elseif v.off then
      for n,m in ipairs(v.off) do
        (tempExactMatchTrigger or tempTrigger)(m, 'svo.defs.lost_' .. sk.sanitize(k) .. '()')
      end
    end

    -- this is EXACTLY for substring
    if v.offs and type(v.offs) == "string" then
        tempTrigger(v.offs, 'svo.defs.lost_' .. sk.sanitize(k) .. '()')
    elseif v.offs then
      for n,m in ipairs(v.offs) do
        tempTrigger(m, 'svo.defs.lost_' .. sk.sanitize(k) .. '()')
      end
    end

    if v.off_free then (tempExactMatchTrigger or tempTrigger)(v.off_free, 'svo.defs.lost_' .. sk.sanitize(k) .. '()') end

    if v.def and type(v.def) == "table" then
      for n,m in ipairs(v.def) do
        (tempExactMatchTrigger or tempTrigger)(m, 'svo.defs.def_' .. sk.sanitize(k) .. '()')
      end
    elseif v.def then
      (tempExactMatchTrigger or tempTrigger)(v.def, 'svo.defs.def_' .. sk.sanitize(k) .. '()')
    end

    if v.defr and type(v.defr) == "table" then
      for n,m in ipairs(v.defr) do
        tempRegexTrigger(m, 'svo.defs.def_' .. sk.sanitize(k) .. '()')
      end
    elseif v.defr then
      tempRegexTrigger(v.defr, 'svo.defs.def_' .. sk.sanitize(k) .. '()')
    end

    if not defs["got_" .. k] then
      if dict[k] then
        -- rely on the fact that defs only have 1 item in them
        local bal
        for kk,vv in pairs(dict[k]) do if type(vv) == "table" and kk ~= "gone" then bal = kk break end end
        if bal then
          defs["got_" .. k] = function ()
            if not v.custom_def_type then checkaction(dict[k][bal]) else checkaction(dict[k][bal], true) end
            if actions[k .. "_" .. bal] then
              lifevision.add(actions[k .. "_" .. bal].p)
            end
          end
        end
      end

      if not defs["got_" .. k] then
        defs["got_" .. k] = function ()
          defences.got(k)
        end
      end
    end

    if v.on_only and not defs["gotonly_" .. k] then
      if dict[k] then
        -- rely on the fact that defs only have 1 item in them
        local bal
        for kk,vv in pairs(dict[k]) do
          if type(vv) == "table" and kk ~= "gone" then bal = kk break end
        end
        defs["gotonly_" .. k] = function ()
          checkaction(dict[k][bal], false)
          if actions[k .. "_" .. bal] then
            lifevision.add(actions[k .. "_" .. bal].p)
          end
        end
      else
        defs["gotonly_" .. k] = function ()
          defences.got(k)
        end
      end
    end

    if not defs["lost_" .. sk.sanitize(k)] then
      if dict[k] and dict[k].gone then
        defs["lost_" .. k] = function ()
          checkaction(dict[k].gone, true)
          if actions[k .. "_gone"] then
            lifevision.add(actions[k .. "_gone"].p)
          end
        end
      else
        defs["lost_" .. k] = function ()
          defences.lost(k)
        end
      end
    end

    if not v.nodef and not v.custom_def_type then
      defs["def_"..sk.sanitize(k)] = function ()

        -- if we're in dragonform and this isn't a general or a dragoncraft def, then remember it as an additional def - not a class skill one, since those are not shown in Dragon
        if defc.dragonform and v.type ~= "general" and v.type ~= "dragoncraft" then
          if not v.ondef then
            defences.nodef_list[k] = true
          else
            defences.nodef_list[k] = v.ondef()
          end
        else
          if not v.ondef then
            defences.def_def_list[k] = true
          else
            defences.def_def_list[k] = v.ondef()
          end
        end
        deleteLine()
      end
    elseif not v.nodef and v.custom_def_type then
      defs["def_"..sk.sanitize(k)] = function ()
        defences.got(k)
      end

    -- additional defence (nodef)
    else
      defs["def_"..sk.sanitize(k)] = function ()
      -- only accept the def line if we know that we're parsing the def list currently, so lines similar to ones on the DEFENCES list that show up elsewhere don't mess things up
        if not actions.defcheck_physical then return end

        deleteLine()
        if not v.ondef then
          defences.nodef_list[k] = true
        else
          defences.nodef_list[k] = v.ondef()
        end
      end
    end

    -- fill up our defences.def_types
    if v.type then
      defences.def_types[v.type] = defences.def_types[v.type] or {}
      defences.def_types[v.type][#defences.def_types[v.type]+1] = k
    end

    -- create blanks for defup and keepup
    if not v.nodef then
      for mode,modet in pairs(defdefup) do
        defdefup[mode][k] = false
        defkeepup[mode][k] = false
      end
    end


    if v.type then
      sk.ignored_defences[v.type] = sk.ignored_defences[v.type] or {status = false, t = {}}
      sk.ignored_defences[v.type].t[k] = sk.ignored_defences[v.type].t[k] or false
      sk.ignored_defences_map[k] = v.type
    end
  end

  update(defdefup, defdefup_t)
  update(defkeepup, defkeepup_t)

  -- remove skillsets from ignorelist that we don't have, for people that change
  for skillset, _ in pairs(sk.ignored_defences) do
    if skillset ~= "general" and skillset ~= "enchantment" and skillset ~= "dragoncraft" and not me.skills[skillset] then
      sk.ignored_defences[skillset] = nil
    end
  end


  -- simple way of removing all and adding per line
  for name, data in pairs(defences.custom_types) do
    defs["def"..name.."start"] = function()
      for def, _ in pairs(defences.custom_types[name]) do
        defences.lost(def)
      end
    end
  end
end)

-- customize for gag
defs["lost_shield"] = function ()
  checkaction(dict.shield.gone, true)
  if actions["shield_gone"] then
    lifevision.add(actions["shield_gone"].p)
  end

  -- local line = getCurrentLine()
  -- selectCurrentLine() replace''
  -- cecho(string.format("<DarkOrange>><red>> <white:sienna>%s<:black> <red><<DarkOrange><", line))
  if selectString(line, 1) ~= -1 then
    replace("")
    cecho(string.format("<DarkOrange>><red>> <white:sienna>%s<:black> <red><<DarkOrange><", line))
  end
end

-- customize for riding_physical
defs["lost_riding"] = function()
  -- force it so unwilling dismount is counted
  checkaction(dict.riding.physical, true)
  if actions["riding_physical"] then
    lifevision.add(actions["riding_physical"].p, "dismount")
  end
end

defs["block_failed"] = function()
  checkaction(dict.block.physical, true)
  if actions["block_physical"] then
    lifevision.add(actions["block_physical"].p, "failed")
  end
end

function defs.defprompt()
  show_current_defs()

  -- see if we need to show any additional defences
  local function check_additionals()
    for def, _ in defences.nodef_list:pairs() do
      if defs_data[def] and (defs_data[def].nodef or (defc.dragonform and defs_data[def].type ~= "dragoncraft" and defs_data[def].type ~= "general")) then return true end
    end
  end

  if check_additionals() then
    echof("Additional defences:")
    local count = 1
    for def, value in defences.nodef_list:pairs() do
      if defs_data[def] and (defs_data[def].nodef or (defc.dragonform and defs_data[def].type ~= "dragoncraft" and defs_data[def].type ~= "general")) then
        if value == true then
          decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", sk.desanitize(def)))
        else
          decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", sk.desanitize(def) .. " " .. tostring(value)))
        end

        if count % 3 == 0 then echo("\n") end
        count = count + 1
      end
    end
    count = 1 echo("\n")

  end
  defences.nodef_list = phpTable()
  defences.def_def_list = {}
  showprompt()
end

function defs.defstart()
  checkaction(dict.defcheck.physical)
  if actions.defcheck_physical then
    deleteLine()

    -- reset parry, as no parry won't show a line
    local t = sps.parry_currently
    for limb, _ in pairs(t) do t[limb] = false end
    check_sp_satisfied()
  end
end

-- last line of 'def' that shows your count
function defs.defline()
  checkaction(dict.defcheck.physical)
  if actions.defcheck_physical then
    deleteLine()
    tempLineTrigger(1, 1, 'selectString(line, 1) replace""')
    lifevision.add(actions.defcheck_physical.p)
  end
end

process_defs = function ()
  local addback = {}

  for defn, deft in pairs(defc) do
    -- clear ones we don't have
    if defc[defn] and not defences.def_def_list[defn] and not (defs_data[defn] and (defs_data[defn].invisibledef or defs_data[defn].custom_def_type)) then
      if dict[defn] and dict[defn].gone then
        checkaction(dict[defn].gone, true)
        lifevision.add(actions[defn.."_gone"].p)
      else
        defences.lost(defn)
      end
    elseif defc[defn] and defences.def_def_list[defn] and not (defs_data[defn] and defs_data[defn].custom_def_type) then -- if we do have it, remove from def list
      addback[defn] = defences.def_def_list[defn]
      defences.def_def_list[defn] = nil
    end
  end

  -- add left over ones
  for j,k in pairs(defences.def_def_list) do
    local bal
    for kk,vv in pairs(dict[j] or {}) do if type(vv) == "table" and kk ~= "gone" then bal = kk break end end
    if bal and dict[j][bal].oncompleted then
        dict[j][bal].oncompleted(true)
    else
      defences.got(j)
    end
  end

  for k,v in pairs(addback) do defences.def_def_list[k] = v end


  tempTimer(0, defs.defprompt)
end

-- prints out a def table
local function show_defs(tbl, linkcommand, cmdname)
  local count = 1

  local olddechoLink = dechoLink
  local function dechoLink(text, command, hint)
    olddechoLink(text, command, hint, true)
  end

  local function show_em(skillset, what)
    if skillset and not sk.ignored_defences[skillset].status then echof("%s defences:", skillset:title()) end
    for c,def in ipairs(what) do
      local disabled = ((sk.ignored_defences[skillset] and sk.ignored_defences[skillset].status) and true or (sk.ignored_defences[sk.ignored_defences_map[def]].t[def]))

      if not disabled and not tbl[def] and not defences.nodef_list[def] then
        if (count % 3) ~= 0 then
          if not linkcommand or not dechoLink then
            decho(string.format("<153,204,204>[ ] %-23s", def))
          else
            dechoLink(string.format("<153,204,204>[ ] %-23s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Add %s to %s", def, cmdname))
          end
        else
          if not linkcommand or not dechoLink then
            decho(string.format("<153,204,204>[ ] %s", def))
          else
            dechoLink(string.format("<153,204,204>[ ] %s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Add %s to %s", def, cmdname))
          end
        end
      elseif not disabled then
        if (count % 3) ~= 0 then
          if not defs_data[def].mana then
            if type(defences.nodef_list[def]) == "string" then
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def.." ("..defences.nodef_list[def]..")"))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def.." ("..defences.nodef_list[def]..")"), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif type(defences.def_def_list[def]) == "string" then
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def.." "..defences.def_def_list[def]))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def.." "..defences.def_def_list[def]), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif defs_data[def].onshow then
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def.." ("..defs_data[def].onshow()..")"))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def.." ("..defs_data[def].onshow()..")"), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
            else
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %-23s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
            end
          elseif defs_data[def].mana == "little" then
            if not linkcommand or not dechoLink then
              decho(string.format("<153,204,204>[<0,0,140>m<153,204,204>] %-23s", def))
            else
              dechoLink(string.format("<153,204,204>[<0,0,140>m<153,204,204>] %-23s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
            end
          else
            if not linkcommand or not dechoLink then
              decho(string.format("<153,204,204>[<0,0,204>M<153,204,204>] %-23s", def))
            else
              dechoLink(string.format("<153,204,204>[<0,0,204>M<153,204,204>] %-23s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
            end
          end
        else
          if not defs_data[def].mana then
            if type(defences.nodef_list[def]) == "string" then
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %s", def.." ("..defences.nodef_list[def]..")"))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %s", def.." ("..defences.nodef_list[def]..")"), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif type(defences.def_def_list[def]) == "string" then
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] % s", def.." "..defences.def_def_list[def]))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] % s", def.." "..defences.def_def_list[def]), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif defs_data[def].onshow then
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %s", def.." ("..defs_data[def].onshow()..")"))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %s", def.." ("..defs_data[def].onshow()..")"), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
            else
              if not linkcommand or not dechoLink then
                decho(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %s", def))
              else
                dechoLink(string.format("<153,204,204>[<0,204,0>X<153,204,204>] %s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
              end
            end
          elseif defs_data[def].mana == "little" then
            if not linkcommand or not dechoLink then
              decho(string.format("<153,204,204>[<0,0,140>m<153,204,204>] %s", def))
            else
              dechoLink(string.format("<153,204,204>[<0,0,140>m<153,204,204>] %s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
            end
          else
            if not linkcommand or not dechoLink then
              decho(string.format("<153,204,204>[<0,0,204>M<153,204,204>] %s", def))
            else
              dechoLink(string.format("<153,204,204>[<0,0,204>M<153,204,204>] %s", def), string.format("%s('%s', nil, nil, false, true)", linkcommand, def), string.format("Remove %s from %s", def, cmdname))
            end
          end
        end
      end

      if not disabled and count % 3 == 0 then echo("\n") end
      if not disabled then count = count + 1 end
    end

    if count %3 ~= 1 then echo("\n") end; count = 1
  end

  setFgColor(153,204,204)
  local underline = setUnderline; _G.setUnderline = function () end

  show_em(nil, defences.def_types.general)

  if defc.dragonform then
    show_em("dragoncraft", defences.def_types.dragoncraft)
  else

    for skillset,s in pairs(defences.def_types) do
      if skillset ~= "general" and skillset ~= "dragoncraft" then show_em (skillset, s) end
    end
  end

  _G.setUnderline = underline
end

function show_current_defs(window)
  svo.echof(window or "main", "Your current defences (%d):", (function ()
    local count = 0
    for k,v in pairs(defc) do if v then count = count + 1 end end
    for k,v in defences.nodef_list:pairs() do
      if v then count = count + 1 end end
    return count
  end)())

  if not window then
    show_defs(defc)
  else
    sk.echofwindow = window
    local olddecho, oldecho = decho, echo
    decho, echo = ofs.windowdecho, ofs.windowecho

    show_defs(defc)

    decho, echo = olddecho, oldecho
  end
end

function show_defup()
  svo.echof("%s defup defences (click to toggle):", defs.mode:title())
  show_defs(defdefup[defs.mode], "svo.defs.defup", "defup")
  showprompt()
end

function show_keepup()
  if not conf.serverside then
    echof("%s keepup defences (click to toggle):", defs.mode:title())
  else
    echofn("%s keepup defences (click to toggle) (", defs.mode:title())

    setFgColor(unpack(getDefaultColorNums))
    setUnderline(true)
    echoLink("view serverside keepup", [[send'CURING PRIORITY DEFENCE LIST']], "Click to view serverside's keepup list - which'll be the same as Svof's", true)
    setUnderline(false)
    echo(")\n")
  end
  show_defs(defkeepup[defs.mode], "svo.defs.keepup", "keepup")
  showprompt()
end

-- can't just check if we need and don't have, because some might have conflicts.
-- hence, just check isadvisable; this checks it for us and skips conflicts.
-- check have defup on prompt so it's not called many times.
function sk.have_defup_defs()
  local waitingon = {}
  for def,deft in defs_data:iter() do
    if defdefup[defs.mode][def] and not defc[def]
     -- if we have to skip it
    and not ((deft.specialskip and deft.specialskip())
     -- or if it's ignored
    or ignore[def]
      -- or it's not a general or dragon defence and we're in dragon
    or (defc.dragonform and not (deft.type == "general" or deft.type == "dragoncraft"))) and not deft.nodef then
      if dict[def] then
        if dict[def].physical and not dict_balanceful_def[def] and not dict_balanceless_def[def] then
          waitingon[#waitingon+1] = string.format("%s (?)", def)
        else
          waitingon[#waitingon+1] = def
        end
      else
        waitingon[#waitingon+1] = string.format("%s (?)", def)
      end
    end
  end

  -- sort them according to aspriority
  table.sort(waitingon,
    function(a,b)
      if dict[a] and dict[b] and dict[a].physical and dict[b].physical then
        return dict[a].physical.aspriority > dict[b].physical.aspriority
      end
    end)

  if #waitingon > 0 then return false, waitingon
  else return true end
end;

function ignoreskill(skill, newstatus, echoback)
  local skill = skill:lower()

  -- first, check if this is a group we're disabling as a whole
  if sk.ignored_defences[skill] then
    sk.ignored_defences[skill].status = newstatus
    showhidelist() return
  end

  -- otherwise, loop through all skillsets, looking for the skill
  for _, group in pairs(sk.ignored_defences) do
    for skills, _ in pairs(group.t) do
      if skills == skill then
        group.t[skill] = newstatus
        showhidelist() return
      end
    end
  end
end

function showhidelist()
  local enabled_c, disabled_c = "<242,218,218>", "<156,140,140>"

  -- adds in the link with a proper tooltip
  local function makelink(skill, sign, groupstatus)
    if sign == "+" then
      echoLink(sign, [[svo.ignoreskill("]]..skill..[[", false, true)]],
        string.format("Click to start showing " .. skill.."%s", groupstatus and " (won't do anything since the group is disabled, though)" or ""), true)
    elseif sign == "-" then
      echoLink(sign, [[svo.ignoreskill("]]..skill..[[", true, true)]],
        string.format("Click to hide " .. skill.."%s", groupstatus and " (won't do anything since the group is disabled, though)" or ""), true)
    else
      echo " "
    end

    return ""
  end

  local count = 1
  -- shows a specific defences group
  local function show_em(name, what)
    decho(string.format("%s%s %s defences:\n",
      (what.status and disabled_c or enabled_c),
      makelink(name, (what.status and "+" or "-")),
      name:title()))

    -- loops through all defences within the group
    for def,disabled in pairs(what.t) do
      -- if the whole group is disabled, then all things inside it should be as well
      local skill_color = (what.status and true or disabled)

      if count % 3 == 1 then echo"  " end
      if (count % 3) ~= 0 then
        decho(string.format("%s%s %-23s",
          (skill_color and disabled_c or enabled_c),
          makelink(def, (disabled and "+" or "-"), what.status),
          def))
      else
        decho(string.format("%s%s %s",
          (skill_color and disabled_c or enabled_c),
          makelink(def, (disabled and "+" or "-"), what.status),
          def))
      end

      if count % 3 == 0 then echo("\n") end
      --~ if count % 3 ~= 1 then echo("  ") end
      count = count + 1
    end

    if count %3 ~= 1 then echo("\n") end
    count = 1
  end

  echof("Select which skillsets or skills to show in defence display lists:")
  show_em("general", sk.ignored_defences.general)

  local function f()
    for j,k in pairs(sk.ignored_defences) do
      if j ~= "general" then show_em (j, k) end
    end
  end

  local s,_ = pcall(f)
  if not s then echof("Your Mudlet version doesn't seem to be new enough to display this; please update to latest (http://forums.mudlet.org/viewtopic.php?f=5&t=1874)") end
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

--[[ Logic: keep the prios embedded in the dict.*.*.spriority/dict.*.*.aspriority, don't keep a table
      of it's own. When exporting/importing, create such tables.]]
pl.dir.makepath(getMudletHomeDir() .. "/svo/prios")

function prio.export (name, options, echoback)
  local sendf; if echoback then sendf = echof end
  assert(name, "what name do you want to save this list as?", sendf)

  -- kv table of what to export
  local to_export = {
    herb = {
      prewrite = "Herb cures: ",
    },
    smoke = {
      prewrite = "Smoke cures: ",
    },
    salve = {
      prewrite = "Salve cures: ",
    },
    sip = {
      prewrite = "Sipping balance: ",
    },
    purgative = {
      prewrite = "Purgative cures: ",
    },
    physical = {
      prewrite = "Balance or equilibrium actions: ",
    },
    focus = {
      prewrite = "Focus cures: ",
    },
    moss = {
      prewrite = "Moss balances (these don't really make sense to order): ",
    },
    misc = {
      prewrite = "Miscallaneous actions: ",
    },
    slowcuring = {
      prewrite = "Slow curing mode priorities: "
    }
  }

  if not options or options == "" or options == " " then
    for k, v in pairs(to_export) do
      v.o = true
    end
  elseif type(options) == "string" then
    for w in string.gmatch(options, "%a+") do
      if to_export[w] then to_export[w].o = true end
    end
  elseif type(options) == "table" then
    for i, w in ipairs(options) do
      if to_export[w] then to_export[w].o = true end
    end
  end

  --[[ generate a single table like so:
  {
    herb = {
      "relapsing",
      "paranoia",
      "vapors",
      ...
    },

    salve = {
    ....
    }

  }

  Writing out though, skip the initial whole table itself.
  ]]

  local data
  local s = {
    "-- Priorities list '".. name .. "' by ".. sys.charname .. ", exported @ " .. os.date().."\n",
    "-- Note: The lower the priority in the list without a number, or the lower number - the more important the thing is. ie, things at the bottom of the list will get done before those on the top!"
  }


  for priority, priotbl in pairs(to_export) do
    if priotbl.o then
      if priority == "slowcuring" then
        data = make_sync_prio_table("%s_%s")
      else
        data = make_prio_table(priority)
      end

      s[#s+1] = "\n-- " .. priotbl.prewrite
      s[#s+1] = priority .. " = " .. pl.pretty.write(data)
    end
  end

  s = table.concat(s, "\n")

  pl.dir.makepath(getMudletHomeDir() .. "/svo/prios")
  io.output(getMudletHomeDir() .. "/svo/prios/"..name, "w")
  io.write(s)
  io.close()

  if echoback then echof("exported %s prio to %s", name, getMudletHomeDir() .. "/svo/prios/"..name) end
end

function prio.list(echoback)
  local dir = getMudletHomeDir() .. "/svo/prios"
  local list = {}

  for file in lfs.dir(dir) do
    if file ~= "." and file ~= ".." then
      list[#list+1] = file
    end
  end

  if echoback then
    echof("Priorities that we've got stored in '%s':\n  %s", dir, concatand(list))
  else
    return list
  end
end

-- returns the table of actions in a balance
function prio.getlist(balance)
  return make_prio_table(balance)
end

-- returns a table of actions in a balance, sorted most important first, without gaps
function prio.getsortedlist(balance)
  -- get into table...
  local data
  if balance ~= "slowcuring" then
    data = make_prio_table(balance)
  else
    data = make_sync_prio_table("%s_%s")
  end
  local orderly = {}

  -- create an indexed list of just the priorities only
  for i,j in pairs(data) do
    orderly[#orderly+1] = i
  end

  -- invert the list, so actions are ordered most important first
  table.sort(orderly, function(a,b) return a>b end)

  -- sort original keys usin the new sorting
  local sortedprios = {}
  for _, prio in ipairs(orderly) do
    sortedprios[#sortedprios+1] = data[prio]
  end

  return sortedprios
end

-- returns the highest number used, and what uses it, in a balance
function prio.gethighest(balance)
  local t = make_prio_table(balance)

  -- there could be holes - can't use #
  local maxprio, maxaction = 0
  for prio, action in pairs(t) do
    if prio > maxprio then
      maxprio = prio
      maxaction = action
    end
  end

  return maxprio, maxaction
end

-- returns a sorted list of actions in a balance by priority
function prio.sortlist(actions, balance)
  assert(type(actions) == "table", "svo.prio.sortlist: actions must be an indexed table (a list)")
  assert(balance, "svo.prio.sortlist: in which balance do you want to check these actions in?")

  table.sort(actions, function(a,b)
    return dict[a] and dict[a][balance] and dict[b] and dict[b][balance] and
      dict[a][balance].aspriority > dict[b][balance].aspriority
  end)

  return actions
end

function prio.getaction(num, balance)
  assert(num and balance, "What number and balance to use?")
  local data = make_prio_table(balance)
  return data[num]
end

function prio.getslowaction(num)
  assert(num, "What number to use?")
  local data = make_sync_prio_table("%s_%s")
  if data[num] then
    return data[num]:match("(%w+)_(%w+)")
  end
end

-- inserts an action at balance and bumps all current actions down if necessary
-- string, string, number -> boolean
-- inserts an action at balance and bumps all current actions down if necessary.
-- because we're really only swapping items in the priority list and not inserting, we don't need to worry
-- about items underflowing past 0 priority yet
function prio.insert(action, balance, number, echoback)
  number = tonumber(number)

  if balance == "balance" then balance = "physical" end

  if balance == "slowcuring" then
    local validaction, plainaction, plainbalance = valid_sync_action(action)

    if not validaction then return false, plainaction end
  end

  local function getpriotable(balance)
    if balance ~= "slowcuring" then
      return make_prio_table(balance)
    else
      return make_sync_prio_table("%s_%s")
    end
  end

  local function insertat(action, balance, number)
    if balance ~= "slowcuring" then
      dict[action][balance].aspriority = number
    else
      dict[plainaction][plainbalance].spriority = number
    end
    if echoback then echof("Set %s's priority in %s balance to %d.", action, balance, number) end
    raiseEvent("svo prio changed", action, balance, number, (balance == "slowcuring" and "slowcuring"))
  end

  local t = getpriotable(balance)
  local originalt = deepcopy(t)

  if balance ~= "slowcuring" and not t then return nil, "no such balance: "..balance end

  -- if nothing is in the desired index, then just insert. If something is, shuffle down first.
  if not t[number] then
    insertat(action, balance, number)
  else
    local function index_of(table, element)
      for k,v in pairs(table) do
        if v == element then return k end
      end
    end

    -- remove from its current position
    local oldnum = index_of(t, action)
    t[oldnum] = nil

    -- move everything below the old index (oldnum) one up
    local newt = {}
    for k,v in pairs(t) do
      if k <= oldnum then
        newt[k+1] = v
      else
        newt[k] = v
      end
    end

    -- copy items into a new table, one lower if they're at or below new index (number)
    local l = {}
    for k,v in pairs(newt) do
      if k <= number then -- if at or below - shuffle 1 down, unless it's at the previous position or below - then keep it
        l[k-1] = v
      else  -- if above: keep where it was
        l[k] = v
      end
    end

    l[number] = action -- insert our action back in
    local action_prio = {} -- create an action-value list of the new priorities
    for k,v in pairs(l) do action_prio[v] = k end

    -- then read off our diff of new list and store away new prios.
    local diff = basictableindexdiff(originalt, l) -- obtain an indexed list of all the different positions
    for _, a in pairs(diff) do
      if balance ~= "slowcuring" then
        dict[a][balance].aspriority = action_prio[a]
        raiseEvent("svo prio changed", a, balance, action_prio[a])
      else
        local _, action, balance = valid_sync_action(a)
        dict[action][balance].spriority = action_prio[a]
        raiseEvent("svo prio changed", action, balance, action_prio[a], "slowcuring")
      end
    end

    if echoback then echof("Set %s's priority in %s balance to %d.", action, balance, number) end
  end

  return true
end

function prio.getnumber(aff, balance)
  assert(aff and balance and dict[aff] and dict[aff][balance], "Such affliction/defence or balance doesn't exist")
  return dict[aff][balance].aspriority
end

function prio.cleargaps(balance, echoback)
  -- sync mode
  if balance == "slowcuring" then
    local data = make_sync_prio_table("%s_%s")

    local max=0
    for k,v in pairs(data) do
      if k>max then max=k end
    end

    local t, n = {}, 0

    for i=1,max do
      if data[i] then n=n+1 t[n]=data[i] end
    end

    -- create an action - prio table for retrieval of location using diffs
    local action_prio = {}
    for i = 1, #t do action_prio[t[i]] = i end

    -- create a diff, using the old table first as it has no holes
    local diff = basictableindexdiff(t, data)

    -- now only change & notify for the delta differences
    for _, a in pairs(diff) do
      local _, action, balance = valid_sync_action(a)
      dict[action][balance].spriority = action_prio[a]
      raiseEvent("svo prio changed", action, balance, action_prio[a], "slowcuring")
    end

    if echoback then echof("Cleared all gaps for the slow curing prio.") end
  -- normal modes
  else
    local data = make_prio_table(balance)

    local max=0
    for k,v in pairs(data) do
      if k>max then max=k end
    end

    local t, n = {}, 0

    for i=1,max do
      if data[i] then n=n+1 t[n]=data[i] end
    end

    -- create an action - prio table for retrieval of location using diffs
    local action_prio = {}
    for i = 1, #t do action_prio[t[i]] = i end

    local diff = basictableindexdiff(t, data)

    for _, a in pairs(diff) do
      dict[a][balance].aspriority = action_prio[a]
      raiseEvent("svo prio changed", a, balance, action_prio[a])
    end

    if echoback then echof("Cleared all gaps for the %s prio.", balance) end
  end
  showprompt()
end

function prio.usedefault(echoback)
  local sendf; if echoback then sendf = echof else sendf = errorf end

  -- um. this fails for some reason on Windows.
--[[  local s,m = os.remove(getMudletHomeDir() .. "/svo/prios/current")
  if not s then echof("Couldn't update because of: "..tostring(m)) return end]]

  if prio.import("current", false, false, true) then
    echof("Updated to default priorities.")
  else
    echof("Couldn't update to default priorities :|") end
end

function prio.import(name, echoback, report_errors, use_default)
  local sendf; if echoback then sendf = echof else sendf = errorf end

  local filename
  if not name then
    filename = invokeFileDialog(true, "Select the priority list you'd like to import")
    if filename == "" then
      sendf("Cancelled; don't have anything to import.")
      return
    end
  end

  local path = filename or getMudletHomeDir() .. "/svo/prios/".. name

  local importables = {
    "herb",
    "smoke",
    "salve",
    "sip",
    "purgative",
    "physical",
    "focus",
    "moss",
    "misc",
    "slowcuring",
  }

  local s
  if name == "current" and (use_default or not lfs.attributes(path)) then
    -- adds in the default prios here at compile-time
    s = "-- Priorities list 'default_prios' by Vadimuses, exported @ Sat 10 Jan 2015 06:29:31 AEST\
\
-- Note: The lower the priority in the list without a number, or the lower number - the more important the thing is. ie, things at the bottom of the list will get done before those on the top!\
\
-- Sipping balance:\
sip = {\
  \"wristfractures\",\
  \"crackedribs\",\
  \"torntendons\",\
  \"skullfractures\",\
  \"healmana\",\
  \"healhealth\"\
}\
\
-- Balance or equilibrium actions:\
physical = {\
  \"fireresist\",\
  \"vigilance\",\
  \"lifevision\",\
  \"deathaura\",\
  \"meditate\",\
  \"dragonbreath\",\
  \"block\",\
  \"coldresist\",\
  \"bell\",\
  \"electricresist\",\
  \"fury\",\
  \"rewield\",\
  \"magicresist\",\
  \"resistance\",\
  \"curseward\",\
  \"clinging\",\
  \"satiation\",\
  \"riding\",\
  \"restore\",\
  \"breath\",\
  \"vengeance\",\
  \"shroud\",\
  \"mastery\",\
  \"putrefaction\",\
  \"soulcage\",\
  \"hypersight\",\
  \"treewatch\",\
  \"metawake\",\
  \"alertness\",\
  \"softfocus\",\
  \"telesense\",\
  \"nightsight\",\
  \"groundwatch\",\
  \"skywatch\",\
  \"mindseye\",\
  \"defcheck\",\
  \"weathering\",\
  \"deathsight\",\
  \"lightpipes\",\
  \"grip\",\
  \"selfishness\",\
  \"dragonarmour\",\
  \"shield\",\
  \"dragonform\",\
  \"sturdiness\",\
  \"lovers\",\
  \"diag\",\
  \"dragonheal\",\
  \"fitness\",\
  \"cloak\",\
  \"doparry\",\
  \"fillskullcap\",\
  \"fillvalerian\",\
  \"fillelm\",\
  \"lyre\"\
}\
\
-- Moss balances (these don't really make sense to order):\
moss = {\
  \"healmana\",\
  \"healhealth\"\
}\
\
-- Smoke cures:\
smoke = {\
  \"deadening\",\
  \"manaleech\",\
  \"disloyalty\",\
  \"hellsight\",\
  \"madness\",\
  \"rebounding\",\
  \"slickness\",\
  \"checkasthma\",\
  \"aeon\"\
}\
\
-- Slow curing mode priorities:\
slowcuring = {\
  \"mindseye_physical\",\
  \"defcheck_physical\",\
  \"doparry_physical\",\
  \"weathering_physical\",\
  \"deathsight_physical\",\
  \"fillskullcap_physical\",\
  \"lovers_physical\",\
  \"grip_physical\",\
  \"selfishness_physical\",\
  \"dragonarmour_physical\",\
  \"dragonbreath_physical\",\
  \"dragonform_physical\",\
  \"sturdiness_physical\",\
  \"fireresist_physical\",\
  \"firedisrupt_herb\",\
  \"waterbubble_herb\",\
  \"sanguinehumour_herb\",\
  \"earthdisrupt_herb\",\
  \"cholerichumour_herb\",\
  \"airdisrupt_herb\",\
  \"melancholichumour_herb\",\
  \"phlegmatichumour_herb\",\
  \"deathsight_herb\",\
  \"waterdisrupt_herb\",\
  \"spiritdisrupt_herb\",\
  \"checkimpatience_misc\",\
  \"amnesia_misc\",\
  \"checkhypersomnia_misc\",\
  \"checkparalysis_misc\",\
  \"hoisted_misc\",\
  \"firedisrupt_focus\",\
  \"fear_focus\",\
  \"airdisrupt_focus\",\
  \"waterdisrupt_focus\",\
  \"parestoarms_salve\",\
  \"extremeburn_salve\",\
  \"unknowncrippledlimb_salve\",\
  \"severeburn_salve\",\
  \"hypothermia_salve\",\
  \"scalded_salve\",\
  \"vigilance_physical\",\
  \"shield_physical\",\
  \"lifevision_physical\",\
  \"meditate_physical\",\
  \"lightpipes_physical\",\
  \"coldresist_physical\",\
  \"bell_physical\",\
  \"electricresist_physical\",\
  \"fury_physical\",\
  \"rewield_physical\",\
  \"deathaura_physical\",\
  \"magicresist_physical\",\
  \"resistance_physical\",\
  \"curseward_physical\",\
  \"clinging_physical\",\
  \"satiation_physical\",\
  \"restore_physical\",\
  \"torntendons_sip\",\
  \"crackedribs_sip\",\
  \"wristfractures_sip\",\
  \"bleeding_misc\",\
  \"breath_physical\",\
  \"levitation_purgative\",\
  \"venom_purgative\",\
  \"speed_purgative\",\
  \"frost_purgative\",\
  \"vengeance_physical\",\
  \"shroud_physical\",\
  \"mastery_physical\",\
  \"putrefaction_physical\",\
  \"soulcage_physical\",\
  \"hypersight_physical\",\
  \"treewatch_physical\",\
  \"metawake_physical\",\
  \"alertness_physical\",\
  \"softfocus_physical\",\
  \"telesense_physical\",\
  \"nightsight_physical\",\
  \"groundwatch_physical\",\
  \"skywatch_physical\",\
  \"healmana_moss\",\
  \"healhealth_moss\",\
  \"deadening_smoke\",\
  \"manaleech_smoke\",\
  \"roped_misc\",\
  \"thirdeye_misc\",\
  \"doprecache_misc\",\
  \"sileris_misc\",\
  \"checkwrithes_misc\",\
  \"checkanorexia_misc\",\
  \"checkslows_misc\",\
  \"fear_misc\",\
  \"lethargy_herb\",\
  \"thirdeye_herb\",\
  \"clumsiness_herb\",\
  \"kola_herb\",\
  \"insomnia_herb\",\
  \"justice_herb\",\
  \"myrrh_herb\",\
  \"dissonance_herb\",\
  \"stupidity_herb\",\
  \"illness_herb\",\
  \"hallucinations_herb\",\
  \"masochism_herb\",\
  \"agoraphobia_herb\",\
  \"pacifism_herb\",\
  \"epilepsy_herb\",\
  \"inlove_herb\",\
  \"hypersomnia_herb\",\
  \"haemophilia_herb\",\
  \"shyness_herb\",\
  \"deaf_herb\",\
  \"addiction_herb\",\
  \"checkstun_misc\",\
  \"dementia_herb\",\
  \"weakness_herb\",\
  \"recklessness_herb\",\
  \"loneliness_herb\",\
  \"dizziness_herb\",\
  \"blind_herb\",\
  \"confusion_herb\",\
  \"generosity_herb\",\
  \"claustrophobia_herb\",\
  \"peace_herb\",\
  \"paranoia_herb\",\
  \"relapsing_herb\",\
  \"impatience_herb\",\
  \"healthleech_herb\",\
  \"rebounding_smoke\",\
  \"darkshade_herb\",\
  \"vertigo_herb\",\
  \"healmana_sip\",\
  \"healhealth_sip\",\
  \"mass_salve\",\
  \"unknowncrippledarm_salve\",\
  \"frozen_salve\",\
  \"heartseed_salve\",\
  \"shivering_salve\",\
  \"ablaze_salve\",\
  \"itching_salve\",\
  \"caloric_salve\",\
  \"loneliness_focus\",\
  \"selarnia_salve\",\
  \"block_physical\",\
  \"riding_physical\",\
  \"unknowncrippledleg_salve\",\
  \"deafaff_salve\",\
  \"blindaff_salve\",\
  \"stuttering_salve\",\
  \"confusion_focus\",\
  \"generosity_focus\",\
  \"claustrophobia_focus\",\
  \"vertigo_focus\",\
  \"dragonflex_misc\",\
  \"fillvalerian_physical\",\
  \"unknownmental_focus\",\
  \"masochism_focus\",\
  \"agoraphobia_focus\",\
  \"dizziness_focus\",\
  \"pacifism_focus\",\
  \"epilepsy_focus\",\
  \"shyness_focus\",\
  \"weakness_focus\",\
  \"madness_smoke\",\
  \"serioustrauma_salve\",\
  \"mangledleftarm_salve\",\
  \"mutilatedrightleg_salve\",\
  \"mutilatedleftarm_salve\",\
  \"mangledleftleg_salve\",\
  \"mangledrightleg_salve\",\
  \"slashedthroat_salve\",\
  \"parestolegs_salve\",\
  \"mutilatedleftleg_salve\",\
  \"mildtrauma_salve\",\
  \"laceratedthroat_salve\",\
  \"mutilatedrightarm_salve\",\
  \"hellsight_smoke\",\
  \"disloyalty_smoke\",\
  \"sensitivity_herb\",\
  \"mangledrightarm_salve\",\
  \"crippledrightarm_salve\",\
  \"crippledleftarm_salve\",\
  \"crippledrightleg_salve\",\
  \"crippledleftleg_salve\",\
  \"rage_misc\",\
  \"cloak_physical\",\
  \"recklessness_focus\",\
  \"hypochondria_herb\",\
  \"voyria_purgative\",\
  \"diag_physical\",\
  \"mildconcussion_salve\",\
  \"seriousconcussion_salve\",\
  \"skullfractures_sip\",\
  \"stupidity_focus\",\
  \"touchtree_misc\",\
  \"slickness_herb\",\
  \"slickness_smoke\",\
  \"impale_misc\",\
  \"disrupt_misc\",\
  \"transfixed_misc\",\
  \"insomnia_misc\",\
  \"charredburn_salve\",\
  \"meltingburn_salve\",\
  \"sleep_misc\",\
  \"bound_misc\",\
  \"webbed_misc\",\
  \"paralysis_herb\",\
  \"prone_misc\",\
  \"anorexia_salve\",\
  \"anorexia_focus\",\
  \"asthma_herb\",\
  \"fitness_physical\",\
  \"checkasthma_misc\",\
  \"checkasthma_smoke\",\
  \"dragonheal_physical\",\
  \"lyre_physical\",\
  \"fillelm_physical\",\
  \"aeon_smoke\"\
}\
\
-- Purgative cures:\
purgative = {\
  \"levitation\",\
  \"venom\",\
  \"speed\",\
  \"frost\",\
  \"voyria\"\
}\
\
-- Salve cures:\
salve = {\
  \"parestoarms\",\
  \"unknowncrippledlimb\",\
  \"unknowncrippledarm\",\
  \"parestolegs\",\
  \"itching\",\
  \"caloric\",\
  \"selarnia\",\
  \"unknowncrippledleg\",\
  \"deafaff\",\
  \"blindaff\",\
  \"stuttering\",\
  \"ablaze\",\
  \"severeburn\",\
  \"slashedthroat\",\
  \"shivering\",\
  \"scalded\",\
  \"serioustrauma\",\
  \"laceratedthroat\",\
  \"mildtrauma\",\
  \"mutilatedrightarm\",\
  \"mutilatedleftarm\",\
  \"mutilatedleftleg\",\
  \"mutilatedrightleg\",\
  \"mangledrightarm\",\
  \"mangledleftarm\",\
  \"crippledleftarm\",\
  \"crippledrightarm\",\
  \"mangledleftleg\",\
  \"mangledrightleg\",\
  \"frozen\",\
  \"hypothermia\",\
  \"crippledrightleg\",\
  \"crippledleftleg\",\
  \"mildconcussion\",\
  \"seriousconcussion\",\
  \"extremeburn\",\
  \"charredburn\",\
  \"meltingburn\",\
  \"mass\",\
  \"heartseed\",\
  \"anorexia\"\
}\
\
-- Focus cures:\
focus = {\
  \"fear\",\
  \"unknownmental\",\
  \"masochism\",\
  \"agoraphobia\",\
  \"pacifism\",\
  \"epilepsy\",\
  \"shyness\",\
  \"weakness\",\
  \"loneliness\",\
  \"airdisrupt\",\
  \"firedisrupt\",\
  \"dizziness\",\
  \"waterdisrupt\",\
  \"confusion\",\
  \"generosity\",\
  \"claustrophobia\",\
  \"vertigo\",\
  \"recklessness\",\
  \"anorexia\",\
  \"stupidity\"\
}\
\
-- Miscallaneous actions:\
misc = {\
  \"checkimpatience\",\
  \"amnesia\",\
  \"checkhypersomnia\",\
  \"dragonflex\",\
  \"checkparalysis\",\
  \"hoisted\",\
  \"rage\",\
  \"thirdeye\",\
  \"sleep\",\
  \"doprecache\",\
  \"sileris\",\
  \"bleeding\",\
  \"fear\",\
  \"webbed\",\
  \"roped\",\
  \"transfixed\",\
  \"bound\",\
  \"impale\",\
  \"disrupt\",\
  \"checkwrithes\",\
  \"checkslows\",\
  \"checkanorexia\",\
  \"checkasthma\",\
  \"checkstun\",\
  \"insomnia\",\
  \"prone\",\
  \"touchtree\"\
}\
\
-- Herb cures:\
herb = {\
  \"firedisrupt\",\
  \"waterbubble\",\
  \"sanguinehumour\",\
  \"earthdisrupt\",\
  \"cholerichumour\",\
  \"airdisrupt\",\
  \"melancholichumour\",\
  \"phlegmatichumour\",\
  \"deathsight\",\
  \"waterdisrupt\",\
  \"myrrh\",\
  \"lethargy\",\
  \"thirdeye\",\
  \"vertigo\",\
  \"justice\",\
  \"healthleech\",\
  \"dissonance\",\
  \"illness\",\
  \"hallucinations\",\
  \"agoraphobia\",\
  \"inlove\",\
  \"hypersomnia\",\
  \"shyness\",\
  \"dementia\",\
  \"addiction\",\
  \"weakness\",\
  \"loneliness\",\
  \"paranoia\",\
  \"generosity\",\
  \"claustrophobia\",\
  \"deaf\",\
  \"blind\",\
  \"haemophilia\",\
  \"masochism\",\
  \"dizziness\",\
  \"epilepsy\",\
  \"confusion\",\
  \"sensitivity\",\
  \"darkshade\",\
  \"clumsiness\",\
  \"pacifism\",\
  \"peace\",\
  \"spiritdisrupt\",\
  \"recklessness\",\
  \"hypochondria\",\
  \"impatience\",\
  \"stupidity\",\
  \"paralysis\",\
  \"slickness\",\
  \"asthma\",\
  \"relapsing\",\
  \"insomnia\",\
  \"kola\"\
}\
"
  else
    assert(lfs.attributes(path), name .. " prio doesn't exist.", sendf)

    io.input(path)
    s = io.read("*all")
  end

  -- load file into our sandbox; credit to http://lua-users.org/wiki/SandBoxes
  local i = {}
  -- run code under environment
  local function run(untrusted_code)
    local untrusted_function, message = loadstring(untrusted_code)
    if not untrusted_function then return nil, message end
    setfenv(untrusted_function, i)
    return pcall(untrusted_function)
  end

  local s, m = run (s)
  if not s then sendf("There's a syntax problem in the prios file, we couldn't load it:\n  %s", m) return end

  local function set(num, action, balance, priority)
    if not (dict[action] and dict[action][balance]) then
      if report_errors then
        if not dict[action] then sendf("Skipping %s, don't know such thing.", action) else
          sendf("Skipping %s, it doesn't use %s balance.", action, balance) end
      end
    else
      dict[action][balance][priority] = num
    end
  end

  -- create a snapshot of the before state for all balances, since dict_setup might mess with any
  local beforestate = sk.getbeforestateprios()

  local contains, sfind = table.contains, string.find
  -- table i now contains subtables with all of our stuff
  for balance,balancet in pairs(i) do
    if contains(importables, balance) then
      if balance == "slowcuring" then
        -- reset all current ones to zero
        clear_sync_prios ()

        for num, action in pairs(balancet) do
          -- have to weed out action name _ balance name first
          local _,_, action, balance = sfind(action, '(%w+)_(%w+)')
          set(num, action, balance, "spriority")
        end
      else
        -- reset all current ones to zero
        clear_balance_prios(balance)
        for num, action in pairs(balancet) do
          set(num, action, balance, "aspriority")
        end
      end
    end
  end
  dict_setup()
  dict_validate()

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)

  if echoback then echof("Imported %s prio list.", name) end
  return true
end

signals.saveconfig:connect(function ()
  prio.export("current")
end)

signals.systemstart:connect(function ()
  prio.import("current")
end)
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

pl.dir.makepath(getMudletHomeDir() .. "/svo/config")

sps.sp_fillup = function ()
  local t = {}
  for limb, _ in pairs(sp_limbs) do
    t[limb] = false
  end
  return t
end

sp_config = { parry = "", priority = {}, parry_actionlevel = {}, parry_shouldbe = sps.sp_fillup() }
sps.parry_currently = sps.sp_fillup()
me.parry_currently = sps.parry_currently

sps.parry_options = {
  full = "Parry the currently damaged limb (one that's mangled/mutilated).",
  lasthit = "Parry the last hit limb (ie got hit left leg - will parry left leg).",
  ["lasthit opposite limb"] = "Parry the opposite of the last hit limb, by limbs (ie got hit left leg - will parry right  leg).",
  ["lasthit opposite side"] = "Parry the opposite of the last hit limb, by sides (ie got hit left leg - will parry left arm).",
  manual = "Allows you to manually control parry with the p* aliases."
}

-- ask users to click on limbs for priority first, then ask for each limb in order to select action level,
-- then ask what to do with stancing when the action level happens, and what to do with parrying
sps.install = {
  {
    check = function () return #sp_config.priority == table.size(sp_limbs) end,
    act = function (step)
      echof("Step %d - assign priorities to the limbs. Click on the following in the order of most important, or use the %s command:", step, green("vp nextprio <limb>"))
      echo("  " .. oneconcat(sp_limbs))
          resetFormat()
          deselect()
      for name, _ in pairs(sp_limbs) do
        moveCursor("main",  1, getLineNumber()+2)
        if selectString(name, 1) ~= -1 then
          setLink('svo.sp.nextprio ("' .. name .. '", true)', 'Set ' .. name .. ' as the next limb in importance.')
          resetFormat()
          deselect()
        end
      end
      echo"\n"
    end},
  --[[{
    check = function ()
        for limb,_ in pairs(sp_limbs) do
          if sp_config.parry_actionlevel[limb] == nil then return false end
        end
        return true
      end,
    act = function (step)
      local function makecodestrings(name)
        local t = {}
        t[#t+1] = 'svo.sp.setparrylevel("'..name..'", false, true)'
        for amount = 275, 2000, 275 do
          t[#t+1] = 'svo.sp.setparrylevel("'..name..'", '..amount..', true)'
        end
        return t
      end
      local function maketooltipstrings(name)
        local t = {}
        t[#t+1] = 'Set ' .. name .. ' to ' .. 'none'
        for amount = 275, 2000, 275 do
          t[#t+1] = 'Set ' .. name .. ' to ' .. amount
        end
        return t
      end


      echof("Step %d - assign a level above which parry should act for for each limb by right-clicking, or use the %s command:", step, green("vp parrylevel <limb> <amount, or 'none'>"))
      echo "  "
      for name, _ in pairs(sp_limbs) do
        echoPopup(name, makecodestrings(name), maketooltipstrings(name))
        echo(" ")
      end
      echo"\n"
    end},
]]
  {
    check = function () return sp_config.parry ~= "" end,
    act = function (step)
      echof("Step %d - decide what parry strategy to use when a limb is over the limit by clicking on it, or using the %s command:", step, green("vp parrystrat <strategy>"))
      echo "  "
      for name, tooltip in pairs(sps.parry_options) do
        echoLink(name, 'svo.sp.setparry ("' .. name .. '", true)', tooltip)
        echo " "
      end
      echo"\n"
    end},

}

sps.installnext = function()
  if not sps.settingup then return end
  for i, c in ipairs(sps.install) do
    if not c.check() then
      echo"\n"
      c.act(i)
      return
    end
  end

  sps.settingup = nil
  echof("Parry setup done :)")
end


function sp.setup()
  sp_config = { parry = "", priority = {}, parry_actionlevel = {}, parry_shouldbe = sps.sp_fillup() }
  sps.settingup = true

  sps.installnext()
end

function sp.nextprio(limb, echoback)
  local sendf
  if echoback then sendf = echof else sendf = errorf end
  local prios = sp_config.priority

  if not sp_limbs[limb] then
    sendf("Sorry, %s isn't a proper limb name. They are:\n  %s", limb, oneconcat(sp_limbs))
    return; end

  if contains(prios, limb) then
    sendf("%s is already in the list.", limb); return; end

  prios[#prios+1] = limb
  if echoback then
    echof("%s added; current list: %s", limb, table.concat(prios, ", "))
  end

  if #prios == table.size(sp_limbs) then sps.installnext() end
end

function sp.setparry(option, echoback)
  local sendf
  if echoback then sendf = echof else sendf = errorf end

  if not option then
    sendf("Possible options are:")
    echo"  "
    for name, tooltip in pairs(sps.parry_options) do
      echoLink(name, 'svo.sp.setparry ("' .. name .. '", true)', tooltip)
      echo "   "
    end
    echo'\n'
    showprompt()
    return
  elseif not sps.parry_options[option] then
    sendf("Sorry, %s isn't a valid option for parry. They are:")
    echo"  "
    for name, tooltip in pairs(sps.parry_options) do
      echoLink(name, 'svo.sp.setparry ("' .. name .. '", true)', tooltip)
      echo "   "
    end
    echo'\n'
    showprompt()
    return
  end

  sp_config.parry = option
  if echoback then
    echof("Will use the %s strategy for parry.", sp_config.parry)
    showprompt()
  end

  sp_checksp()
  sps.installnext()
end

function sp.setparrylevel(limb, amount, echoback)
  local sendf
  if echoback then sendf = echof else sendf = errorf end

  if not sp_limbs[limb] then
    sendf("Sorry, %s isn't a proper limb name. They are:\n  %s", limb, oneconcat(sp_limbs))
    return; end

  if not tonumber(amount) and amount ~= false then
    sendf("To what amount do you want to set %s to?", limb)
    return; end

  sp_config.parry_actionlevel[limb] = tonumber(amount)

  if echoback then
    echof("Set the %s parry action level to %s", limb, amount and tostring(amount) or "none")
  end

  for limb,_ in pairs(sp_limbs) do
    if sp_config.parry_actionlevel[limb] == nil then return end
  end
  sps.installnext()
end

function sp_setparry(what, echoback)
  local sendf
  if echoback then sendf = echof else sendf = errorf end

  local t = {
    h = "head",
    tt = "torso",
    rl = "right leg",
    ll = "left leg",
    ra = "right arm",
    la = "left arm",
    n = "nothing"
  }

  assert(t[what], "invalid short letter for svo.sp_setparry", sendf)

  for limb, _ in pairs(sp_limbs) do
    if limb == t[what] then sp_config.parry_shouldbe[limb] = true
      else sp_config.parry_shouldbe[limb] = false end
  end

  sp_checksp()
  make_gnomes_work()
end

sp.show = function ()
  echof("Parry report:")

  --[[echof("Action levels:")
  for limb, level in pairs(sp_config.parry_actionlevel) do
    echo"  " echof("%s: parry %s", limb, tostring(level))
  end]]

  echof("Limb priorities: %s", table.concat(sp_config.priority, ", "))
  echof("Parry strategy: %s (currently parrying: %s)", type(sp_config.parry) == "string" and sp_config.parry or "custom function",

  (function ()
    local parrying_list = {}
    for limb, parrying in pairs(sp_config.parry_shouldbe) do
      if parrying then parrying_list[#parrying_list+1] = limb end
    end

    return table.concat(parrying_list, ", ") end)())
end

sp_checksp = function ()
  -- check parry
  -- see if any priories have been set for strategies that require them
  local prios, priosset = sp_config.priority, true
  if type(prios) ~= "table" then
    priosset = false
  end

  if priosset and sp_config.parry == "full" then
    local alreadyset
    for i = 1, #prios do
      local limb = prios[i]
      if not alreadyset and type(sp_config.parry_actionlevel[limb]) == "number" and (affs["mangled"..limb] or (limb == head and (affs.serioustrauma or affs.mildtrauma)) or (limb == "torso" and (affs.mildconcussion or affs.seriousconcussion))) then
        sp_config.parry_shouldbe[limb] = true
        alreadyset = true
      else
        sp_config.parry_shouldbe[limb] = false
      end
    end

  elseif sp_config.parry == "lasthit" then
    for limb, _ in pairs(sp_config.parry_shouldbe) do
      if limb == me.lasthitlimb then
        sp_config.parry_shouldbe[limb] = true
      else
        sp_config.parry_shouldbe[limb] = false
      end
    end

  elseif sp_config.parry == "lasthit opposite limb" then
    local t = {
      head = "torso",
      torso = "head",
      ["right arm"] = "left arm",
      ["left arm"] = "right arm",
      ["right leg"] = "left leg",
      ["left leg"] = "right leg"
    }

    local wanted = t[me.lasthitlimb]

    if wanted then
      for limb, _ in pairs(sp_config.parry_shouldbe) do
        if limb == wanted then
          sp_config.parry_shouldbe[limb] = true
        else
          sp_config.parry_shouldbe[limb] = false
        end
      end
    end

  elseif sp_config.parry == "lasthit opposite side" then
    local t = {
      head = "torso",
      torso = "head",
      ["right arm"] = "right leg",
      ["left arm"] = "left leg",
      ["right leg"] = "right arm",
      ["left leg"] = "left arm"
    }

    local wanted = t[me.lasthitlimb]

    if wanted then
      for limb, _ in pairs(sp_config.parry_shouldbe) do
        if limb == wanted then
          sp_config.parry_shouldbe[limb] = true
        else
          sp_config.parry_shouldbe[limb] = false
        end
      end
    end

  elseif type(sp_config.parry) == "function" then
    local s,m = pcall(sp_config.parry)
    if not s then echof("Your custom parry function had a problem:\n  %s", m) end
  end

  -- check if we need to adjust our parry
  check_sp_satisfied()

  signals.after_lifevision_processing:block(sp_checksp)
end

-- check custom parry functions whenever we gain or lose an aff
-- implemented in another function and not sp_checksp, because of https://github.com/katcipis/luanotify/issues/24
sps.checkcustomparry = function()
  if type(sp_config.parry) == "function" then
    sp_config.parry()

    -- check if we need to adjust our parry
    check_sp_satisfied()
  end
end
signals.svogotaff:connect(sps.checkcustomparry)
signals.svolostaff:connect(sps.checkcustomparry)
-- public API
checkcustomparry = sps.checkcustomparry

signals.after_lifevision_processing:connect(sp_checksp)
signals.after_lifevision_processing:block(sp_checksp)

sps.something_to_parry = function ()
  for _, shouldparry in pairs(sp_config.parry_shouldbe) do
    if shouldparry then return true end
  end

  return false -- don't unparry if we have all zero's as shouldparry
end

signals.saveconfig:connect(function () table.save(getMudletHomeDir() .. "/svo/config/sp_config", sp_config) end)

local sp_config_path = getMudletHomeDir() .. "/svo/config/sp_config"

if lfs.attributes(sp_config_path) then
  local ok = pcall(table.load,sp_config_path, sp_config)
  if not ok then
    os.remove(sp_config_path)
    tempTimer(10, function()
      echof("Your parry config file was corrupted - I've deleted it so the system can load other stuff OK. You'll need to set the parry options again with vconfig sp. (%q)", msg)
    end)
  end
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

life.hellotrigs = {}

life.hellodata = {
  ["Dusk has overtaken the light in Achaea."] = function ()
    local t = {"Good evening.", "Good evening, " .. sys.charname..".", "Hello!"}
    echof(t[math.random(1, #t)])
  end,
  ["It is dusk in Achaea."] = function ()
    local t = {"Good evening.", "Good evening, " .. sys.charname..".", "Hello!"}
    echof(t[math.random(1, #t)])
  end,

  ["It is deep night in Achaea, before midnight."] = function ()
    local t = {"*yawn*. Hi.", "Ello. It's a lovely night tonight.", "What a night. Look at the stars!"}
    echof(t[math.random(1, #t)])
  end,
  ["It is early morning in Achaea."] = function ()
    local t = {"*yawn*. Morning!", "Gooood morning, " .. sys.charname .. "!", "Hello!", "Morning!"}
    echof(t[math.random(1, #t)])
  end,
  ["It is early afternoon in Achaea."] = function ()
    local t = {"Good afternoon.", "Good afternoon, " .. sys.charname .. ".", "Hello!", "hi!"}
    echof(t[math.random(1, #t)])
  end,
}

life.hellodata["It is the middle of the night in Achaea."] = life.hellodata["It is deep night in Achaea, before midnight."]
life.hellodata["You think that it is currently night-time up above."] = life.hellodata["It is deep night in Achaea, before midnight."]
life.hellodata["Darkness rules the land. It is deepest midnight."] = life.hellodata["It is deep night in Achaea, before midnight."]
life.hellodata["It is late night, approaching dawn."] = life.hellodata["It is deep night in Achaea, before midnight."]
life.hellodata["The shadows have lengthened. It is late afternoon in Achaea."] = life.hellodata["It is early afternoon in Achaea."]
life.hellodata["It's mid-morning in Achaea."] = life.hellodata["It is early morning in Achaea."]
life.hellodata["The sun has awakened from its long slumber. It is dawn."] = life.hellodata["It is early morning in Achaea."]
life.hellodata["The sun sits at its apex. It is exactly noon."] = life.hellodata["It is early afternoon in Achaea."]
life.hellodata["You think that it is currently day-time up above."] = life.hellodata["It is early afternoon in Achaea."]

protips = {
  "You can do 'vconfig warningtype right' to have the instakill warnings be less spammy",
  "You can toggle sbites and stabs to ignore bites or doublestabs with only one venom from Serpents",
  "You can toggle 'tsc' to toggle command overriding or denying in aeon or retardation. The autotsc will also automatically toggle this for you",
  "'lp' will relight all pipes manually",
  "'inra' will store away all riftables in the rift",
  "You can customize when the system uses the tree tattoo with your own custom scenarios",
  "You can customize when the system uses the restore skill with your own custom scenarios",
  "You can use 'vdefs cancel' to cancel defup",
  "You can use 'fl' to get to full stats, and chain it with commands to do after you're good - ie 'fl write journal', 'fl board ship, 'fl challenge person'",
  "You can use 'pva' to toggle quickly between paralysis and asthma priority",
  "You can use 'pvd' to toggle quickly between paralysis and darkshade priority",
  "You can use 'avs' to toggle quickly between impatience and slickness priority (apostate vs serpent)",
  "You can use svo.prompttrigger() to trigger actions to be done on the next prompt. Can come in very handy in scripting",
  "Basic keepup is done at login for you, so you might want to be conservative about what you put on basic keepup - and instead put most of the defs on defup, or in another mode",
  "You can create your own priority lists, and swap them in depending on your fighting conditions",
  "You can add names not to be autorejected with vconfig lustlist <name>",
  "No illusions will be checked with anti-illusion off. If you're worried, it's best to leave it on",
  "If you attach flame sigils to your pipes, you can't be forced to put them in your container",
  "Be extra careful in blackout. People use it, obviously enough, to hide things from you",
  "Review your fight logs. There's always room for improvement",
  "This is a game, and it should be entertaining. If it's not - consider something else",
  "Pay attention in raids! Group cohesiveness demands attention and quick action",
  "When your group leader is spamming into your block to move, take that as a hint to unblock quickly",
  "You can use vconfig showbaltimes to see how long your balance & equilibrium actions took",
  "With vconfig gagpipes on, the system will light all 3 pipes whenever one goes out for better assurance",
  "It might be a good idea to clear your target if they raise deliverance - can save you from accidentally hitting them. Search for Svof's \"Deliverance\" trigger for the pattern on that",
  "Svof can plot people on the mapper for you! With the peopletracker addon you have, open the Mudlet map and make sure you have the latest mapper script",
  "You can do 'qwho' with the peopletracker addon to plot people on the map",
  "You can do 'qwhom' to see a nicer list of where everyone is located, along with 'qwhom <area>'",
  "You can do 'ppin <area>' after doing qwho to report on your ccto what people are in an area",
  "You can do 'ppwith <person>' after doing qwho to report the people grouped with someone to your ccto",
  "You can do vconfig ccto pt, vconfig ccto tell <person>, vconfig ccto ot, vconfig ccto echo and vconfig ccto <short clan name> to configure where ccto messages go",
  "You can use gotop or gotop <person> with the peopletracker addon after locating them to go to them",
  "If a name is on the map, you can gotop <name> to get to it",
  "With the peopletracker addon, you can just use 'gotop' to go to the last known location of the person in the 'target' variable",
  "hh quickly toggles between health and mana priority",
  "Some limbcounters (not Svof's) reset when you apply a salve to a limb after an attack - if you know that's the case, you could trigger to randomly apply mending to a limb they just hit!",
  "You can make colour logs by selecting text, right-clicking and selecting 'copy to HTML'. Then paste it into pastehtml.com and share the link",
  "Find out which of your abilities are completely hidden in blackout - you can cause blackout by obtaining dust bombs and throwing them at the ground",
  "You can make your own echos colour schemes and select them with 'vshow colors'. See docs on how!",
  "You can customize which defences, or even skillsets, show up in def lists with vshow hidelist",
  "Svof comes with a built-in logger: you can do 'startlog' to log, and 'stoplog' to stop logging",
  "You might want to turn focus use off against experienced Priests to save on mana",
  "It'd be good to adjust your vconfig manause amount to something above 50 against Apostates, Alchemists or Priests - this'll sure the system doesn't use mana for curing when you're getting close to instakill levels",
  "cll (and cll on, cll off) is a shortcut for vconfig clot - toggles clotting on/off",
  "va (and va on, va off) is a shortcut for vkeep riding - toggles auto-mounting or auto-dismounting. If you'd like to disable this, you can do vignore riding",
  "Disabling clotting against an Apostate might be a good idea - this'll save you precious mana. Just keep tabs on how much you're bleeding for",
  "Noticed an opponent stopped hitting certain limbs of yours? They're likely prepped now. You could break them yourself by bouncing off their rebounding aura on that limb",
  "You can use svo.boxDisplay(\"message here\", \"foreground color:background color\") to make giant echoes",
  "The system is your tool; it's in your interest to master it",
  "You can use vconfig manause # to mod the % of mana below which the system won't be using mana skills and will be trying for alternatives. You want to be upping this against Apostates, Alchemists, Priests",
  "Svof doesn't make you edit text files for any settings - everything is accessible from vconfig options, or clickable menus of vshow, vconfig, vconfig2",
  "To lock areas in the mapper, type 'arealock' or 'arealock area' and click on the Lock! buttons",
  "Mudlet's errors view is in Scripts -> Errors, the button is bottom-left",
  "You can use Svof's echos by doing svo.echof(\"stuff\")",
  "Need to catch a breather in retardation and cure up? Tumble out - Svof will send all curing commands right when you get out of the room. Good chance you'll get braziered back in though",
  "You can use svo.concatand(mytable) to bring all the items together in a list, with a proper 'and' at the end",
  "You can use svo.deleteLineP() to completely gag the line and the prompt coming after it",
  "Svof comes with some scripting examples of the API built-in - take a look at Svof's scripts folder",
  "'vshow herbstat' shows what Svof thinks of your herb inventory and updates real-time!",
  "You can do \"vlua svo.protips\" to see all of the protips",
  "The extra Svof's in the Package Manager are OK - those are the addons",
  [[When you're scripting, you can make Svof do an action for you in the proper way via the svo.doaction("<action>", "<balance>") function - for example svo.doaction("healmana", "sip") will properly sip mana or mentality, depending on the users settings and what they actually have]],
  [[vconfig lag 4 - for those times when you're on a hawaiian mountainside catching DSL wifi through a rain catchment tank during a heavy jungle rain]],
  "You can look at vshow curelist for a forestal <-> alchemist equivalents table, and configure prefercustom curemethod from right there",
  "vlua can work as a calculator - try it, do vlua 2+2",
  "If bleeding a ton, switch your sipping priority to mana as long as you can afford it to clot away quicker",
  "Use qwho <area> to see if any ungemmed people are bashing in an area before walking there",
  "Svof is designed to be a platform for your system - there's loads of things you can build on top of it. Check out the docs for anything you'd like to do!",
  "Attach flame sigils to your pipes so you can't be forced to put them away in your pack. You can still be forced to drop them, though",
  "You can pre-block a direction with b <direction> before moving, to help combat beckon triggered on alertness (you can also spam manual block to help with that too)",
  "You can use dop to toggle the do queue - useful in bashing, when you don't want to dor off/dor <bashing alias> again",
  "Svof is not an acronym! Just a short name...",
  "'ndb' shows you a cheatsheet for NameDB! You can hover over or click on aliases to see an explanation.",
  "'ndb long' shows you a cheatsheet for NameDB!",
  "Svof has a very thorough Lyre mode built-in - check the manual on how to make use of it",
  "You can make use of the 'svo system loaded' event to stop having to shuffle your scripts down after upgrading",
  "Proning your hoister is the quickest way to get down - if you're setup for that, you can do 'vignore hoisted' to have the system not autowrithe for you",
  "You can sit and sleep without needing to pause the system",
  "You can use 'shh' to toggle sipping health before all prios in retardation curing mode",
  "You can use vp <balance> to view & change priorities for a balance",
  "The (a) that pops up on aeon/retardation is clickable - clicking on it will show what actions was the system considering/doing",
  "You can use vset <aff name> <balance> <priority number> to move a prio to a position and shift the rest down, ie vset wristfractures sip 5",
  "'tn raid' will switch into combat defs mode for you and ensure that a few essential defs are on keepup",
  "'vconfig repeatcmd #' will have Svof repeat all curing commands # amount of times",
  "'ppof <city>' will report the citizens online of that city",
  "'qwc' will sort qw by citizenry",
  "'qwm' shows ungemmed marks on qw",
  "'qwic' shows ungemmed Infamous on qw. 'qwi' re-checks all people and then shows the ungemmed Infamous",
  "You can toggle vconfig gagservercuring to show/hide [CURING] messages from serverside",
  "You can use 'ndb delete unranked' to wipe unranked (dormant / newbies) players from NameDB",
  "You can export all priorities in a file and edit them there, see 'vshow'"
}


lifep.sayhello = function()
  for _, id in ipairs(life.hellotrigs) do
    killTrigger(tostring(id))
  end
  life.hellotrigs = nil
  deleteAllP()

  for pattern, func in pairs(life.hellodata) do
    if line:find(pattern) then
      tempTimer(.1, function () func() showprompt() end)

      tempTimer(math.random(2,5), function () math.randomseed(os.time()) echof("protip: ".. protips[math.random(1, #protips)]..".") showprompt() end)
      break
    end
  end
end

life.sayhello = function ()

  tempTimer(math.random(2, 7), function ()
    if conf.paused then echof("Hey!") return end

    life.hellotrigs = {}
    for pattern, func in pairs(life.hellodata) do
      life.hellotrigs[#life.hellotrigs+1] = (tempExactMatchTrigger or tempTrigger)(pattern, 'svo.lifep.sayhello()')
    end
    send("time raw", false)
  end)
end
signals.charname:connect(life.sayhello)
signals.gmcpcharname:connect(life.sayhello)
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

function sk.getactiondo(i)
  local action = me.doqueue[i]
  if not action then return '' end

  if type(action) == 'table' then
    return tostring(action.what)
  else
    return tostring(action)
  end
end

sk.dometatable = {
  __tostring = function (self)
    return self.what
  end
}

function dofirst(what, echoback, show)
  if type(show) == 'nil' then
    table.insert(me.doqueue, 1, what)
  else
    local t = {what = what, show = show}
    setmetatable(t, sk.dometatable)
    table.insert(me.doqueue, 1, t)
  end

  if echoback then echof("Will do \"%s\" first.", tostring(what)) end
  -- spur the queue into doing work right away, unless this came from a trigger - in which case the prompt will make the stuff work anyhow
  if not debug.traceback():find("Trigger", 1, true) then make_gnomes_work() end
  raiseEvent("svo do changed")
end
function dofreefirst(what, echoback)
  table.insert(me.dofreequeue, 1, what)
  if echoback then echof("Will do \"%s\" first in dofree.", tostring(what)) end
  if not debug.traceback():find("Trigger", 1, true) then make_gnomes_work() end
  raiseEvent("svo dofree changed")
end

function doadd(what, echoback, show)
  if type(show) == 'nil' then
    me.doqueue[#me.doqueue+1] = what
  else
    local t = {what = what, show = show}
    setmetatable(t, sk.dometatable)
    me.doqueue[#me.doqueue+1] = t
  end

  if echoback then echof("Added '%s' to the do queue.", tostring(what)) end
  if not debug.traceback():find("Trigger", 1, true) then make_gnomes_work() end
  raiseEvent("svo do changed")
end

function doaddfree(what, echoback)
  me.dofreequeue[#me.dofreequeue+1] = what
  if echoback then echof("Added '%s' to the dofree queue.", tostring(me.dofreequeue[#me.dofreequeue])) end
  if not debug.traceback():find("Trigger", 1, true) then make_gnomes_work() end
  raiseEvent("svo dofree changed")
end

function donext()
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end
  if not debug.traceback():find("Trigger", 1, true) then make_gnomes_work() end
end

function dor (what, echoback, show)
  if not what or what == "off" then
    if me.doqueue.repeating or what == "off" then
      me.doqueue = {repeating = false}
      if echoback then echof("Do-Repeat %s.", red("disabled")) end
    else
      me.doqueue.repeating = true
      if echoback and #me.doqueue > 0 then
        echof("Do-Repeat %s; will repeat the first command (%s) in the queue%s.", green("enabled"), sk.getactiondo(1), (me.dopaused and ", but the do queue is currently paused" or ""))
      elseif echoback then
        echof("Do-Repeat %s; will repeat the first command (which is nothing right now) in the queue%s.", green("enabled"), (me.dopaused and ", but the do queue is currently paused" or ""))
      end
    end
  else
    me.doqueue.repeating = true
    if type(show) == 'nil' then
      me.doqueue[1] = what
    else
      me.doqueue[1] = {what = what, show = show}
    end

    if echoback then echof("Do-Repeat %s; will repeat %s forever%s.", green("enabled"), sk.getactiondo(1), (me.dopaused and ", but the do queue is currently paused" or "")) end
  end
  if not debug.traceback():find("Trigger", 1, true) then make_gnomes_work() end
  raiseEvent("svo do changed")
end

function sk.check_do()
  if not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm or doworking or me.dopaused then return end

  if #me.doqueue == 0 then return end

  doworking = true

  local action = me.doqueue[1]
  local show
  if type(action) == 'table' then
    show = action.show
    action = action.what
  end

  if type(action) == "string" then
    for _,w in ipairs(string.split(action, "%$")) do
      if type(show) == 'nil' then
        pcall(expandAlias, w)
      else
        pcall(expandAlias, w, show)
      end
    end
  else
    local s,m = pcall(action)
    if not s then echof("Your do queue %s had a problem:\n  %s", tostring(action), m) end
  end

  if not me.doqueue.repeating then
    table.remove(me.doqueue, 1)
    raiseEvent("svo do changed")
  end

  doworking = false

  return true
end

signals.systemstart:connect(function () addbalanceful("svo check do", sk.check_do) end)

function check_dofree()
  if not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm or dofreeworking then return end

  if #me.dofreequeue == 0 then return end

  dofreeworking = true

  for _, action in ipairs(me.dofreequeue) do
    if type(action) == "string" then
      for _,w in ipairs(string.split(action, "%$")) do
        expandAlias(w, false)
      end
    else
      local s,m = pcall(action)
      if not s then echof("Your dofree queue %s had a problem:\n  %s", tostring(action), m) end
    end
  end

  me.dofreequeue = {}
  raiseEvent("svo dofree changed")

  dofreeworking = false
end

signals.systemstart:connect(function () addbalanceless("svo check dofree", check_dofree) end)

function undo(what, echoback)
  if what == "all" then return end

  if #me.doqueue == 0 then
    if echoback then echof("The do queue is empty.") end
  return end

  if what then
    for i in ipairs(me.doqueue) do
      local action = sk.getactiondo(i)
      if type(action) == 'table' then
        action = action.what
      end

      if action == what then
        table.remove(me.doqueue, i)
        if echoback then echof("Removed \"%s\" from the do queue.", action) return end
      end
    end

    if echoback then echof("Don't have \"%s\" in the do queue.", what) end
  else
    local action = sk.getactiondo(1)
    if type(action) == 'table' then
      action = action.what
    end

    if echoback then echof("Removed \"%s\" from the do queue.", action) end
  end
  raiseEvent("svo do changed")
end

function undofree(echoback)
  if #me.dofreequeue == 0 then
    if echoback then echof("The dofree queue is empty.") end
  return end

  if what then
    for i,v in ipairs(me.dofreequeue) do
      if v == what then
        table.remove(me.dofreequeue, i)
        if echoback then echof("Removed \"%s\" from the dofree queue.", v) return end
      end
    end

    if echoback then echof("Don't have \"%s\" in the dofree queue.", what) end
  else
    local what = table.remove(me.dofreequeue, 1)
    if echoback then echof("Removed \"%s\" from the dofree queue.", what) end
  end
  raiseEvent("svo dofree changed")
end

function undoall(echoback)
  me.doqueue = {}
  if echoback then echof("Do queue completely cleared.") end
  raiseEvent("svo do changed")
end

function undoallfree(echoback)
  me.dofreequeue = {}
  if echoback then echof("Dofree queue completely cleared.") end
  raiseEvent("svo dofree changed")
end

function doshow()
  echof("Actions left in the dofree queue (%d): %s", #me.dofreequeue, safeconcat(me.dofreequeue, ", "))
  echof("Actions left in the do queue (%d): %s", #me.doqueue, safeconcat(me.doqueue, ", "))
  if me.dorepeat then echof("Do-Repeat is enabled.") end
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

cpp = {}

for _, stat in ipairs {"health", "mana", "endurance", "willpower"} do
  cpp["compute_"..stat.."_percent"] = function()
    return math.floor((stats["current"..stat]/stats["max"..stat])*100)
  end
end

for _, stat in ipairs {"health", "mana", "endurance", "willpower"} do
  cpp["compute_"..stat.."_colour"] = function()
    if stats["current"..stat] >= (stats["max"..stat] * .75) then
      return "<a_darkgreen>"
    elseif stats["current"..stat] >= (stats["max"..stat] * .25) then
      return "<a_yellow>"
    else
      return "<a_red>" end
  end
end

cpp.compute_reverse_xp = function()
  return 100 - stats.nextlevel
end

cpp.compute_pause = function()
  return conf.paused and '<a_red>(<a_darkgrey>p<a_red>)<black> ' or ''
end

cpp.compute_slowcuring = function()
  if not sys.sync then return '' end

  local s = {}
  s[#s+1] = "<red>("

  if sacid then
    s[#s+1] = "<green>a"
  elseif sk.doingstuff_inslowmode() then
    s[#s+1] = "<red>a"
  else
    s[#s+1] = "<blue>a"
  end

  s[#s+1] = "<red>) "

  return table.concat(s)
end

cpp.unknown_stats = function()
  if not affs.recklessness and not affs.blackout then return '' else
  return "<blaze_orange>?: " end
end

cpp.compute_defs = function()
  local t = {}

  if defc.cloak then
    t[#t+1] = "c"
  end

  if affs.deafaff or defc.deaf then
    t[#t+1] = "d"
  end

  if affs.blindaff or defc.blind then
    t[#t+1] = "b"
  end

  if defc.kola then
    t[#t+1] = "k"
  end

  if defc.rebounding then
    t[#t+1] = "r"
  end

  if defc.breath then
    t[#t+1] = "h"
  end

  return table.concat(t)
end

cpp.compute_eqbal = function()
  local t = {}

  if bals.equilibrium then t[#t+1] = "e" end
  if bals.balance then t[#t+1] = "x" end

  return table.concat(t)
end

cpp.compute_armbal = function()
  local t = {}

  if bals.leftarm == true then
    t[#t+1] = "l"
  elseif bals.leftarm ~= false then
    t[#t+1] = "?" end

  if bals.rightarm == true then
    t[#t+1] = "r"
  elseif bals.rightarm ~= false then
    t[#t+1] = "?" end

  return table.concat(t)
end

cpp.compute_prone = function ()
  return (affs.prone and "p" or "")
end

cpp.compute_Prone = function ()
  return (affs.prone and "P" or "")
end




cpp.compute_gametarget_colour = function()
  local colour = "blanched_almond"

  local hp = me.gametargethp or 0
  if hp == 0 then
      -- default colour
  elseif hp < 5 then
        colour = "red" -- nearly dead
  elseif hp < 25 then
        colour = "orange_red" -- grievously wounded
  elseif hp < 50 then
        colour = "dark_orange" -- injured
  elseif hp < 75 then
        colour = "orange" -- slightly injured
  end

  return '<'..colour..">"
end



-- add me to default prompt




cpp.compute_dragonhealbal = function()
  return (bals.dragonheal and "d" or "")
end

cpp.compute_timestamp = function()
  return getTime(true, 'hh:mm:ss.zzz')
end

cpp.compute_servertimestamp = function()
  return me.servertime or ''
end

cpp.compute_at = function()
  return (defc.blackwind or defc.astralform or defc.phase) and "@" or ""
end

cpp.compute_gametarget = function()
  return me.gametarget and me.gametarget or ""
end

cpp.compute_gametargethp = function()
  return me.gametargethp and me.gametargethp.."%" or ""
end

cpp.compute_weaponmastery = function()
  return stats.weaponmastery or 0
end

cpp.compute_power = function()
  local power = stats.shin or stats.kai
  if not power or power == 0 then
   power = ""
  else
   power = power .. "<grey>-"
  end
  return power
end

cpp.compute_power_color = function()
  local powerColor
  local power = stats.shin or stats.kai
  if not power or power == 0 then
   powerColor = ""
  else
   powerColor = "<" .. (power < 25 and "red" or power < 60 and
  "yellow" or power < 75 and
       "green_yellow" or power < 100 and "a_darkgreen" or "a_green") ..">"
  end
  return powerColor
end


cpp.compute_promptstring = function()
 return ("<LightSlateGrey>")..
        (defc.cloak and "c" or "") ..
        (bals.equilibrium and "<white>e<LightSlateGrey>" or "")..
        (bals.balance and "<white>x<LightSlateGrey>" or "")..
        (defc.kola and "k" or "")..
        ((defc.deaf or affs.deafaff) and "d" or "")..
        ((defc.blind or affs.blindaff) and "b" or "")..
        (defc.astralform and "@" or "")..
        (defc.phase and "@" or "")..
        (defc.blackwind and "@" or "")..
        (defc.breath and "<blue>|<LightSlateGrey>b" or "")..
        ("-<grey>")
end

cpp.compute_promptstringorig = function()
 return ("<grey>")..
        (defc.cloak and "c" or "") ..
        (bals.equilibrium and "e" or "")..
        (bals.balance and "x" or "")..
        (defc.kola and "k" or "")..
        ((defc.deaf or affs.deafaff) and "d" or "")..
        ((defc.blind or affs.blindaff) and "b" or "")..
        ((defc.phase or defc.blackwind or defc.astralform) and "@" or "")
end

cpp.compute_diffmana = function()
  return (me.manachange > 0 and "+"..me.manachange or (me.manachange < 0 and me.manachange or ''))
end
cpp.compute_diffhealth = function()
  return (me.healthchange > 0 and "+"..me.healthchange or (me.healthchange < 0 and me.healthchange or ''))
end

cpp.compute_diffmana_paren = function()
  return (me.manachange > 0 and "(+"..me.manachange..")" or (me.manachange < 0 and "("..me.manachange..")" or ''))
end
cpp.compute_diffhealth_paren = function()
  return (me.healthchange > 0 and "(+"..me.healthchange..")" or (me.healthchange < 0 and "("..me.healthchange..")" or ''))
end

cpp.compute_diffmana_bracket = function()
  return (me.manachange > 0 and "[+"..me.manachange.."]" or (me.manachange < 0 and "["..me.manachange.."]" or ''))
end
cpp.compute_diffhealth_bracket = function()
  return (me.healthchange > 0 and "[+"..me.healthchange.."]" or (me.healthchange < 0 and "["..me.healthchange.."]" or ''))
end

svo.cpp.compute_day = function()
  local gmcp = gmcp
  return (gmcp.IRE and ((gmcp.IRE.Time.Update and gmcp.IRE.Time.Update.day) or (gmcp.IRE.Time.List and gmcp.IRE.Time.List.day))) or ""
end

svo.cpp.compute_month = function()
  local gmcp = gmcp
  return (gmcp.IRE and ((gmcp.IRE.Time.Update and gmcp.IRE.Time.Update.month) or (gmcp.IRE.Time.List and gmcp.IRE.Time.List.month))) or ""
end

svo.cpp.compute_year = function()
  local gmcp = gmcp
  return (gmcp.IRE and ((gmcp.IRE.Time.Update and gmcp.IRE.Time.Update.year) or (gmcp.IRE.Time.List and gmcp.IRE.Time.List.year))) or ""
end

cp.definitions = {
  ["@health"]        = "svo.stats.currenthealth",
  ["@mana"]          = "svo.stats.currentmana",
  ["@willpower"]     = "svo.stats.currentwillpower",
  ["@endurance"]     = "svo.stats.currentendurance",
  ["@maxhealth"]     = "svo.stats.maxhealth",
  ["@maxmana"]       = "svo.stats.maxmana",
  ["@maxwillpower"]  = "svo.stats.maxwillpower",
  ["@maxendurance"]  = "svo.stats.maxendurance",
  ["@%health"]       = "svo.cpp.compute_health_percent()",
  ["@%mana"]         = "svo.cpp.compute_mana_percent()",
  ["@%willpower"]    = "svo.cpp.compute_willpower_percent()",
  ["@%endurance"]    = "svo.cpp.compute_endurance_percent()",
  ["@%xp"]           = "svo.stats.nextlevel",
  ["@-%xp"]          = "svo.cpp.compute_reverse_xp()",
  ["@xprank"]        = "svo.stats.xprank",
  ["@defs"]          = "svo.cpp.compute_defs()",
  ["@eqbal"]         = "svo.cpp.compute_eqbal()",
  ["@armbal"]        = "svo.cpp.compute_armbal()",
  ["@prone"]         = "svo.cpp.compute_prone()",
  ["@Prone"]         = "svo.cpp.compute_Prone()",
  ["@@"]             = "svo.cpp.compute_at()",
  ["@power"]         = "svo.cpp.compute_power()",
  ["@promptstring"]  = "svo.cpp.compute_promptstring()",
  ["@promptstringorig"] = "svo.cpp.compute_promptstringorig()",
  ["@diffmana"]     = "svo.cpp.compute_diffmana()",
  ["@diffhealth"]   = "svo.cpp.compute_diffhealth()",
  ["@(diffmana)"]   = "svo.cpp.compute_diffmana_paren()",
  ["@(diffhealth)"] = "svo.cpp.compute_diffhealth_paren()",
  ["@[diffmana]"]   = "svo.cpp.compute_diffmana_bracket()",
  ["@[diffhealth]"] = "svo.cpp.compute_diffhealth_bracket()",
  ["@day"]          = "svo.cpp.compute_day()",
  ["@month"]        = "svo.cpp.compute_month()",
  ["@year"]         = "svo.cpp.compute_year()",
  ["@p"]            = "svo.cpp.compute_pause()",
  ["@slowcuring"]   = "svo.cpp.compute_slowcuring()",
  ["@?:"]           = "svo.cpp.unknown_stats()",
  ["@gametarget"]   = "svo.cpp.compute_gametarget()",
  ["@gametargethp"] = "svo.cpp.compute_gametargethp()",
  ["@dragonhealbal"]    = "svo.cpp.compute_dragonhealbal()",
  ["@timestamp"]     = "svo.cpp.compute_timestamp()",
  ["@servertimestamp"] = "svo.cpp.compute_servertimestamp()",
  ["^1"]             = "svo.cpp.compute_health_colour()",
  ["^2"]             = "svo.cpp.compute_mana_colour()",
  ["^4"]             = "svo.cpp.compute_willpower_colour()",
  ["^5"]             = "svo.cpp.compute_endurance_colour()",
  ["^7"]             = "svo.cpp.compute_power_color()",
  ["^r"]             = "'<a_red>'",
  ["^R"]             = "'<a_darkred>'",
  ["^g"]             = "'<a_green>'",
  ["^G"]             = "'<a_darkgreen>'",
  ["^y"]             = "'<a_yellow>'",
  ["^Y"]             = "'<a_darkyellow>'",
  ["^b"]             = "'<a_blue>'",
  ["^B"]             = "'<a_darkblue>'",
  ["^m"]             = "'<a_magenta>'",
  ["^M"]             = "'<a_darkmagenta>'",
  ["^c"]             = "'<a_cyan>'",
  ["^C"]             = "'<a_darkcyan>'",
  ["^w"]             = "'<a_white>'",
  ["^W"]             = "'<a_darkwhite>'",
  ["^gametarget"]    = "svo.cpp.compute_gametarget_colour()",
}

function cp.adddefinition(tag, func)
  local func = string.format("tostring(%s)", func)

  cp.definitions[tag] = func
  cp.makefunction()
end

function cp.makefunction()
  if not conf.customprompt or not sk.logged_in then return end

  local t = cp.generatetable(conf.customprompt)

  local display, error = loadstring("return table.concat({"..table.concat(t, ", ").."})")
  if display then cp.display = display else
    cp.display = function() return '' end
    debugf("Couldn't compile the custom prompt: %s", error)
  end

  -- set the prompt we require within the game for these tags to work
  if conf.customprompt:find("@gametarget") or conf.customprompt:find("@gametargethp") or conf.customprompt:find("@weaponmastery") or conf.customprompt:find("@servertimestamp") then
    send(sys.ingamecustomprompt, false)

    svo.ingameprompt = tempExactMatchTrigger("Your custom prompt is now:", [[
      svo.deleteAllP()
      if svo.ingameprompt then
        killTrigger(svo.ingameprompt)
        svo.ingameprompt = nil
      end
    ]])
  end
end
-- use the login event, and not systemstart, so we get can set the right prompt in the game
signals.gmcpcharname:connect(cp.makefunction)
-- meanwhile, return nothing
cp.display = function() return '' end

signals.systemstart:connect(function ()
  if not conf.oldcustomprompt or conf.oldcustomprompt == "off" then
    conf.oldcustomprompt = conf.customprompt
  end
end)

function cp.generatetable(customprompt)
  local t = {}
  local ssub = string.sub

  local tags_array = {}
  for def, defv in pairs(cp.definitions) do
    tags_array[#tags_array+1] = {def = def, defv = defv}
  end

  table.sort(tags_array, function(a,b) return #a.def > #b.def end)

  local buffer = ""

  local function add_character(c)
      buffer = buffer .. c
  end

  local function add_buffer()
    if buffer ~= "" then
      t[#t+1] = "'" .. buffer .. "'"
      buffer = ""
    end
  end

  local function add_code(c)
      add_buffer()
      t[#t+1] = c
  end

  while customprompt ~= "" do
    local matched = false

    for i = 1, #tags_array do
      local def = tags_array[i].def

      if ssub(customprompt, 1, #def) == def then
        add_code(tags_array[i].defv)
        customprompt = ssub(customprompt, #def + 1)
        matched = true
        break
      end
    end

    if not matched then
      add_character(ssub(customprompt, 1, 1))
      customprompt = ssub(customprompt, 2)
    end

  end

  add_buffer()

  return t
end

-- import color_table
for color in pairs(color_table) do
  cp.definitions["^"..color] = "'<"..color..">'"
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

-- update serverside prios in general
signals["svo prio changed"]:connect(function()
  if not conf.serverside then return end

  if not sk.priochangetimer then
    sk.priochangetimer = tempTimer(0, function() sk.updateserversideprios() end)
  end
end)

-- update serverside prios with custom dict overrides, ie for health which is not on serverside prios
signals["svo prio changed"]:connect(function(action, balance, newprio, slowcuring)
  if not (conf.serverside and dict[action][balance].onprioswitch) then return end

  dict[action][balance].onprioswitch(newprio, slowcuring)
end)

-- start out with blank prios, so a diff on switch to basic has the right stuff
signals["svo system loaded"]:connect(function()
  sk.priosbeforechange = sk.getblankbeforestateprios()
end)


function sk.sendpriorityswitch(action, balance, raffs, rdefs, cache)
  local isdefence, priority, gamename

  if dict[action][balance].def then
    isdefence = "defence "
    priority = rdefs[action]
  elseif dict[action].aff then
    isdefence = ""
    priority = raffs[action]
  else -- an action that's not an aff or a def - ignore
    debugf("(e!) sk.sendpriorityswitch: quitting, not an aff or a def")
    return
  end

  -- caps at 25, so pool everything after on 25
  if priority > 25 then priority = 25 end

  -- if already in cache at same priority, don't send
  if cache[action] == priority then
    debugf("%s is already on %s, ignoring", action, cache[action])
    return
  else
    cache[action] = priority
  end

  gamename = dict[action].gamename and dict[action].gamename or action

  local command = string.format("priority %s%s %s", isdefence, gamename, priority)

  sendcuring(command)
end

function sk.sendpriorityignore(action, balance, rignoreaffs, rignoredefs, cache)
  local isdefence, priority, gamename

  if dict[action][balance].def then
    isdefence = "defence "
    priority = "reset"
  elseif dict[action].aff then
    isdefence = ""
    priority = 26
  else -- an action that's not an aff or a def - ignore
    debugf("(e!) sk.sendpriorityignore: quitting, not an aff or a def")
    return
  end

  -- if already in cache at same priority, don't send
  if cache[action] == "ignore" then
    debugf("%s is already on %s, ignoring", action, cache[action])
    return
  else
    cache[action] = "ignore"
  end

  gamename = dict[action].gamename and dict[action].gamename or action

  local command = string.format("priority %s%s %s", isdefence, gamename, priority)

  sendcuring(command)
end

function sk.updateserversideprios()
  if not sk.priochangetimer then return end
  sk.updateserverwatch = sk.updateserverwatch or createStopWatch()
  startStopWatch(sk.updateserverwatch)

  -- don't notify of prio changes until the system is loaded, as they can get shuffled around a bit
  if not systemloaded then return end

  local afterstate = sk.getafterstateprios()
  debugf("sk.updateserverwatch sk.getafterstateprios: %s", getStopWatchTime(sk.updateserverwatch))

  local basictableindexdiff, valid_sync_action = basictableindexdiff, valid_sync_action

  for balance, data in pairs(sk.priosbeforechange) do
    if balance == "slowcuring" then
      sk.priochangecache[balance] = sk.priochangecache[balance] or {}
      local priochangecache = sk.priochangecache[balance]

      -- make the diff of snapshots
      local diffslow = basictableindexdiff(data.data, afterstate[balance].newdata)
      -- split the action_balance actions into separate balances
      local diff = sk.splitbals(diffslow)

      -- get the new list of prios, sorted in importance
      local neworderslow = prio.getsortedlist(balance)
      -- split the action_balance actions into separate balances
      local neworderbals = sk.splitbals(neworderslow)

      -- if not in slowcuring mode, switch to slowcuring prios first
      local needtoswitch, needtoswitchback = false, false
      if not sys.sync then
        needtoswitch = true
      end

      for balance, neworder in pairs(neworderbals) do
        if diff[balance] then
          priochangecache[balance] = priochangecache[balance] or {}
          local affs, defs, ignoreaffs, ignoredefs = sk.splitdefs(balance, neworder)
          local raffs, rdefs, rignoreaffs, rignoredefs = {}, {}, {}, {}
          for i = 1, #affs do raffs[affs[i]] = i end
          for i = 1, #defs do rdefs[defs[i]] = i end
          for i = 1, #ignoreaffs do rignoreaffs[ignoreaffs[i]] = i end
          for i = 1, #ignoredefs do rignoredefs[ignoredefs[i]] = i end

          -- update for the changes
          for _, action in pairs(diff[balance]) do
            -- check if this is something actually on prios. an aff could be ignored, a def not on keepup
            if raffs[action] or rdefs[action] then
              if needtoswitch then sendc("curingset switch slowcuring"); needtoswitch = false; needtoswitchback = true end

              sk.sendpriorityswitch(action, balance, raffs, rdefs, priochangecache[balance])
            elseif rignoreaffs[action] or rignoredefs[action] then
              if needtoswitch then sendc("curingset switch slowcuring"); needtoswitch = false; needtoswitchback = true end

              sk.sendpriorityignore(action, balance, rignoreaffs, rignoredefs, priochangecache[balance])
            end
          end
        end
      end

      if needtoswitchback then
        sendc("curingset switch normal")
      end
    else
      sk.priochangecache[balance] = sk.priochangecache[balance] or {}

      -- make the diff of snapshots
      local diff = basictableindexdiff(data.data, afterstate[balance].newdata)
      -- if next(diff) then debugf("%s diff: %s", balance, pl.pretty.write(diff)) end
      -- get the new list of prios, sorted in importance
      local neworder = prio.getsortedlist(balance)
      local affs, defs, ignoreaffs, ignoredefs = sk.splitdefs(balance, neworder)
      local raffs, rdefs, rignoreaffs, rignoredefs = {}, {}, {}, {}
      for i = 1, #affs do raffs[affs[i]] = i end
      for i = 1, #defs do rdefs[defs[i]] = i end
      for i = 1, #ignoreaffs do rignoreaffs[ignoreaffs[i]] = i end
      for i = 1, #ignoredefs do rignoredefs[ignoredefs[i]] = i end

      -- if not in slowcuring mode, switch to slowcuring prios first
      local needtoswitch, needtoswitchback = false, false
      if sys.sync then
        needtoswitch = true
      end

      -- update for the changes
      for _, action in pairs(diff) do
        -- check if this is something actually on prios. an aff could be ignored, a def not on keepup
        if raffs[action] or rdefs[action] then
          if needtoswitch then sendc("curingset switch normal"); needtoswitch = false; needtoswitchback = true end

          sk.sendpriorityswitch(action, balance, raffs, rdefs, sk.priochangecache[balance])
        elseif rignoreaffs[action] or rignoredefs[action] then
          if needtoswitch then sendc("curingset switch normal"); needtoswitch = false; needtoswitchback = true end

          sk.sendpriorityignore(action, balance, rignoreaffs, rignoredefs, sk.priochangecache[balance])
        end
      end

      if needtoswitchback then
        sendc("curingset switch slowcuring")
      end
    end
  end

  sk.priochangetimer = nil

  -- save new state for next change
  debugf("sk.updateserverwatch sk.getbeforestateprios: %s", getStopWatchTime(sk.updateserverwatch))
  sk.priosbeforechange = sk.getbeforestateprios()

  debugf("sk.updateserverwatch: %s", stopStopWatch(sk.updateserverwatch))
end

-- splits slowcuring prios by balance
function sk.splitbals(list)
  local balances, valid_sync_action = {}, valid_sync_action

  for i = 1, #list do
    local action_balance = list[i]

    local _, action, balance = valid_sync_action(action_balance)
    balances[balance] = balances[balance] or {}
    local balancet = balances[balance]
    balancet[#balancet+1] = action
  end

  return balances
end

-- returns true if the given action should be ignored on serverside, which it should be if:
-- it's ignored in system in general
-- it's handled by Svof instead of serverside
-- it's not on keepup
-- if we're in defup and it's not on defup
-- its custom onservereignore function returns true
function sk.shouldignoreserverside(action)
  return conf.serverside and (
    ignore[action] or
    not serverignore[action] or
    (not sys.deffing and defkeepup[defs.mode][action] == false) or
    (sys.deffing and defdefup[defs.mode][action] == false) or
    (dict[action].onservereignore and dict[action].onservereignore())
  ) -- false so afflictions are okay, which are a nil
end
shouldignoreserverside = sk.shouldignoreserverside

function sk.handleserversideswitch()
  if not sk.priochangetimer then
    sk.priochangetimer = tempTimer(0, function() sk.updateserversideprios() end)
  end
end

function sk.handleserversideswitch_keepup(defmode, action)
  if not dict[action] then return end

  -- don't do anything for the current defences mode
  if defmode ~= defs.mode then return end

  if not sk.priochangetimer then
    sk.priochangetimer = tempTimer(0, function() sk.updateserversideprios() end)
  end
end

-- splits defs up into another list and removes them from the affs one
-- also remove uncurable actions that aren't affs, and defs that
-- aren't on defup or keepup
function sk.splitdefs(balance, list)
  local defs, disableddefs, disabledaffs, dict, defmode, tremove = {}, {}, {}, dict, svo.defs.mode, table.remove

  -- prune list to only be a list of affs, save defs and disable defs into another list
  -- iterate backwards, so we can remove items from the list safely
  for i = #list, 1, -1 do
    local action = list[i]

    -- take care of defs
    if dict[action][balance].def then
      -- check that it's not undeffable in-game and on keepup
      if not dict[action][balance].undeffable and ((sys.deffing and defdefup[defmode][action]) or (not sys.deffing and defkeepup[defmode][action])) and not sk.shouldignoreserverside(action) then
        defs[#defs+1] = tremove(list, i)
      -- if it's off keepup, send to another list so those defs get ignored
      elseif not dict[action][balance].undeffable and sk.shouldignoreserverside(action) then
        disableddefs[#disableddefs+1] = tremove(list, i)
      else
        -- make sure to remove a def either way
        tremove(list, i)
      end
    else
      -- remove if not priotisable
      if dict[action][balance].uncurable or dict[action][balance].irregular then
        tremove(list, i)
      -- if handled by svo, or handled by serverside and on normal ignore, ignore
      elseif dict[action].aff and sk.shouldignoreserverside(action) then
        disabledaffs[#disabledaffs+1] = tremove(list, i)
      end
    end
  end

  -- since we were iterating lists backwards, sort defs and disableddefs
  local ordereddefs, ordereddisableddefs, ordereddisabledaffs = {}, {}, {}
  for i = #defs, 1, -1 do ordereddefs[#ordereddefs+1] = defs[i] end
  for i = #disableddefs, 1, -1 do ordereddisableddefs[#ordereddisableddefs+1] = disableddefs[i] end
  for i = #disabledaffs, 1, -1 do ordereddisabledaffs[#ordereddisabledaffs+1] = disabledaffs[i] end

  return list, ordereddefs, ordereddisabledaffs, ordereddisableddefs
end


-- gets a snapshot of priorities, skipping actions that should be ignored
function sk.getbeforestateprios()
  local beforestate = {}
  local importables = {
    "herb",
    "smoke",
    "salve",
    "sip",
    "purgative",
    "physical",
    "moss",
    "misc",
    "slowcuring",
  }
  local make_prio_tablef = make_prio_tablef

  for _, balance in ipairs(importables) do
    beforestate[balance] = {}

    if balance == "slowcuring" then
      -- get the before state for diffing
      local data = make_sync_prio_tablef("%s_%s", function(action)
        return not sk.shouldignoreserverside(action)
      end, { focus = true })
      beforestate[balance] = {data = data}
    else
      -- get the before state for diffing
      local data = make_prio_tablef(balance, function(action)
        return not sk.shouldignoreserverside(action)
      end)
      beforestate[balance] = {data = data}
    end
  end

  return beforestate
end

-- gets a blanked out state of before prios - useful if all of them need to be reset serverside
function sk.getblankbeforestateprios()
  local beforestate = {}
  local importables = {
    "herb",
    "smoke",
    "salve",
    "sip",
    "purgative",
    "physical",
    "moss",
    "misc",
    "slowcuring",
  }
  local make_prio_tablef = make_prio_tablef

  for _, balance in ipairs(importables) do
    beforestate[balance] = {}

    if balance == "slowcuring" then
      -- get the before state for diffing
      local data = make_sync_prio_tablef("%s_%s", nil, { focus = true })
      -- set all prios to negative, so things get set or ignored serverside properly
      local nullify, c = {}, -1
      for k,v in pairs(data) do nullify[c] = v; c = c - 1 end
      beforestate[balance] = {data = nullify}
    else
      -- get the before state for diffing
      local data = make_prio_tablef(balance)
      -- set all prios to negative, so things get set or ignored serverside properly
      local nullify, c = {}, -1
      for k,v in pairs(data) do nullify[c] = v; c = c - 1 end
      beforestate[balance] = {data = nullify}
    end
  end

  return beforestate
end

function sk.getafterstateprios()
  local afterstate = {}
  local importables = {
    "herb",
    "smoke",
    "salve",
    "sip",
    "purgative",
    "physical",
    "moss",
    "misc",
    "slowcuring",
  }
  local make_prio_tablef = make_prio_tablef

  for _, balance in ipairs(importables) do
    afterstate[balance] = {}

    if balance == "slowcuring" then
      -- get the new state
      local newdata = make_sync_prio_tablef("%s_%s", function(action)
        return not sk.shouldignoreserverside(action)
      end, { focus = true })
      -- create an action - prio table for retrieval of location using diffs
      local action_prio = {}
      for k,v in pairs(newdata) do action_prio[v] = k end
      afterstate[balance] = {newdata = newdata, action_prio = action_prio}
    else
      -- get the new state
      local newdata = make_prio_tablef(balance, function(action)
        return not sk.shouldignoreserverside(action)
      end)
      -- create an action - prio table for retrieval of location using diffs
      local action_prio = {}
      for k,v in pairs(newdata) do action_prio[v] = k end
      afterstate[balance] = {newdata = newdata, action_prio = action_prio}
    end
  end

  return afterstate
end

function sk.notifypriodiffs(beforestate, afterstate)
  local basictableindexdiff = basictableindexdiff

  -- don't notify of prio changes until the system is loaded, as they can get shuffled around a bit
  if not systemloaded then return end

  for balance, data in pairs(beforestate) do
    if balance == "slowcuring" then
      -- make the diff of snapshots
      local diff = basictableindexdiff(data.data, afterstate[balance].newdata)
      local valid_sync_action = valid_sync_action

      -- now only notify for the differences
      for _, a in pairs(diff) do
        local _, action, balance = valid_sync_action(a)
        raiseEvent("svo prio changed", action, balance, afterstate[balance].action_prio[a], "slowcuring")
      end
    else
      -- make the diff of snapshots
      local diff = basictableindexdiff(data.data, afterstate[balance].newdata)

      -- notify only for the changes
      for _, a in pairs(diff) do
        raiseEvent("svo prio changed", a, balance, afterstate[balance].action_prio[a])
      end
    end
  end
end


-- returns an alphabetically sorted indexed list of all actions serverside can do
function sk.getallserversideactions()
  local type = type

  local actions = {}
  for action, balances in pairs(dict) do
    for balance, data in pairs(balances) do
      if type(data) == "table" and balance ~= "waitingfor" and balance ~= "aff" and balance ~= "gone" and balance ~= "happened" and not data.uncurable and not data.undeffable then
        actions[action] = true
      end
    end
  end

  local actionslist = {}
  for k,v in pairs(actions) do
    actionslist[#actionslist+1] = k
  end

  table.sort(actionslist)

  return actionslist
end

--[[ register all signals needed for this to work ]]

signals.sync:connect(function ()
  if not conf.serverside then return end

  if sys.sync then
    sendc("curingset switch slowcuring")
  else
    sendc("curingset switch normal")
  end
end)

-- vconfig serverside
signals["svo config changed"]:connect(function(config)
  if config ~= "serverside" then return end

  if conf.serverside then
    sk.priochangecache = { special = {} }
    -- sync everything
    sk.priosbeforechange = sk.getblankbeforestateprios()
    sendcuring("PRIORITY RESET")
    sk.priochangetimer = true
    sk.updateserversideprios()
    -- sync all special things like health
    for action, actiont in pairs(dict) do
      for balance, balancet in pairs(actiont) do
        if type(balancet) == "table" and balancet.onprioswitch then
          balancet.onprioswitch()
        end
      end
    end

    -- initial sync of some config options.
    local option
    if conf.healthaffsabove == true then option = "on"
    elseif conf.healthaffsabove == false then option = "off"
    else
      option = conf.healthaffsabove
    end

    sendcuring("healthaffsabove "..option)
    if conf.mosshealth == true then option = "on"
    elseif conf.mosshealth == false then option = "off"
    else
      option = conf.mosshealth
    end

    sendcuring("mosshealth "..option)
    if conf.mossmana == true then option = "on"
    elseif conf.mossmana == false then option = "off"
    else
      option = conf.mossmana
    end

    sendcuring("mossmana "..option)

    if conf.keepup then
      sendcuring("defences on")
    else
      sendcuring("defences off")
    end

    sk.togglefocusserver()
    sk.toggleclotserver()
    sk.toggleinsomniaserver()

    if sk.canclot() and conf.clot then sendcuring("clot on") else sendcuring("clot off") end
    sendcuring("clotat "..conf.bleedamount)

    if not serverignore.healhealth then
      sendcuring("siphealth 0")
      sk.priochangecache.special.healhealth = 0
    elseif serverignore.healhealth then
      sendcuring("siphealth "..conf.siphealth)
      sk.priochangecache.special.healhealth = conf.siphealth
    end

    if not serverignore.healmana then
      sendcuring("sipmana 0")
      sk.priochangecache.special.healmana = 0
    elseif serverignore.healmana then
      sendcuring("sipmana "..conf.sipmana)
      sk.priochangecache.special.healmana = conf.sipmana
    end

    if conf.curemethod == "transonly" then
      sendcuring("transmutation on")
    elseif conf.curemethod == "conconly" then
      sendcuring("transmutation off")
    elseif conf.curemethod == "prefertrans" then
      sendcuring("transmutation on")
      echof("Setting in-game curemethod to 'transmutation cures only', as serverside doesn't support mixed cures.")
    elseif conf.curemethod == "preferconc" then
       sendcuring("transmutation off")
       echof("Setting in-game curemethod to 'concoctions cures only', as serverside doesn't support mixed cures.")
    end

    sendcuring("manathreshold "..conf.manause)
  end
end)

signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "healthaffsabove") then return end

  if conf.healthaffsabove == true then option = "on"
  elseif conf.healthaffsabove == false then option = "off"
  else
    option = conf.healthaffsabove
  end

  sendcuring("healthaffsabove "..option)
end)
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "mosshealth") then return end

  if conf.mosshealth == true then option = "on"
  elseif conf.mosshealth == false then option = "off"
  else
    option = conf.mosshealth
  end

  sendcuring("mosshealth "..option)
end)
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "mossmana") then return end

  if conf.mossmana == true then option = "on"
  elseif conf.mossmana == false then option = "off"
  else
    option = conf.mossmana
  end

  sendcuring("mossmana "..option)
end)
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "clot") then return end

  if sk.canclot() and conf.clot and not sk.clotting_on_serverside then
    sendcuring("clot on")
    sk.clotting_on_serverside = true
  elseif not (sk.canclot() and conf.clot) and sk.clotting_on_serverside then
    sendcuring("clot off")
    sk.clotting_on_serverside = false
  end
end)

-- healhealth / siphealth
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "siphealth") then return end

  if not serverignore.healhealth and sk.priochangecache.special.healhealth ~= 0 then
    sendcuring("siphealth 0")
    sk.priochangecache.special.healhealth = 0
  elseif serverignore.healhealth and sk.priochangecache.special.healhealth ~= conf.siphealth then
    sendcuring("siphealth "..conf.siphealth)
    sk.priochangecache.special.healhealth = conf.siphealth
  end
end)
signals["svo serverignore changed"]:connect(function(config)
  if not (conf.serverside and config == "healhealth") then return end

  if not serverignore.healhealth and sk.priochangecache.special.healhealth ~= 0 then
    sendcuring("siphealth 0")
    sk.priochangecache.special.healhealth = 0
  elseif serverignore.healhealth and sk.priochangecache.special.healhealth ~= conf.siphealth then
    sendcuring("siphealth "..conf.siphealth)
    sk.priochangecache.special.healhealth = conf.siphealth
  end
end)

-- healmana / sipmana
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "sipmana") then return end

  if not serverignore.healmana and sk.priochangecache.special.healmana ~= 0 then
    sendcuring("sipmana 0")
    sk.priochangecache.special.healmana = 0
  elseif serverignore.healmana and sk.priochangecache.special.healmana ~= conf.sipmana then
    sendcuring("sipmana "..conf.sipmana)
    sk.priochangecache.special.healmana = conf.sipmana
  end
end)
signals["svo serverignore changed"]:connect(function(config)
  if not (conf.serverside and config == "healmana") then return end

  if not serverignore.healmana and sk.priochangecache.special.healmana ~= 0 then
    sendcuring("sipmana 0")
    sk.priochangecache.special.healmana = 0
  elseif serverignore.healmana and sk.priochangecache.special.healmana ~= conf.sipmana then
    sendcuring("sipmana "..conf.sipmana)
    sk.priochangecache.special.healmana = conf.sipmana
  end
end)

-- bleedamount
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "bleedamount") then return end

  sendcuring("clotat "..conf.bleedamount)
end)

-- manause
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "manause") then return end

  sendcuring("manathreshold "..conf.manause)
end)

-- curemethod
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "curemethod" and not logging_in) then return end

  if conf.curemethod == "transonly" then
    sendcuring("transmutation on")
  elseif conf.curemethod == "conconly" then
    sendcuring("transmutation off")
  elseif conf.curemethod == "prefertrans" then
    sendcuring("transmutation on")
    echof("Setting in-game curemethod to 'transmutation cures only', as serverside doesn't support mixed cures.")
  elseif conf.curemethod == "preferconc" then
     sendcuring("transmutation off")
     echof("Setting in-game curemethod to 'concoctions cures only', as serverside doesn't support mixed cures.")
  end
end)

-- pause
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "paused" and not logging_in) then return end

  -- send right away, so chained commands are done in proper order
  if conf.paused then
    send("curing off")
  else
    send("curing on")
  end
end)

-- keepup
signals["svo config changed"]:connect(function(config)
  if not (conf.serverside and config == "keepup" and not logging_in) then return end

  if conf.keepup then
    sendcuring("defences on")
  else
    sendcuring("defences off")
  end
end)

signals["svo ignore changed"]:connect(sk.handleserversideswitch)
signals["svo ignore changed"]:connect(sk.handleserversideswitch_keepup)
signals["svo keepup changed"]:connect(sk.handleserversideswitch)
signals["svo keepup changed"]:connect(sk.handleserversideswitch_keepup)
signals["svo serverignore changed"]:connect(sk.handleserversideswitch)
signals["svo serverignore changed"]:connect(sk.handleserversideswitch_keepup)
signals["svo switched defence mode"]:connect(sk.handleserversideswitch)
signals["svo done defup"]:connect(sk.handleserversideswitch)

-- setup the block if serverside isn't on at load
signals["svo system loaded"]:connect(function()
  if not conf.serverside then
    signals["svo ignore changed"]:block(sk.handleserversideswitch)
    signals["svo ignore changed"]:block(sk.handleserversideswitch_keepup)
    signals["svo keepup changed"]:block(sk.handleserversideswitch)
    signals["svo keepup changed"]:block(sk.handleserversideswitch_keepup)
    signals["svo serverignore changed"]:block(sk.handleserversideswitch)
    signals["svo serverignore changed"]:block(sk.handleserversideswitch_keepup)
    signals["svo switched defence mode"]:block(sk.handleserversideswitch)
    signals["svo done defup"]:block(sk.handleserversideswitch)
  end
end)

-- toggle appropriately upon vconfig changed
signals["svo config changed"]:connect(function(config)
  if config ~= "serverside" then return end

  if conf.serverside then
    signals["svo ignore changed"]:unblock(sk.handleserversideswitch)
    signals["svo ignore changed"]:unblock(sk.handleserversideswitch_keepup)
    signals["svo keepup changed"]:unblock(sk.handleserversideswitch)
    signals["svo keepup changed"]:unblock(sk.handleserversideswitch_keepup)
    signals["svo serverignore changed"]:unblock(sk.handleserversideswitch)
    signals["svo serverignore changed"]:unblock(sk.handleserversideswitch_keepup)
    signals["svo switched defence mode"]:unblock(sk.handleserversideswitch)
    signals["svo done defup"]:unblock(sk.handleserversideswitch)
  else
    signals["svo ignore changed"]:block(sk.handleserversideswitch)
    signals["svo ignore changed"]:block(sk.handleserversideswitch_keepup)
    signals["svo keepup changed"]:block(sk.handleserversideswitch)
    signals["svo keepup changed"]:block(sk.handleserversideswitch_keepup)
    signals["svo serverignore changed"]:block(sk.handleserversideswitch)
    signals["svo serverignore changed"]:block(sk.handleserversideswitch_keepup)
    signals["svo switched defence mode"]:block(sk.handleserversideswitch)
    signals["svo done defup"]:block(sk.handleserversideswitch)
  end
end)


-- if we've got cadmus, and have one of of the me.cadmusaffs afflictions, then we should focus
function sk.canfocus()
  -- check if we haven't got cadmus
  if not affs.cadmus then return true end

  -- if we do, and focus with cadmus is on, check if any of the affs we've got allow us to focus
  if conf.focuswithcadmus then
    -- iterate aff list, as that'll be smaller most of the time than cadmusaffs
    for aff in pairs(affs) do
      if me.cadmusaffs[aff] == true then return true end
    end
  end

  return true
end

function sk.togglefocusserver()
  if not (conf.serverside and sk.logged_in) then return end

  if sk.canfocus() and conf.focus and not sk.priochangecache.special.focustoggle then
    sendcuring("focus on")
    sk.priochangecache.special.focustoggle = true
  elseif (not conf.focus or (conf.focus and not sk.canfocus())) and sk.priochangecache.special.focustoggle then
    sendcuring("focus off")
    sk.priochangecache.special.focustoggle = false
  end
end
signals.svogotaff:connect(sk.togglefocusserver)
-- use after prompt processing, not lost aff, so afflictions getting removed don't spam-toggle
signals.after_prompt_processing:connect(sk.togglefocusserver)
signals["svo config changed"]:connect(sk.togglefocusserver)

function sk.canclot()
  if (affs.corrupted and stats.currenthealth < sys.corruptedhealthmin) then
    return false
  else
    return true
  end
end

function sk.toggleclotserver()
  if not conf.serverside then return end

  if sk.canclot() and conf.clot and not sk.clotting_on_serverside then
    sendcuring("clot on")
    sk.clotting_on_serverside = true
  elseif not (sk.canclot() and conf.clot) and sk.clotting_on_serverside then
    sendcuring("clot off")
    sk.clotting_on_serverside = false
  end
end
-- use after prompt processing, not lost aff, so afflictions getting removed don't spam-toggle
signals.svogotaff:connect(sk.toggleclotserver)
signals.after_prompt_processing:connect(sk.toggleclotserver)


function sk.toggleinsomniaserver()
  if not (conf.serverside and sk.logged_in) then return end

  if conf.insomnia and not sk.priochangecache.special.insomniatoggle then
    sendcuring("insomnia on")
    sk.priochangecache.special.insomniatoggle = true
  elseif not conf.insomnia and sk.priochangecache.special.insomniatoggle then
    sendcuring("insomnia off")
    sk.priochangecache.special.insomniatoggle = false
  end
end
signals["svo config changed"]:connect(sk.toggleinsomniaserver)

--


function setupserverside()
  if not conf.serverside then return end

  sendc("curingset new normal")
  sendc("curingset new slowcuring")

  if serversidesetup then killTimer(serversidesetup) end
  serversidesetup = tempTimer(5+getping(), function()
    serversidesetup = nil
  end)
end
signals.charname:connect(setupserverside)
signals.gmcpcharname:connect(setupserverside)

function hitcuringsetlimit()
  if not serversidesetup then return end

  if not svo.conf.serverside then return end

  echo("\n")
  echofn("You don't have enough curingset slots to enable serverside use - Svof requires two. View your curingsets with ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink("CURINGSET LIST", 'send"curingset list"', "CURINGSET LIST", true)
  setUnderline(false)
  echo(" and delete some with ")
  setUnderline(true)
  echoLink("CURINGSET DELETE", 'printCmdLine"curingset delete "', "CURINGSET DELETE", true)
  setUnderline(false)
  echo(".\n")

  tntf_set("serverside", "off", true)
end

function hitaliaslimit()
  if not serversidesetup then return end

  if not svo.conf.serverside then return end

  echo("\n")
  echofn("You haven't got enough space for Svof's two serverside aliases - view list with ")
  setFgColor(unpack(getDefaultColorNums))
  setUnderline(true)
  echoLink("ALIAS LIST", 'send"alias list"', "ALIAS LIST", true)
  setUnderline(false)
  echo(" and delete some with ")
  setUnderline(true)
  echoLink("CLEARALIAS", 'printCmdLine"clearalias "', "CLEARALIAS", true)
  setUnderline(false)
  echo(".\n")

  tntf_set("serverside", "off", true)
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.


--[[
things to optimize: only do label updates on prompt
handling multiple rooms ideas:
 * draw a far-away label saying "also in area at '%s': blah, blah"
   -> can't work yet, because calculating a possible location would be a pain
 * put names in every room
   -> looks ugly in this combination: http://img7.imagebanana.com/img/oshg8lw5/Selection_037.png
 * label by single letters for groups, with only the rightmost room having the full list of names with letter) prepended
]]

-- area = {labels}
local labels = {}

-- default to numerals when we run out
-- while defining this as a function would be nicer, it's easier for most people to mod if it's in this format
local multiplegroups = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"}

conf.peopletracker = type(conf.peopletracker) == 'nil' and true or conf.peopletracker
config.setoption("peopletracker", {
  type = "boolean",
  onenabled = function ()
    if not deleteMapLabel or not createMapLabel then
      echof("I'm sorry, but your Mudlet is too old and can't make labels on the map yet - update it!")
      conf.peopletracker = false
      raiseEvent("svo config changed", "peopletracker")
      return
    end

    echof("People tracker <0,250,0>enabled%s.", getDefaultColor())
  end,
  ondisabled = function () sys.clean_old_labels() echof("People tracker <250,0,0>disabled%s.", getDefaultColor()) end,
  installstart = function () conf.peopletracker = true end,
})

conf.clearlabels = type(conf.clearlabels) == 'nil' and true or conf.clearlabels
config.setoption("clearlabels", {
  type = "boolean",
  onenabled = function () signals.newarea:connect(sys.clear_labels) echof("<0,250,0>Will%s automatically clear map labels that are surrounded by ().", getDefaultColor()) end,
  ondisabled = function ()signals.newarea:disconnect(sys.clear_labels) echof("<250,0,0>Won't%s automatically clear map labels that are surrounded by ().", getDefaultColor()) end,
  installstart = function () conf.clearlabels = true end,
})

conf.labelsfont = type(conf.labelsfont) == 'nil' and 10 or conf.labelsfont
config.setoption("labelsfont", {
  type = "number",
  onset = function () sys.update_people_labels() echof("Labels set to draw at %dpt.", conf.labelsfont) end,
  installstart = function () conf.labelsfont = 10 end,
})

conf.labelcolor = conf.labelcolor or "white"
conf.maxdupes = conf.maxdupes or 20
config.setoption("labelcolor", {
  type = "string",
  vconfig2string = true,
  check = function (what)
    if color_table[what] then return true end
  end,
  onshow = function (defaultcolour)
    fg("gold")
    echoLink("ppl: ", "", "svo People Tracker", true)
    fg(defaultcolour) echo("People tracker ")
    fg("a_cyan") echoLink((conf.peopletracker and "on" or "off"), "svo.config.set('peopletracker', "..(conf.peopletracker and "false" or "true")..", true)", "Click to "..(conf.peopletracker and "disable" or "enable").." people tracking on the map", true)
    fg(defaultcolour) echo("; using")
    fg(conf.labelcolor or "a_cyan") echoLink(" "..(conf.labelcolor or '?'), "printCmdLine'vconfig labelcolor '", "Click to change the color", true)
    fg(defaultcolour) echo(" map labels (")
    fg("a_cyan") echoLink("view all", "showColors()", "Click to view possible color names that you can use for customizing the label colors", true)
    fg(defaultcolour)
    echo("); font size is ")
    fg("a_cyan") echoLink(tostring(conf.labelsfont), "printCmdLine'vconfig labelsfont '", "Click to set the font size for peopletracker labels", true)
    echo(".\n")
  end,
  onset = function ()
    local r,g,b = unpack(color_table[conf.labelcolor])
    sys.update_people_labels()
    echof("Okay, will color the map labels in <%s,%s,%s>%s%s now.", r,g,b, conf.labelcolor, getDefaultColor())
  end,
  installstart = function ()
    conf.labelcolor = "blue"
  end
})

-- check for old Mudlet versions
if not deleteMapLabel or not createMapLabel then
  echof("I'm sorry, but your Mudlet is too old and can't make labels on the map yet - update it!")
  return
end

sys.clean_old_labels = function()
  for areanum, arealabels in pairs(labels) do
    for _, label in pairs(arealabels) do
      deleteMapLabel(areanum, label)
    end
  end
  labels = {}
end
signals.sysexitevent:connect(sys.clean_old_labels)

sys.clear_labels = function()
  if not mmp then return end
  local function clearlabels(areaid)
    local t = getMapLabels(areaid)
    if type(t) ~= "table" then return end

    local starts, ends = string.starts, string.ends
    for labelid, text in pairs(t) do
      if starts(text, '(') and ends(text, ')') then
        deleteMapLabel(areaid, labelid)
      end
    end
  end

  for areaid in pairs(mmp.areatabler or {}) do
    clearlabels(areaid)
  end
end

if conf.clearlabels then
  signals.newarea:connect(sys.clear_labels)
end

sys.update_people_labels = function ()
  -- drawwatch = drawwatch or createStopWatch()
  -- startStopWatch(drawwatch)

  local s,m = pcall(function()
    if not mmp then return end
    -- build a 'location = people' reverse map
    local r = {}
    -- keeps track at which index of multiplegroups are we at
    local multiplescount = 1

    local fr,fg,fb = unpack(color_table[conf.labelcolor or "white"])
    local br,bg,bb = unpack(color_table.black)

    for k,v in pairs(mmp.pdb) do
      if mmp.pdb_lastupdate[k] then
        r[v] = r[v] or {}; r[v][#r[v]+1] = k
      end
    end

    sys.clean_old_labels()
    if not conf.peopletracker or not mmp.pdb_lastupdate or not mmp.roomexists(mmp.currentroom) then return end

    local getRoomArea, createMapLabel, getRoomCoordinates, concat, sort = getRoomArea, createMapLabel, getRoomCoordinates, table.concat, table.sort

    -- if we have a unique location, draw fancy labels in all rooms on 60% opacity
    for room, persons in pairs(r) do
      sort(persons)
      local ids = mmp.getnums(room, true)

      -- multiples? special case then. Current method implemented is #3
      if ids and #ids >1 and #ids <= conf.maxdupes then
        -- make a table of roomid = {x,y,z}
        -- in a separate variable, track the right-most room ID and x coordinate per-Z level
        local coords, rightmost = {}, {}
        for _, exactroomid in pairs(ids) do
          coords[exactroomid] = {getRoomCoordinates(exactroomid)}
          coords[exactroomid][4] = getRoomArea(exactroomid)

          if not rightmost[coords[exactroomid][3]] or
            coords[exactroomid][1] >= rightmost[coords[exactroomid][3]][1] then -- >= so rightmostroom is set at least once

            rightmost[coords[exactroomid][3]] =
              {coords[exactroomid][1], exactroomid} -- we don't account for the Y coordinate if the X's are the same atm, though
          end
        end

        -- now, draw!
        for roomid, l in pairs(coords) do
          local area = l[4]
          labels[area] = labels[area] or {}

          if rightmost[l[3]] and roomid == rightmost[l[3]][2] then
            -- doesn't account for multiplescount overflowing atm
            labels[area][#labels[area]+1] = createMapLabel(area, '('..multiplegroups[multiplescount].." "..concat(persons, ", ")..')', l[1],l[2],l[3], fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
          else
            labels[area][#labels[area]+1] = createMapLabel(area, '('..multiplegroups[multiplescount]..')', l[1],l[2],l[3], fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
          end
        end
        multiplescount = multiplescount +1

      elseif ids and #ids == 1 then
        local x,y,z = getRoomCoordinates(ids[1])
        local area = getRoomArea(ids[1])

        if area then -- somehow area can still be returned as nil
          labels[area] = labels[area] or {}

          labels[area][#labels[area]+1] = createMapLabel(area, '('..concat(persons, ", ")..')', x,y,z, fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
        end
      end
    end
  end)

  if not s then
    echoLink("(e!)", string.format("echo([=[The problem was: %q]=])", m), 'Oy - there was a problem with the peopletracker. Click on this link and submit a bug report with what it says.')
  end

  -- echof("update took %s", stopStopWatch(drawwatch))
end

signals["mmapper updated pdb"]:connect(function()
  if isPrompt() then
    sys.update_people_labels()
  else
    sk.onprompt_beforeaction_add("update_labels", sys.update_people_labels)
  end
end)

signals.quit:connect(sys.clean_old_labels)
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

dl_version = "1.0"

dl_list = {}
local limbs = {"head", "torso", "rightarm", "leftarm", "rightleg", "leftleg"}
local hittable = {}
dl_prep_at = 3
dl_break_at = 4

enableTrigger("svo Dragon limbcounter")
enableAlias("svo Dragon limbcounter")

-- Their blah, blah, blah are also prepped.
local function get_other_prepped(t, limbhit)
  local s = {}
  for i = 1, #limbs do
    if limbs[i] ~= limbhit and t[limbs[i]] == dl_prep_at then s[#s+1] = limbs[i] end
  end

  if #s == 0 then return ""
  else return string.format(" Their %s %s also prepped.", concatand(s), (#s == 1 and "is" or "are")) end
end

function svo.dl_ignore()
  if not next(hittable) then return end
  table.remove(select(2, next(hittable)))
end


function sk.dl_checklimbcounter()
  -- make the announces work with a singleprompt
  local echof = itf
  moveCursor(0, getLineNumber())

  -- we'll only ever have one name here so far
  local who, t = next(hittable)
  local where
  for i = 1, #t do
    local dmg
    where, dmg = next(t[i])
    dl_list[who][where] = dl_list[who][where] + dmg
    raiseEvent("svo limbcounter hit", who, where)
  end

  if not where then
    echof("Failed to connect.%s", get_other_prepped(dl_list[who], ""))
  else
    if dl_list[who][where] >= dl_break_at then
      echof("%s's %s broke.%s", who, where, get_other_prepped(dl_list[who], where))
      dl_list[who][where] = 0
    elseif dl_list[who][where] >= dl_prep_at then
      echof("%s's %s is prepped.%s", who, where, get_other_prepped(dl_list[who], where))
    else
      echof("%s's %s is now at %s/%s.%s", who, where, dl_list[who][where], dl_break_at, get_other_prepped(dl_list[who], where))
    end
  end

  hittable = {}
  disableTrigger("svodl Don't register")
  signals.before_prompt_processing:disconnect(sk.dl_checklimbcounter)
end

function dl_hit(who, where)
  dl_list[who] = dl_list[who] or {head = 0, torso = 0, rightarm = 0, leftarm = 0, rightleg = 0, leftleg = 0}
  local where = where:gsub(" ", "")
  lasthit = who

  hittable[who] = hittable[who] or {}
  hittable[who][#hittable[who] + 1] = {[where] = 1}
  signals.before_prompt_processing:connect(sk.dl_checklimbcounter)
  enableTrigger("svodl Don't register")
end

function dl_reset(whom)
  if not defc.dragonform then return end

  if whom then whom = string.title(whom) end

  local t = {
    h = "head",
    t = "torso",
    rl = "rightleg",
    ll = "leftleg",
    ra = "rightarm",
    la = "leftarm",
  }

  if whom == "All" then
    dl_list = {}
    echof("Reset everyone's limb status.")
  elseif not whom and lasthit then
    dl_list[lasthit] = {head = 0, torso = 0, rightarm = 0, leftarm = 0, rightleg = 0, leftleg = 0, dl_break_at = dl_break_at}
    echof("Reset %s's limb status.", lasthit)
  elseif t[whom:lower()] then
    if not lasthit or not dl_list[lasthit] then
      echof("Not keeping track of anyone yet to reset their limb.")
    else
      dl_list[lasthit][t[whom:lower()]] = 0
      echof("Reset %s %s's status.", lasthit, t[whom:lower()])
    end
  elseif whom then
    if dl_list[whom] then
      dl_list[whom] = nil
      echof("Reset %s's limb status.", whom)
    else
      echof("Weren't keeping track of %s anyway.", whom)
    end
  else
    echof("Not keeping track of anyone to reset them anyway.")
  end
  raiseEvent("svo limbcounter reset")
end

function dl_show()
  if not defc.dragonform then return end

  if not next(dl_list) then echof("dragon limbcounter: Not keeping track of anyone yet."); return end

  setFgColor(unpack(getDefaultColorNums))
  for person, limbt in pairs(dl_list) do
    echo("---"..person.." ") fg("a_darkgrey")
    echoLink("(reset)", 'svo.dl_reset"'..person..'"', "Reset limb status for "..person, true)
    setFgColor(unpack(getDefaultColorNums))
    echo(string.format(" -- prep at %s -- break at %s --", dl_prep_at, dl_break_at))
    echo(string.rep("-", (52-#person-#tostring(dl_prep_at)-#tostring(dl_break_at))))
    echo"\n|"
    for i = 1, #limbs do
      if limbt[limbs[i]] >= dl_break_at - 1 then fg("green") end
      echo(string.format("%14s", (limbt[limbs[i]] >= dl_break_at - 1 and limbs[i].." prep" or limbs[i].. " "..limbt[limbs[i]])))
      if limbt[limbs[i]] >= dl_break_at - 1 then setFgColor(unpack(getDefaultColorNums)) end
      echo"|"
    end
    echo"\n"
  end
  echo(string.rep("-", 91))
end

echof("Loaded svo Dragon limbcounter, version %s.", tostring(dl_version))
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

es_version = "1.1"

-- stores vial ID and months left
es_vials = {}
-- stores type by key, and inside each, a potion table
--es_potions = {} -- intialized in setup
-- what are we currently capturing - so we know when to show the output
es_capturing = ""
es_disposecmd = ""

es_knownstuff = es_knownstuff or {}

signals.elistcaptured = luanotify.signal.new()

function es_capture()
  -- reset only what we're actually capturing
  if line:find("Venom", 1, true) then
    es_capturing = "venoms"

    for vial, _ in pairs(es_potions.venom) do
      es_potions.venom[vial] = {sips = 0, vials = 0, decays = 0}
    end

    -- wipe venoms only from es_potions
    local wipevenom = {}
    for vialid, vialdata in pairs(es_vials) do
      if es_potions.venom[vialdata.potion] then
        wipevenom[#wipevenom+1] = vialid
      end
    end
    for i = 1, #wipevenom do
      es_vials[wipevenom[i]] = nil
    end
  else
    es_capturing = "potions"

    for catn,cat in pairs(es_potions) do
      if catn ~= "venom" then
        for vial, _ in pairs(cat) do
          cat[vial] = {sips = 0, vials = 0, decays = 0}
        end
      end
    end

    -- wipe non-venoms only from es_potions
    local wipevial = {}
    for vialid, vialdata in pairs(es_vials) do
      if not es_potions.venom[vialdata.potion] then
        wipevial[#wipevial+1] = vialid
      end
    end
    for i = 1, #wipevial do
      es_vials[wipevial[i]] = nil
    end
  end
end

config.setoption("elist",
{
  type = "custom",
  vconfig2string = true,
  onshow = function (defaultcolour)
    fg("gold")
    echoLink("es:", "", "svo Elist Sorter", true)
    -- change desired amounts; considering vials about to decay at 5 or less months
    fg("a_cyan") echoLink(" set vial amounts", "svo.config.set'elist'", "Click to change the minimum amounts of vials you'd like to have", true)
    fg(defaultcolour) echo("; considering vials about to decay at")
    fg("a_cyan") echoLink(" "..(conf.decaytime or '?'), "printCmdLine'vconfig decaytime '", "Click to change the amount of months at which a vial will be considered for throwing away", true)
    fg(defaultcolour)
    echo(" month"..(conf.decaytime == 1 and '' or 's')..".\n")

  end,
  onmenu = function ()
    -- sort into categories
    local t = {}
    for k,v in pairs(es_categories) do t[es_categories[k] or "unknown"] = t[es_categories[k] or "unknown"] or {}; t[es_categories[k] or "unknown"][#t[es_categories[k] or "unknown"]+1] = k end

    echof("Set the desired amount for each potion by clicking on the number:")
    for catn, catt in pairs(t) do
      echof("%s%s:", catn:title():sub(1, -2), (catn:sub(-1) == "y" and "ies" or catn:sub(-1).."s"))

      for _, potion in pairs(catt) do
        local amount = (es_knownstuff[potion] or 0)
        echo(string.format("  %30s ", potion))
        fg("blue")
        echoLink(" "..amount.." ", 'printCmdLine"vconfig setpotion '..(es_shortnamesr[potion] and es_shortnamesr[potion] or "unknown").. ' '..amount..'"', "Change how many vials of "..potion.." you'd like to have", true)
        resetFormat()
        echo"\n"
      end
    end
  end
})

conf.decaytime = conf.decaytime or 3
config.setoption("decaytime",
{
  type = "number",
  vconfig2string = true,
  onset = function () echof("Will consider vials available for disposal when they decay time is at or less than %d months.", conf.decaytime) end,
  onshow = function (defaultcolour)
    fg("gold")
    echoLink("es:", "", "svo Elist Sorter", true)

    -- obfuscated vials: store vials at less than %d sips into %container
    fg(defaultcolour) echo(" obfuscated vials: store at less than")
    fg("a_cyan") echoLink(" "..(conf.obfsips or '?'), "printCmdLine'vconfig obfsips '", "Click to change the # of sips below which obfuscated vials will be stored in a container", true)
    fg(defaultcolour)
    echo(" sip"..(conf.obfuscated == 1 and '' or 's').." into ")
    fg("a_cyan") echoLink((conf.obfcontainer or '?'), "printCmdLine'vconfig obfcontainer '", "Click to change container into which obfuscated vials will be stored", true)
    echo(".\n")
  end
})

conf.obfsips = conf.obfsips or 20
config.setoption("obfsips",
{
  type = "number",
  onset = function () echof("Will put obfuscated vials away into %s when they're at %d or below sips.", tostring(conf.obfcontainer), conf.obfsips) end
})


conf.obfcontainer = conf.obfcontainer or "pack"
config.setoption("obfcontainer",
{
  type = "string",
  onset = function () echof("Will put obfuscated vials away into %s.", tostring(conf.obfcontainer)) end
})

config.setoption("setpotion",
{
  type = "string",
  onset = function()
    if not conf.setpotion:find("^.+ %d+$") then echof("What amount do you want to set?") return end

    local potion, amount = conf.setpotion:match("^(.+) (%d+)$")
    amount = tonumber(amount)
    if es_shortnames[potion] then
      es_knownstuff[es_shortnames[potion]] = amount
      echof("Made a note that we'd like to have a minimum %s of %s.", amount, potion)
      return
    elseif not es_knownstuff[potion] then
      echof("I haven't seen any potions called '%s' yet...", potion)
    else
      es_knownstuff[potion] = amount
      echof("Made a note that we'd like to have a minimum %s of %s.", amount, potion)
      return
    end
  end
})

function es_appendrequest(whatfor)
  local t = {}
  for catn, catt in pairs(es_potions) do
    for potn, pott in pairs(catt) do
      if ((whatfor ~= "venoms" and not potn:find("the venom", 1, true)) or (whatfor == "venoms" and potn:find("the venom", 1, true))) and es_knownstuff[potn] and pott.vials < es_knownstuff[potn] then
        t[#t+1] = (es_knownstuff[potn] - pott.vials) .. " ".. (es_shortnamesr[potn] and es_shortnamesr[potn] or potn)
      end
    end
  end

  if #t == 0 then echof("I don't think you're short on anything!") return
  else appendCmdLine(" I'd like "..concatand(t)) end
end

function es_refillfromkeg()
  local t = {}
  for catn, catt in pairs(es_potions) do
    for potn, pott in pairs(catt) do
      if es_knownstuff[potn] and pott.vials < es_knownstuff[potn] and (es_shortnamesr[potn] and es_shortnamesr[potn] or potn) ~= "empty" then
        for i = 1, es_knownstuff[potn] - pott.vials do
          t[#t+1] = string.format("refill empty from %s", (es_shortnamesr[potn] and es_shortnamesr[potn] or potn))
        end
      end
    end
  end

  if #t == 0 then echof("I don't think you're short on anything!") return
  else
    sendc(unpack(t))
  end
end

function es_captured(vlist)
  tempTimer(0, function()
    local missing = 0
    local decaying

    local function checkdecays(pott)
      if pott.decays == 0 then return ""
      else decaying = true return (pott.decays.." decaying soon") end
    end

    for catn, catt in pairs(es_potions) do
      echof("%s%s:", catn:title():sub(1, -2), (catn:sub(-1) == "y" and "ies" or catn:sub(-1).."s"))

      for potn, pott in pairs(catt) do
        -- don't show vials that we have 0 of and want 0 of
        if not (pott.vials == 0 and (not es_knownstuff[potn] or (es_knownstuff[potn] and es_knownstuff[potn] == 0))) then
          if es_knownstuff[potn] and pott.vials < es_knownstuff[potn] then
            missing = missing + es_knownstuff[potn] - pott.vials
            echon("%3d %-35s%7s  %10s", pott.vials, potn..' ('..pott.sips..'s)', (es_knownstuff[potn] - pott.vials .. " short"), checkdecays(pott))
          else
            echon("%3d %-35s%7s  %10s", pott.vials, potn..' ('..pott.sips..'s)', "", checkdecays(pott))
          end
        end
      end
    end
    echo"  "; dechoLink("<0,0,250>("..getDefaultColor().."change desired amounts<0,0,250>)", "svo.config.set('elist')", "Show a menu to change how much of what would you like to have", true) echo"\n"
    if decaying then echo"  "; dechoLink("<0,0,250>("..getDefaultColor().."dispose of decays<0,0,250>)", "printCmdLine'dispose of decays by: give vial to humgii'", "Dispose of vials (pouring them into other vials if possible) with a custom command.\nMake sure to include the word 'vial' in the command", true) echo"\n" end
    if missing > 0 then
      echo"  "
      dechoLink("<0,0,250>("..getDefaultColor().."append refill request, need "..missing.." refills<0,0,250>)", "svo.es_appendrequest('"..es_capturing.."')", "Insert how many refills of "..es_capturing.." would you like into the command line.\nYou should pre-type whenever you want to say or tell this to anyone, and then click", true)
      echo"\n  "
      dechoLink("<0,0,250>("..getDefaultColor().."refill from tuns, need "..missing.." refills<0,0,250>)", "svo.es_refillfromkeg()", "Click here to refill all necessary things from shop tuns", true)
      echo"\n"
    end
    showprompt()
    debugf("raising elistcaptured with: %s", tostring(vlist))
    signals.elistcaptured:emit(vlist)
  end)
end

function es_dodisposing(vlist)
  -- check vlist and then elist - ignore if its vlist, only act on elist
  debugf("es_dodisposing: %s", tostring(vlist))
  if vlist then return end

  local function emptyvial(id)
    if es_vials[id].sips == 0 then echof("%d is already empty.", id) return end
    echof("Emptying vial%d with %s.", id, es_vials[id].potion)

    -- one pass is enough! If we don't completely dispose of it, then that's alright
    for otherid, t in pairs(es_vials) do
      if otherid ~= id and (t.potion == es_vials[id].potion or t.potion == "empty") and t.sips < (type(t.months) == "number" and 200 or 240) and
        (type(t.months) ~= "number" or t.months > conf.decaytime) then

        local deltacapacity = (type(t.months) == "number" and 200 or 240) - t.sips -- this is how much we can fill it up by
        echof("Can fill vial%d with %d more sips.", otherid, deltacapacity)

        local fillingwith = (es_vials[id].sips < deltacapacity and es_vials[id].sips or deltacapacity)
        echof("Filling vial%d with %d sips.", otherid, fillingwith)

        sendc(string.format("pour %d into %d", id, otherid))

        t.sips = t.sips + fillingwith
        echof("Poured %s into vial%s, which is now at %d sips.", es_vials[id].potion, tostring(otherid), tostring(t.sips))

        es_vials[id].sips = es_vials[id].sips - fillingwith
        echof("Decayable vial%s is now at %d sips.", id, es_vials[id].sips)

        if t.potion == "empty" then t.potion = es_vials[id].potion; echof("Poured into empty now has %s potion", tostring(t.potion)) end
        if es_vials[id].sips <= 0 then echof("Vial %s fully emptied.\n--", tostring(id)) return end
      end
    end
    echof("Vial %d with '%s' wasn't fully emptied, no space to pour it into now.\n--", id, es_vials[id].potion)
  end

  echo'\n'
  local haddecays
  for id, t in pairs(es_vials) do
    if type(t.months) == "number" and t.months <= conf.decaytime then
      emptyvial(id)
      sendc(es_disposecmd:gsub("vial", id), false)
      haddecays = true
    end
  end

  if haddecays then
    echof("Disposing of vials which have %d or less months on them...", conf.decaytime)
  else
    echof("Don't have any vials which have under %d months :)", conf.decaytime)
  end
  showprompt()

  signals.elistcaptured:disconnect(es_dodisposing)
end

function es_dispose(cmd)
  if not cmd:find("vial", 1, true) then echof("Please include the word 'vial' in the command. Thanks!") return end
  if not next(es_vials) then echof("Don't know of any vials you have - check 'elist' please.") return end

  signals.elistcaptured:connect(es_dodisposing)
  es_disposecmd = cmd
  -- refresh our vials data, in case new vials were bought
  send("config pagelength 250", false)
  send("vlist", false)
  send("elist", false)
end

signals.saveconfig:connect(function () table.save(getMudletHomeDir() .. "/svo/config/es_knownstuff", es_knownstuff) end)
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/es_knownstuff"

  if lfs.attributes(conf_path) then
    table.load(conf_path, es_knownstuff)
  end

  if lfs.attributes(conf_path) then
    local ok = pcall(table.load, conf_path, es_knownstuff)
    if not ok then
      os.remove(conf_path)
      tempTimer(10, function()
        echof("Your elist sorter save file file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-set all of the elist options again, though. (%q)", msg)
      end)
    end
  end
end)

-- remember our vial statuses if we have
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/es_potions"

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    update(es_potions, t)
  end

  -- erase tonics and balms as those are gone
  es_potions.tonic = nil
  es_potions.balm = nil
end)

signals.saveconfig:connect(function () table.save(getMudletHomeDir() .. "/svo/config/es_potions", es_potions) end)

echof("Loaded svo Elist Sorter, version %s.", tostring(es_version))

-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

ti_version = "1.1"

local limb_order = {"head", "torso", "right arm", "left arm", "right leg", "left leg", "back"}
local tattoos = {
  ox = {
    {
      1,
      "goldink",
    },
    {
      1,
      "redink",
    },
    {
      1,
      "yellowink",
    },
    {
      1,
      "blueink",
    }
  },
  cloak = {
    {
      3,
      "blueink",
    }
  },
  firefly = {
    {
      1,
      "yellowink",
    }
  },
  bell = {
    {
      3,
      "blueink",
    },
    {
      2,
      "redink",
    }
  },
  moss = {
    {
      1,
      "blueink",
    },
    {
      1,
      "redink",
    },
    {
      1,
      "yellowink",
    }
  },
  prism = {
    {
      1,
      "blueink",
    },
    {
      1,
      "greenink",
    },
    {
      1,
      "purpleink",
    },
    {
      1,
      "redink",
    },
    {
      1,
      "yellowink",
    }
  },
  mindseye = {
    {
      2,
      "blueink",
    },
    {
      1,
      "greenink",
    }
  },
  brazier = {
    {
      2,
      "redink",
    },
    {
      2,
      "yellowink",
    }
  },
  feather = {
    {
      2,
      "blueink",
    },
    {
      1,
      "redink",
    }
  },
  moon = {
    {
      1,
      "blueink",
    },
    {
      1,
      "redink",
    },
    {
      1,
      "yellowink",
    }
  },
  starburst = {
    {
      1,
      "blueink",
    },
    {
      1,
      "goldink",
    },
    {
      1,
      "greenink",
    },
    {
      1,
      "purpleink",
    },
    {
      1,
      "redink",
    },
    {
      1,
      "yellowink",
    }
  },
  chameleon = {
    {
      1,
      "goldink",
    },
    {
      1,
      "purpleink",
    },
    {
      1,
      "yellowink",
    }
  },
  crystal = {
    {
      1,
      "greenink",
    },
    {
      1,
      "purpleink",
    },
    {
      1,
      "yellowink",
    }
  },
  megalith = {
    {
      2,
      "goldink",
    }
  },
  tree = {
    {
      5,
      "greenink",
    }
  },
  hourglass = {
    {
      1,
      "blueink",
    },
    {
      2,
      "yellowink",
    }
  },
  hammer = {
    {
      1,
      "purpleink",
    },
    {
      2,
      "redink",
    }
  },
  tentacle = {
    {
      2,
      "greenink",
    },
    {
      1,
      "purpleink",
    }
  },
  web = {
    {
      1,
      "greenink",
    },
    {
      1,
      "yellowink",
    }
  },
  boar = {
    {
      1,
      "purpleink",
    },
    {
      2,
      "redink",
    }
  },
  shield = {
    {
      1,
      "greenink",
    },
    {
      2,
      "redink",
    }
  }
}

svo.ti_inking = false

-- if ends with 'on person', then it's on a person!
function svo.ti_ink(order)
  local anotherperson = order:match(" on (%w+)$")
  if anotherperson then order = order:sub(1, #order-#anotherperson-4) end
  local tattoos = string.split(order, ",")
  for i = 1, #tattoos do tattoos[i] = string.trim(tattoos[i]) end

  svo.ti_inking = {on = anotherperson or "me", tattoos = tattoos, ink_counter = 1, tattoo_counter = 1}
  svo.echof("Going to ink %s on %s.", concatand(ti_inking.tattoos), svo.ti_inking.on)
  svo.showprompt() echo"\n"
  svo.app("on")

  svo.ti_inknext()
end

local function doneinking()
    local touchables = {"moss", "moon", "boar", "megalith", "ox"}
    local needtotouch = {}
    for i = 1, svo.ti_inking.tattoo_counter do
      if table.contains(touchables, svo.ti_inking.tattoos[i]) then needtotouch[#needtotouch+1] = svo.ti_inking.tattoos[i] end
    end
    if #needtotouch > 0 then
      if svo.ti_inking.on ~= "me" then
        if svo.conf.telltouch then send(string.format("say to %s you should now touch your %s tattoo%s", svo.ti_inking.on, concatand(needtotouch), (#needtotouch == 1 and "" or "s"))) end
      end
    end

    svo.ti_inking = nil
    echo("\n")
    svo.app("off")
    svo.echof("Finished inking all tattoos.")
end

function svo.ti_cantink(limb)
  if not svo.ti_inking then return end
  if limb == limb_order[#limb_order] then
    echo("\n")
    svo.echof("No more inking spots on %s :|", (svo.ti_inking.on == "me" and "you" or svo.ti_inking.on))
    svo.showprompt()
    doneinking()
  else
    svo.ti_inking.ink_counter = svo.ti_inking.ink_counter + 1
    svo.ti_inknext()
  end
end

function svo.ti_finishedinking()
  if not ti_inking then return end

  if table.contains({"moss", "moon", "boar", "megalith", "ox"}, svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter]) then
    send("touch "..svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter])
  end

  svo.ti_inking.tattoo_counter = svo.ti_inking.tattoo_counter + 1

  if not svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter] then
    doneinking()
  else
    svo.ti_inking.ink_counter = 1
    echo("\n")
    svo.echof("Inking the next tattoo...")
    svo.ti_inknext()
  end
end

function svo.ti_inknext()
  if svo.ti_inking.ink_counter == 1 and not tattoos[svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter]] then
    svo.echof("Don't know the inks necessary for a %s tattoo.", svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter])
    svo.showprompt()
  elseif svo.ti_inking.ink_counter == 1 then
    for _, t in pairs(tattoos[svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter]]) do
      sendc(string.format("outr %d %s", t[1], t[2]), false)
    end
  end

  sendc(string.format("ink %s on %s of %s", svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter], limb_order[svo.ti_inking.ink_counter], svo.ti_inking.on))
end

function svo.ti_interrupted()
  if not svo.ti_inking then return end

  svo.ti_inking.ink_counter = 1
  if svo.ti_inking.on == "me" then
    echo"\n" svo.echof("Be still! Going to ink again in a few...")
  else
    send(string.format("say to %s be still!", svo.ti_inking.on))
  end
  tempTimer(2, function() svo.ti_inknext() end)
end

function svo.ti_noinks()
  echo("\n") svo.echof("Lacking inks for the %s tattoo...", svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter])
  if not svo.ti_inking.tattoos[svo.ti_inking.tattoo_counter + 1] then
    doneinking()
  else
    svo.ti_inking.tattoo_counter = svo.ti_inking.tattoo_counter + 1
    svo.ti_inknext()
  end
end

config.setoption("telltouch",
{
  type = "boolean",
  vconfig2string = true,
  onshow = function (defaultcolour)
    fg("gold")
    echoLink("ti:", "", "svo Tattoo Inker", true)
    -- <Tell/Don't tell> people to touch inked tattoos
    if svo.conf.telltouch then
      fg("a_cyan") echoLink(" Will tell", "svo.config.set('telltouch', false, true)", "Click to stop telling people to touch their newly-inked tattoos", true)
    else
      fg("a_cyan") echoLink(" Won't tell", "svo.config.set('telltouch', true, true)", "Click to start telling people to touch their newly-inked tattoos", true)
    end
    fg(defaultcolour) echo(" people to touch inked tattoos")
    echo(".\n")
  end,
  onenabled = function ()
    echof("<0,250,0>Will%s tell people to touch tattoos they need to after inking.", getDefaultColor())
  end,
  ondisabled = function () echof("<250,0,0>Won't%s tell people to touch tattoos they need to after inking.", getDefaultColor()) end
})

echof("Loaded svo Tattoo Inker, version %s.", tostring(ti_version))
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.


--[[
things to optimize: only do label updates on prompt
handling multiple rooms ideas:
 * draw a far-away label saying "also in area at '%s': blah, blah"
   -> can't work yet, because calculating a possible location would be a pain
 * put names in every room
   -> looks ugly in this combination: http://img7.imagebanana.com/img/oshg8lw5/Selection_037.png
 * label by single letters for groups, with only the rightmost room having the full list of names with letter) prepended
]]

-- area = {labels}
local labels = {}

-- default to numerals when we run out
-- while defining this as a function would be nicer, it's easier for most people to mod if it's in this format
local multiplegroups = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"}

conf.peopletracker = type(conf.peopletracker) == 'nil' and true or conf.peopletracker
config.setoption("peopletracker", {
  type = "boolean",
  onenabled = function ()
    if not deleteMapLabel or not createMapLabel then
      echof("I'm sorry, but your Mudlet is too old and can't make labels on the map yet - update it!")
      conf.peopletracker = false
      raiseEvent("svo config changed", "peopletracker")
      return
    end

    echof("People tracker <0,250,0>enabled%s.", getDefaultColor())
  end,
  ondisabled = function () sys.clean_old_labels() echof("People tracker <250,0,0>disabled%s.", getDefaultColor()) end,
  installstart = function () conf.peopletracker = true end,
})

conf.clearlabels = type(conf.clearlabels) == 'nil' and true or conf.clearlabels
config.setoption("clearlabels", {
  type = "boolean",
  onenabled = function () signals.newarea:connect(sys.clear_labels) echof("<0,250,0>Will%s automatically clear map labels that are surrounded by ().", getDefaultColor()) end,
  ondisabled = function ()signals.newarea:disconnect(sys.clear_labels) echof("<250,0,0>Won't%s automatically clear map labels that are surrounded by ().", getDefaultColor()) end,
  installstart = function () conf.clearlabels = true end,
})

conf.labelsfont = type(conf.labelsfont) == 'nil' and 10 or conf.labelsfont
config.setoption("labelsfont", {
  type = "number",
  onset = function () sys.update_people_labels() echof("Labels set to draw at %dpt.", conf.labelsfont) end,
  installstart = function () conf.labelsfont = 10 end,
})

conf.labelcolor = conf.labelcolor or "white"
conf.maxdupes = conf.maxdupes or 20
config.setoption("labelcolor", {
  type = "string",
  vconfig2string = true,
  check = function (what)
    if color_table[what] then return true end
  end,
  onshow = function (defaultcolour)
    fg("gold")
    echoLink("ppl: ", "", "svo People Tracker", true)
    fg(defaultcolour) echo("People tracker ")
    fg("a_cyan") echoLink((conf.peopletracker and "on" or "off"), "svo.config.set('peopletracker', "..(conf.peopletracker and "false" or "true")..", true)", "Click to "..(conf.peopletracker and "disable" or "enable").." people tracking on the map", true)
    fg(defaultcolour) echo("; using")
    fg(conf.labelcolor or "a_cyan") echoLink(" "..(conf.labelcolor or '?'), "printCmdLine'vconfig labelcolor '", "Click to change the color", true)
    fg(defaultcolour) echo(" map labels (")
    fg("a_cyan") echoLink("view all", "showColors()", "Click to view possible color names that you can use for customizing the label colors", true)
    fg(defaultcolour)
    echo("); font size is ")
    fg("a_cyan") echoLink(tostring(conf.labelsfont), "printCmdLine'vconfig labelsfont '", "Click to set the font size for peopletracker labels", true)
    echo(".\n")
  end,
  onset = function ()
    local r,g,b = unpack(color_table[conf.labelcolor])
    sys.update_people_labels()
    echof("Okay, will color the map labels in <%s,%s,%s>%s%s now.", r,g,b, conf.labelcolor, getDefaultColor())
  end,
  installstart = function ()
    conf.labelcolor = "blue"
  end
})

-- check for old Mudlet versions
if not deleteMapLabel or not createMapLabel then
  echof("I'm sorry, but your Mudlet is too old and can't make labels on the map yet - update it!")
  return
end

sys.clean_old_labels = function()
  for areanum, arealabels in pairs(labels) do
    for _, label in pairs(arealabels) do
      deleteMapLabel(areanum, label)
    end
  end
  labels = {}
end
signals.sysexitevent:connect(sys.clean_old_labels)

sys.clear_labels = function()
  if not mmp then return end
  local function clearlabels(areaid)
    local t = getMapLabels(areaid)
    if type(t) ~= "table" then return end

    local starts, ends = string.starts, string.ends
    for labelid, text in pairs(t) do
      if starts(text, '(') and ends(text, ')') then
        deleteMapLabel(areaid, labelid)
      end
    end
  end

  for areaid in pairs(mmp.areatabler or {}) do
    clearlabels(areaid)
  end
end

if conf.clearlabels then
  signals.newarea:connect(sys.clear_labels)
end

sys.update_people_labels = function ()
  -- drawwatch = drawwatch or createStopWatch()
  -- startStopWatch(drawwatch)

  local s,m = pcall(function()
    if not mmp then return end
    -- build a 'location = people' reverse map
    local r = {}
    -- keeps track at which index of multiplegroups are we at
    local multiplescount = 1

    local fr,fg,fb = unpack(color_table[conf.labelcolor or "white"])
    local br,bg,bb = unpack(color_table.black)

    for k,v in pairs(mmp.pdb) do
      if mmp.pdb_lastupdate[k] then
        r[v] = r[v] or {}; r[v][#r[v]+1] = k
      end
    end

    sys.clean_old_labels()
    if not conf.peopletracker or not mmp.pdb_lastupdate or not mmp.roomexists(mmp.currentroom) then return end

    local getRoomArea, createMapLabel, getRoomCoordinates, concat, sort = getRoomArea, createMapLabel, getRoomCoordinates, table.concat, table.sort

    -- if we have a unique location, draw fancy labels in all rooms on 60% opacity
    for room, persons in pairs(r) do
      sort(persons)
      local ids = mmp.getnums(room, true)

      -- multiples? special case then. Current method implemented is #3
      if ids and #ids >1 and #ids <= conf.maxdupes then
        -- make a table of roomid = {x,y,z}
        -- in a separate variable, track the right-most room ID and x coordinate per-Z level
        local coords, rightmost = {}, {}
        for _, exactroomid in pairs(ids) do
          coords[exactroomid] = {getRoomCoordinates(exactroomid)}
          coords[exactroomid][4] = getRoomArea(exactroomid)

          if not rightmost[coords[exactroomid][3]] or
            coords[exactroomid][1] >= rightmost[coords[exactroomid][3]][1] then -- >= so rightmostroom is set at least once

            rightmost[coords[exactroomid][3]] =
              {coords[exactroomid][1], exactroomid} -- we don't account for the Y coordinate if the X's are the same atm, though
          end
        end

        -- now, draw!
        for roomid, l in pairs(coords) do
          local area = l[4]
          labels[area] = labels[area] or {}

          if rightmost[l[3]] and roomid == rightmost[l[3]][2] then
            -- doesn't account for multiplescount overflowing atm
            labels[area][#labels[area]+1] = createMapLabel(area, '('..multiplegroups[multiplescount].." "..concat(persons, ", ")..')', l[1],l[2],l[3], fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
          else
            labels[area][#labels[area]+1] = createMapLabel(area, '('..multiplegroups[multiplescount]..')', l[1],l[2],l[3], fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
          end
        end
        multiplescount = multiplescount +1

      elseif ids and #ids == 1 then
        local x,y,z = getRoomCoordinates(ids[1])
        local area = getRoomArea(ids[1])

        if area then -- somehow area can still be returned as nil
          labels[area] = labels[area] or {}

          labels[area][#labels[area]+1] = createMapLabel(area, '('..concat(persons, ", ")..')', x,y,z, fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
        end
      end
    end
  end)

  if not s then
    echoLink("(e!)", string.format("echo([=[The problem was: %q]=])", m), 'Oy - there was a problem with the peopletracker. Click on this link and submit a bug report with what it says.')
  end

  -- echof("update took %s", stopStopWatch(drawwatch))
end

signals["mmapper updated pdb"]:connect(function()
  if isPrompt() then
    sys.update_people_labels()
  else
    sk.onprompt_beforeaction_add("update_labels", sys.update_people_labels)
  end
end)

signals.quit:connect(sys.clean_old_labels)
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

rf_debug = false

-- format: {p = {potion = { normal = #, arty = 0/#}}, currentorder = ""}
-- this stores the total order that we need to do
rf_refilling = false

-- format: "potion"
-- this stores the current potion that we're doing of the whole order

conf.potid = conf.potid or "pot"
config.setoption("potid", {
  type = "string",
  vconfig2string = true,
  onshow = function (defaultcolour)
    fg("gold")
    echoLink("refiller: ", "", "svo Refiller", true)
    fg(defaultcolour) echo("Pot to use is ")
    fg("a_cyan") echoLink((conf.potid or "pot"), "printCmdLine 'vconfig potid pot###'", "Click to set the pot ID to use for brewing in", true)
    fg(defaultcolour) echo("; storing your vials in")
    fg("a_cyan") echoLink(" "..(conf.packid or 'pack'), "printCmdLine'vconfig packid '", "Click to set the pack ID to stuff your vials into when you do 'putvials'", true)
    fg(defaultcolour) echo(".\n")
  end,
  onset = function ()
    echof("Okay, will brew in the %s item.", conf.potid)
  end
})

conf.packid = conf.packid or "pack"
config.setoption("packid", {
  type = "string",
  onset = function ()
    echof("Okay, will store vials in %s when you do 'putvials'. Doing 'getvials' will get them back out.", conf.packid)
  end
})

local concoctions = {
  epidermal = {
    ["kuzu"] = 2,
    ["bloodroot"] = 1,
    ["hawthorn"] = 1,
    ["ginseng"] = 1
  },
  immunity = {
    ["sac"] = 1,
    ["ash"] = 1,
    ["echinacea"] = 2,
  },
  mana = {
    ["slipper"] = 1,
    ["bellwort"] = 1,
    ["hawthorn"] = 1,
    ["bloodroot"] = 1,
  },
  health = {
    ["valerian"] = 1,
    ["goldenseal"] = 1,
    ["ginseng"] = 1,
    ["myrrh"] = 1,
  },
  venom = {
    ["sac"] = 1,
    ["cohosh"] = 1,
    ["kelp"] = 1,
    ["skullcap"] = 1,
  },
  frost = {
    ["kelp"] = 1,
    ["pear"] = 1,
    ["ginseng"] = 1,
  },
  levitation = {
    ["kelp"] = 2,
    ["pear"] = 1,
    ["eaglefeather"] = 1,
  },
  mending = {
    ["ginger"] = 2,
    ["diamonddust"] = 1,
    ["kelp"] = 1,
    ["kuzu"] = 1,
  },
  mass = {
    ["moss"] = 1,
    ["bloodroot"] = 1,
    ["diamonddust"] = 1,
    ["kuzu"] = 1,
  },
  speed = {
    ["skin"] = 2,
    ["goldenseal"] = 1,
    ["kuzu"] = 1,
    ["ginger"] = 1,
  },
  restoration = {
    ["kuzu"] = 2,
    ["valerian"] = 1,
    ["bellwort"] = 1,
    ["gold"] = 2,
  },
  caloric = {
    kuzu = 2,
    kelp = 2,
    valerian = 1,
    bellwort = 1
  }
}

local function outr(what, amount)
  if what == "gold" then
    sendc("get "..amount.." gold from "..conf.packid, rf_debug)
    return
  end

  if amount == 1 then send("outr "..what, rf_debug)
  else sendc("outr "..amount.." "..what, rf_debug) end
end

local function inpot(what, amount, pot)

  while amount > 50 do
    sendc("inpot 50 "..what.." in "..pot, rf_debug)
    amount = amount - 50
  end

  if amount == 1 then
    sendc("inpot "..what.." in "..pot, rf_debug)
  else
    sendc("inpot "..amount.. " "..what.." in "..pot, rf_debug)
  end
end

function rf_fillpot(potion, fills, pot)
  assert(potion and fills, "rf_fillpot: need to supply both what to brew and what amount to brew")

  -- 1 set of ingredients = 1 fill
  assert(concoctions[potion], "rf_fillpot: don't know about such a potion")
  for item, amount in pairs(concoctions[potion]) do
    outr(item, amount * fills)
    inpot(item, amount * fills, pot or conf.potid)
  end
end

function rf_boilpot(pot)
  local pot = pot or conf.potid

  rf_wait_to_boil = tempTimer(getNetworkLatency()+1, function ()
    if not svo.defc.selfishness then
      sendc("drop "..pot, rf_debug)
      sendc("boil "..pot.." for "..tostring(rf_refilling.currentorder), rf_debug)
    else
      sendc("generosity", rf_debug)
      rf_temptrigger = tempExactMatchTrigger("You have recovered equilibrium.", "killTrigger(svo.rf_temptrigger); send('drop "..pot.."', svo.rf_debug); send('boil "..pot.." for "..tostring(rf_refilling.currentorder).."', svo.rf_debug)")
    end
  end)
end

function rf_magichappened()
  if not rf_refilling then return end

  svo.doadd(function()
    sendc("take "..conf.potid, rf_debug)

    if rf_refilling.currentorderdata then
      for i = 1, rf_refilling.currentorderdata.arty do
        rf_fillarty()
      end

      for i = 1, (rf_refilling.currentorderdata.normal - rf_refilling.currentorderdata.arty) do
        rf_fillnext()
      end
    end

    echo'\n' rf_nextpotion()
  end)
end

function rf_fillnext()
  if not rf_refilling then return end

  sendc("fill emptyvial from "..conf.potid.." "..(svo.rf_transrefiller and 4 or 5).." times", rf_debug)
end

function rf_fillarty()
  if not rf_refilling then return end

  if not svo.rf_arties[1] then
    missing_arty = (missing_arty or 0) + 1
    prompttrigger("warn of missing arties", function()
      echof("You're missing %s artefact vials that were needed in the order, fyi.", missing_arty)
      missing_arty = nil
    end)
    return
  end

  sendc("fill "..table.remove(svo.rf_arties).." from "..conf.potid.." "..(svo.rf_transrefiller and 2 or 3).." times", rf_debug)
end

function rf_cancel()
  rf_refilling = nil
  undoall()
  echof("Cancelled refilling.")
end

function rf_refill(what)
  local what = what:split(",")
  local needarties

  rf_refilling = { p = {}, currentorder = false, currentorderdata = false}
  for i = 1, #what do
    what[i] = what[i]:trim()
    local amount, potion
    if what[i]:find("^(%d+) (%w+)") then
      amount, potion = what[i]:match("^(%d+) (%w+)")
    elseif what[i]:find("^(%w+)") then
      amount, potion = 1, what[i]:match("^(%w+)")
    end

    if not concoctions[potion] then
      echof("Don't know the ingredients for a '%s' potion :|", tostring(potion))
    else
      rf_refilling.p[potion] = {normal = tonumber(amount)}
      rf_refilling.p[potion].arty = tonumber(what[i]:match("(%d+) arty$") or 0)

      if rf_refilling.p[potion].arty > 0 then
        needarties = true
      end

      if rf_refilling.p[potion].arty > rf_refilling.p[potion].normal then
        echof("You can't have only %s refills of %s, and %s of them into artefact vials... going to assume you wanted %s %s refills total.", rf_refilling.p[potion].normal, potion, rf_refilling.p[potion].arty, rf_refilling.p[potion].arty, potion)
        rf_refilling.p[potion].normal = rf_refilling.p[potion].arty
      end
    end
  end

  if not next(rf_refilling.p) then
    rf_refilling = nil
    echof("Don't have anything to refill, then :/")
    return
  end

  rf_previousorder = deepcopy(rf_refilling.p)
  if not needarties then rf_nextpotion() else
    echof("Looking for the artefact vials...")
    sendc("config pagelength 250", rf_debug)
    sendc("ii artefact", rf_debug)
    sendc("config pagelength "..(conf.pagelength >= 20 and conf.pagelength or 20), rf_debug)
  end
end

-- to be called only when we need to do the next potion
function rf_nextpotion()
  rf_refilling.currentorder = next(rf_refilling.p)
  rf_refilling.currentorderdata = rf_refilling.p[rf_refilling.currentorder]
  if not rf_refilling.currentorder then
    rf_refilling = nil
    svo.echof("Done refilling!")
    raiseEvent("svo done refilling")
  else
    svo.echof("Going to work on refilling %s.", tostring(rf_refilling.currentorder))
    rf_fillpot(rf_refilling.currentorder,
      -- refill 5 health 2 arty means 3 normal + 2 arty!
      (rf_refilling.p[rf_refilling.currentorder].normal - rf_refilling.p[rf_refilling.currentorder].arty) * (svo.rf_transrefiller and 4 or 5) +
      rf_refilling.p[rf_refilling.currentorder].arty * 2)
    rf_boilpot()

    -- clear the fill so next time rf_nextpotion() is called, it's fine
    rf_refilling.p[rf_refilling.currentorder] = nil
  end
end

function rf_undopot(potion, fills, pot)
  assert(potion and fills, "rf_undopot: need to supply potion and how many fills went in")

  assert(concoctions[potion], "rf_undopot: don't know about such a potion")
  for item, amount in pairs(concoctions[potion]) do
    doadd("get "..amount * fills.." "..item.." from "..(pot or conf.potid))
  end
  doadd("get "..(pot or conf.potid))
  doadd("refill next potion")
end

function rf_missingstuff()
  disableTrigger("Missing ingredients"); tempTimer(2, function() enableTrigger("Missing ingredients") end)
  killTimer(rf_wait_to_boil)

  echo'\n' echof("Ack, looks like you're out of enough ingredients - going to get what we put into the pot back...")

    rf_undopot(rf_refilling.currentorder,
      (rf_refilling.currentorderdata.normal - rf_refilling.currentorderdata.arty) * (svo.rf_transrefiller and 4 or 5) +
      rf_refilling.currentorderdata.arty * 2)
end
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.

pl.dir.makepath(getMudletHomeDir() .. "/svo/namedb")

-- load the highlightignore list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. "/svo/config/highlightignore"

  if lfs.attributes(conf_path) then
    local t = {}
    local ok, msg = pcall(table.load, conf_path, t)
    if ok then
	    me.highlightignore = me.highlightignore or {} -- make sure it's initialized
	    update(me.highlightignore, t)
	else
		os.remove(conf_path)
		tempTimer(10, function()
		  echof("Your NameDB highlights ignored file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-do all the names to ignore highlighting, though. (%q)", msg)
		end)
	end
  end
end)
signals.saveconfig:connect(function () me.highlightignore = me.highlightignore or {}; table.save(getMudletHomeDir() .. "/svo/config/highlightignore", me.highlightignore) end)


-- save the ndb.conf.citypolitics list

signals.saveconfig:connect(function () ndb.conf.citypolitics = ndb.conf.citypolitics or {}; table.save(getMudletHomeDir() .. "/svo/namedb/citypolitics", ndb.conf.citypolitics) end)

signals.saveconfig:connect(function ()
	-- this can error out if the connection is closed
  pcall(function() db.__conn["namedb"]:execute("VACUUM") end)
end)

--ndb.API
function ndb.ismhaldorian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, "Mhaldor"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.iscyrenian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, "Cyrene"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isshallamese(name)
  return #(db:fetch(ndb.db.people, {db:OR(db:eq(ndb.db.people.city, "Shallam"), db:eq(ndb.db.people.city, "Targossas")), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.istargossian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, "Targossas"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.iseleusian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, "Eleusis"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isashtani(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, "Ashtan"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.ishashani(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, "Hashan"), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isclass(name, class)
  name, class = name:title(), class:lower()
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.class, class), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.getclass(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].class:lower()
end

function ndb.setclass(name, class)
  class = class:lower()
  assert(ndb.isvalidclass(class), "ndb.setclass: invalid class given")

  ndb.fixed_set(ndb.db.people.class, class, db:eq(ndb.db.people.name, name))
end

function ndb.getcity(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].city
end

function ndb.getnotes(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].notes
end

function ndb.getxprank(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].xp_rank
end

function ndb.ismark(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  if r[1].mark == "" then return false
  else return r[1].mark end
end

function ndb.setmark(name, type)
  if type == false then type = "" end

  ndb.fixed_set(ndb.db.people.mark, type, db:eq(ndb.db.people.name, name))
end

function ndb.isinfamous(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  if r[1].infamous == "" then return false
  else return r[1].infamous end
end

function ndb.setinfamous(name, infamy)
  ndb.fixed_set(ndb.db.people.infamous, infamy, db:eq(ndb.db.people.name, name))
end

function ndb.isdragon(name)
  assert(name, "ndb.isdragon() requires a name")

  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return (r[1].dragon == 1 and true or false)
end

function ndb.getcityrank(name)
  assert(name, "ndb.getcityrank() requires a name")

  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return ndb.valid.cityranks[r[1].city][r[1].city_rank]
end

function ndb.setdragon(name, status)
  status = svo.toboolean(status) and 1 or 0

  ndb.fixed_set(ndb.db.people.dragon, status, db:eq(ndb.db.people.name, name))
end

function ndb.isimmortal(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return (r[1].immortal == 1 and true or false)
end

function ndb.exists(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

function ndb.isperson(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

-- returns true only if a certain enemy
function ndb.isenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local city = p.city

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and
         ((city and city ~= "" and ndb.conf.citypolitics[city] == "enemy") or
         (p.cityenemy == 1 or p.orderenemy == 1 or p.houseenemy == 1))) then
    return true else return false
  end
end

-- returns true only if someone is an enemy via iff or is a city enemy. They could be a house enemy, and not be considered an enemy by this
function ndb.iscityenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local city = p.city

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and
         ((city and city ~= "" and ndb.conf.citypolitics[city] == "enemy") or
         (p.cityenemy == 1))) then
    return true else return false
  end
end

-- given a title, returns all info about a person
function ndb.getnamebytitle (title)
  return db:fetch(ndb.db.people, db:in_(ndb.db.people.name, string.split(title, " ")))
end

-- given a line, returns the first name it finds, if any
function ndb.findname(line)
  for w in string.gmatch(line, "(%u%l+)") do
    if #w >= 3 then
      if ndb.isperson(w) then return w end
    end
  end
end

-- given a line, returns all names found on it
function ndb.findnames(line)
  local l = {}
  for w in string.gmatch(line, "(%u%l+)") do
    if #w >= 3 then
      if ndb.isperson(w) then l[#l+1] = w end
    end
  end

  if l[1] then return l end
end

-- given a name, returns all info about a person
function ndb.getname (name)
  return db:fetch(ndb.db.people, db:eq(ndb.db.people.name, string.title(name)))[1]
end

local singular_city = {
  [""] = "Rogue",
  Mhaldor = "Mhaldorian",
  Ashtan = "Ashtani",
  Hashan = "Hashani",
  Eleusis = "Eleusian",
  Shallam = "Shallamese",
  Targossas = "Targossian",
  Cyrene = "Cyrenian"
}

local plural_city = {
  [""] = "Rogues",
  Mhaldor = "Mhaldorians",
  Ashtan = "Ashtani",
  Hashan = "Hashani",
  Eleusis = "Eleusians",
  Shallam = "Shallamese",
  Targossas = "Targossians",
  Cyrene = "Cyrenians"
}

local singular_class = {}

local plural_class = {
  Apostate    = "Apostates",
  Bard        = "Bards",
  Blademaster = "Blademasters",
  Dragon      = "Dragons",
  Druid       = "Druids",
  Infernal    = "Infernals",
  Jester      = "Jesters",
  Magi        = "Magi",
  Monk        = "Monks",
  Occultist   = "Occultists",
  Paladin     = "Paladins",
  Priest      = "Priests",
  Runewarden  = "Runewardens",
  Sentinel    = "Sentinels",
  Serpent     = "Serpents",
  Shaman      = "Shamans",
  Sylvan      = "Sylvans",
}

function ndb.getpluralclass(class, count)
  if count <= 1 then
    return class
  else
    return plural_class[class]
  end
end

function ndb.getpluralcity(city, count)
  if count <= 1 then
    return singular_city[city]
  else
    return plural_city[city]
  end
end

local function getcolor(name)
  local person = ndb.getname(name)

  if not person then return "" end -- in case the person doesn't exist

  local city, conf, color = person.city, svo.conf

  -- order of priority: watchfor > divine > city > order > house > citizens.
  if (city == "" or city == "rogue") then city = "" else city = city:lower() end -- known rogues are returned as ""

  -- color first
  if conf.highlightwatchfor and svo.me.watchfor[name] then
    color     = conf.watchforcolor or "a_darkwhite"

  elseif conf.highlightdivine and person.immortal == 1 then
    color     = conf.divinecolor or "a_darkwhite"

  elseif conf.highlightcity and person.cityenemy == 1 then
    color     = conf.citycolor or "a_darkwhite"

  elseif conf.highlightorder and person.orderenemy == 1 then
    color     = conf.ordercolor or "a_darkwhite"

  elseif conf.highlighthouse and person.houseenemy == 1 then
    color     = conf.housecolor or "a_darkwhite"

  elseif order and conf["highlight"..order] then
    color     = conf[order.."color"] or "a_darkwhite"

  elseif city == "" and conf.highlightrogues then
    color     = conf.roguescolor or "a_darkwhite"

  elseif city ~= "" and conf["highlight"..city] then
    color     = conf[city.."color"] or "a_darkwhite"
  end

  return color
end

function ndb.getcolor(name)
  assert(type(name) == "string", "ndb.getcolor: name to get a color of is required")

  local color = getcolor(name)

  return ((color and color ~= "") and '<'..color..'>' or "")
end

function ndb.getcolorn(name)
  assert(type(name) == "string", "ndb.getcolorn: name to get a color of is required")

  local color = getcolor(name)

  return ((color and color ~= "") and ('<'..color..'>'..name..'<reset>') or name)
end

function ndb.getcolorp(name)
  assert(type(name) == "string", "ndb.getcolorp: name to get a color of is required")

  local color = getcolor(name)

  return color
end

for _, format in ipairs{"bold", "underline", "italicize"} do
  ndb["should"..format] = function(name)
    assert(type(name) == "string", "ndb.should"..format..": name to get a color of is required")

    local person = ndb.getname(name)

    if not person then return false end -- in case the person doesn't exist

    local city, conf, color = person.city, svo.conf

    return (conf[format.."watchfor"] and svo.me.watchfor[name])    or
           (conf[format.."city"] and person.cityenemy == 1)        or
           (conf[format.."order"] and person.orderenemy == 1)      or
           (conf[format.."house"] and person.houseenemy == 1)      or
           (conf[format.."divine"] and person.immortal == 1)       or
           (order and conf[format..order])                         or
           ((city == "" or city == "rogue") and conf[format.."rogues"]) or
           (city and conf[format..city])                           or false
  end
end

function ndb.addname(name)
  local temp_name_list = {}

  if type(name) == "table" then
    for i = 1, #name do
      temp_name_list[#temp_name_list+1] = {name = name[i]:title()}
    end
  else
    temp_name_list = {{name = name:title()}}
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  raiseEvent("NameDB got new data")
end

function ndb.setiff(name, status)
  local name = name:lower():title()

  local category = "iff"
  local towhat

  -- -1 autodetected, 1 enemy, 2 ally
  local status = status:lower()
  if status == "enemy" then
    towhat = 1
  elseif status == "ally" then
    towhat = 2
  else
    towhat = -1
  end

  local temp_name_list = {{
    name = name,
    [category] = towhat
  }}

  db:merge_unique(ndb.db.people, temp_name_list)
end

-- ndb.support

function ndb.tablemerge(t, other)
   for other_key, other_items in pairs(other) do
      if not t[other_key] then
         t[other_key] = other_items
      else
         local group = t[other_key]
         for item_key, item_value in pairs(other_items) do
            group[item_key] = item_value
         end
      end
   end
   return t
end

-- given a string and a table of possible answers, returns the first possible answer, if any
function ndb.findfromtable(input, valid)
  local sfind = string.find

  for i = 1, #valid do
    if sfind(input, valid[i], 1, true) then return valid[i] end
  end
end

function ndb.showinfamous()
  local infamous = {}
  for _, person in pairs(db:fetch(ndb.db.people, db:gte(ndb.db.people.infamous, 1))) do
    local infamy = ndb.isinfamous(person.name)

    if infamy and infamy >= 1 then
      infamous[infamy] = infamous[infamy] or {}
      infamous[infamy][#infamous[infamy]+1] = person.name
    end
  end

  svo.echof("Infamous names known in NameDB:")
  if not next(infamous) then svo.echof("(none found)") end
  for cat, people in pairs(infamous) do
    table.sort(people)
    echo(string.format("  %s: %s\n", ndb.valid.shortinfamous[cat], svo.concatand(people)))
  end
  showprompt()
end

function ndb.showhelp(entry)
  svo.echof("<0,250,0>"..ndb.help[entry].term.."<47,79,79>: "..svo.getDefaultColor()..table.concat(ndb.help[entry].definition, "\n"))
  svo.showprompt() echo'\n'
end

function ndb.honors(name, type)
  if ndb.honorsid then svo.echof("ndb.honors() for %s called, when already honours'ing %s - not going to do this.", name:title(), ndb.honorsname:title()) return end
  name = string.title(name)

  enableTrigger("Honors")

  if ndb.honorsid then killTimer(ndb.honorsid) end
  ndb.honorsid = tempTimer(2+getNetworkLatency(), function()
    disableTrigger("Honors")
    svo.echof("Honors on %s didn't happen - re-checking...", name)
    ndb.honorsid, ndb.gaghonours = nil, nil
    ndb.honors(name, type)
  end)

  ndb.honorsname = name
  send("honorsb " .. name, false) -- needs to full so it sees the clan listing

  if type == "quiet" then ndb.gaghonours = true end
end

function ndb.cancelhonors(quietly)
  ndb.manualcheck = nil
  ndb.checkingqwi = nil

  if (ndb.honorslist and next(ndb.honorslist)) or ndb.honorsid then
    ndb.honorslist = {}
    if ndb.honorsid then killTimer(ndb.honorsid) disableTrigger("Honors") end; ndb.honorsid = nil
    if not quietly then svo.echof("Cancelled honors-checking people.") end
  else
    if not quietly then svo.echof("Not checking anyone atm already.") end
  end
  if not quietly then svo.showprompt() end

  ndb.hidehonorswindow()
end

function ndb.getrankincity(city, name)
  city, name = city:title(), name:title()

  if ndb.valid.cityranks[city] then return ndb.valid.cityranks[city][name] end
end

-- update all info that we should be able to glean from honors.
-- might: if it's at -1, then it's default known
-- rank: -1 default unknown, -2 unranked
function ndb.updatebyhonors()
  -- took might check off, as the website doesn't show it
  if not svo.conf.usehonors then return end -- Achaea disallowed use of website scraping, can only honors on a 2s eq

  local data = db:fetch(ndb.db.people, db:AND(db:not_eq(ndb.db.people.immortal, 1), db:eq(ndb.db.people.xp_rank, -1)))

  ndb.honorslist = (function ()
    local t = {}
    for i,j in ipairs(data) do
      -- sanity check for weird names
      if j.name:find("^%u%l+$") then t[j.name] = true
      else db:delete(ndb.db.people, db:eq(ndb.db.people.name, j.name)) end
    end return t end)()

    if svo.conf.paused or not next(ndb.honorslist) then return end

    if not svo.conf.autocheck and not ndb.manualcheck then
      if table.size(ndb.honorslist) > 1 then
        echo'\n'
        if table.size(ndb.honorslist) <= 10 then
          svo.echofn("Got new names (%s), use '", svo.oneconcat(ndb.honorslist))
          setFgColor(unpack(svo.getDefaultColorNums))
          setUnderline(true)
          echoLink("ndb honorsnew", 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo("' to check them.\n")
        else
          svo.echofn("Got %d new names, use '", table.size(ndb.honorslist))
          setFgColor(unpack(svo.getDefaultColorNums))
          setUnderline(true)
          echoLink("ndb honorsnew", 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo("' to check them.\n")
        end
      end

      return
    end

    -- don't show anymore - checking isn't so intrusive anymore
    -- if table.size(ndb.honorslist) <= 10 then
    --   echo'\n' svo.echof("Have new names (%s) - going to check them.", svo.oneconcat(ndb.honorslist))
    -- else
    --   echo'\n' svo.echof("Have %s new names - going to check them.", table.size(ndb.honorslist))
    -- end

  if not ndb.honorsid then ndb.honors_next() end
end

function ndb.doexport()
  if not ndb.exportdata.location then return nil, "no export location" end

  local alldata = db:fetch(ndb.db.people)

  if not alldata or not next(alldata) then svo.echof("Your NameDB is empty! Check 'qw', 'citizens' to start filling it up. There's nothing to export otherwise...") return end

  for i = 1, #alldata do
    local p = alldata[i]

    -- see if we need to prune the result first
    if not ndb.exportdata.people.all then
      alldata[i] = nil

    else
      -- prune fields we don't need
      for key,value in pairs(ndb.exportdata.fields) do
        if key ~= "name" and not value then p[key] = nil end
      end

      -- prune internal fields starting with underscores
      local removekeys = {}
      for key, _ in pairs(p) do
        if key:sub(1,1) == '_' then
          removekeys[#removekeys+1] = key
        end
      end

      for i = 1, #removekeys do p[removekeys[i]] = nil end
    end
  end

  -- build the final table that we'll table.save()
  local exportable = {
    meta = { author = gmcp.Char.Status.name, date = os.date("%A %d, %b '%y"), fields =  ndb.exportdata.fields },
    data = alldata
  }

  local location = string.format("%s/%s's namedb, %s", ndb.exportdata.location, gmcp.Char.Status.name,os.date("%A %d, %b '%y"))
  table.save(location, exportable)
  echo'\n' svo.echof("Data exported okay, it's in %s.", location)
end

-- reads selected files for fields available within it to import
function ndb.getimportfields()

  if not ndb.importdata.location or not io.exists(ndb.importdata.location) then ndb.importdata.location = nil; return end

  ndb.importdata.data = {}
  table.load(ndb.importdata.location, ndb.importdata.data)
  if not ndb.importdata.data then svo.echof("Couldn't read the file - maybe it's corrupted? Try another.") return end

  for k,v in pairs(ndb.importdata.data.meta.fields) do if ndb.schema.people[k] then ndb.importdata.fields[k] = true end end
end

function ndb.doimport()
  if not ndb.importdata.data then return nil, "no data loaded in ndb.importdata.data" end

  -- copy data over for importing with only the fields we need
  local temp_name_list = {}

  -- data.data as the original data is stored in .data of the new field that's imported.
  for i = 1, #ndb.importdata.data.data do
    local p = ndb.importdata.data.data[i]

    temp_name_list[#temp_name_list + 1] = {
      name = p.name,
    }

    for k,v in pairs(p) do
      if ndb.importdata.fields[k] then
        temp_name_list[#temp_name_list][k] = v
      end
    end
  end

  db:merge_unique(ndb.db.people, temp_name_list)
  svo.echof("Imported %d name%s okay.", #temp_name_list, (#temp_name_list == 1 and '' or 's'))

  local c = #(db:fetch(ndb.db.people, db:eq(ndb.db.people.city, "Shallam")))
  if c ~= 0 then
    ndb.fixed_set(ndb.db.people.city, "Targossas", db:eq(ndb.db.people.city, "Shallam"))
    svo.echof("Migrated "..c.." Shallamese to be called Targossians now.")
  end

  raiseEvent("NameDB got new data")
  ndb.importdata.data = nil
end

function ndb.loadhighlights()
  ndb.highlightIDs = ndb.highlightIDs or {}
  collectgarbage("stop")

  ndb.cleartriggers()

  if svo.conf.ndbpaused then return end

  local highlight, watchfor = ndb.singlehighlight, svo.me.watchfor

  local dbnames = db:fetch(ndb.db.people)

  for i = 1, #dbnames do
    highlight(dbnames[i].name,
      dbnames[i].city or "",
      dbnames[i].order or "",
      dbnames[i].cityenemy or 0,
      dbnames[i].orderenemy or 0,
      dbnames[i].houseenemy or 0,
      watchfor[dbnames[i].name],
      dbnames[i].immortal or 0
    )
  end

  collectgarbage()
end

function ndb.singlehighlight(name, city, order, cityenemy, orderenemy, houseenemy, watchfor, immortal)
  if ndb.highlightIDs and ndb.highlightIDs[name] then
    killTrigger(ndb.highlightIDs[name])
  end

  if name == svo.me.name or svo.me.highlightignore[name] or svo.conf.ndbpaused then return end

  local color, bold, underline, italicize
  local conf = svo.conf

  -- order of priority: watchfor > divine > city > order > house > citizens.

  city = city:lower()
  if order == "" then order = false else order = order:lower() end

  -- color first
  if conf.highlightwatchfor and watchfor then
    color     = conf.watchforcolor or "a_darkwhite"

  elseif conf.highlightdivine and immortal == 1 then
    color     = conf.divinecolor or "a_darkwhite"

  elseif conf.highlightcity and cityenemy == 1 then
    color     = conf.citycolor or "a_darkwhite"

  elseif conf.highlightorder and orderenemy == 1 then
    color     = conf.ordercolor or "a_darkwhite"

  elseif conf.highlighthouse and houseenemy == 1 then
    color     = conf.housecolor or "a_darkwhite"

  elseif order and conf["highlight"..order] then
    color     = conf[order.."color"] or "a_darkwhite"

  elseif (city == "" or city == "rogue") and conf.highlightrogues then
    color     = conf.roguescolor or "a_darkwhite"

  elseif city and conf["highlight"..city] then
    color     = conf[city.."color"] or "a_darkwhite"
  end

  -- rest of things
  bold      = (conf.boldwatchfor and watchfor)            or
                (conf.boldcity and cityenemy == 1)        or
                (conf.boldorder and orderenemy == 1)      or
                (conf.boldhouse and houseenemy == 1)      or
                (conf.bolddivine and immortal == 1)       or
                (order and conf["bold"..order])           or
                ((city == "" or city == "rogue") and conf.boldrogues) or
                (city and conf["bold"..city])

  underline = (conf.underlinewatchfor and watchfor)       or
                (conf.underlinecity and cityenemy == 1)   or
                (conf.underlineorder and orderenemy == 1) or
                (conf.underlinehouse and houseenemy == 1) or
                (conf.underlinedivine and immortal == 1)  or
                (order and conf["underline"..order])      or
                ((city == "" or city == "rogue") and conf.underlinerogues) or
                (city and conf["underline"..city])

  italicize = (conf.italicizewatchfor and watchfor)       or
                (conf.italicizecity and cityenemy == 1)   or
                (conf.italicizeorder and orderenemy == 1) or
                (conf.italicizehouse and houseenemy == 1) or
                (conf.italicizedivine and immortal == 1)  or
                (order and conf["italicize"..order])      or
                ((city == "" or city == "rogue") and conf.italicizerogues) or
                (city and conf["italicize"..city])

  if not (color or bold or underline or italicize) then return end

  ndb.highlightIDs = ndb.highlightIDs or {}
  ndb.highlightIDs[name] = tempTrigger(name, ([[ndb.highlight("%s", %s, %s, %s, %s)]]):format(name,
    (color     and '"'..color..'"' or "false"),
    (bold      and "true" or "false"),
    (underline and "true" or "false"),
    (italicize and "true" or "false")
  ))
end

function ndb.cleartriggers()
  if not ndb.highlightIDs or not next(ndb.highlightIDs) then return end

  local killTrigger = killTrigger
  for k,v in pairs(ndb.highlightIDs) do
    killTrigger(v)
  end

  ndb.highlightIDs = {}
end

function ndb.highlight(who, color, bold, underline, italicize)
  -- c counts the appearance of the substring of the word in the line, k counts the character position
  local c, k = 1, 1
  while k > 0 do
    k = line:find(who, k)
    if k == nil then return; end
    c = c + 1

    if k == line:find("%f[%a]"..who.."%f[%A]", k) then
      if selectString(who, c-1) > -1 then
        if color     then fg(color) end
        if bold      then setBold(true) end
        if underline then setUnderline(true) end
        if italicize then setItalics(true) end
        resetFormat()
      else return end
    end

--    k = k + #who
    k = k + 1 -- this is a quicker optimization
  end
end

function ndb.finished_honors(event, name, type)
  if svo.conf.paused or not ndb.honorslist then return end
  local type = gaghonours and "quiet" or "manual"

  local name = next(ndb.honorslist or {})
  if not name then
    if type ~= "manual" then
      echo'\n'
      svo.echof("Done checking all new names.")
      svo.showprompt()
      raiseEvent("NameDB finished all honors")
    end

    ndb.manualcheck = nil
    ndb.hidehonorswindow()
    return
  end
end

function ndb.honors_next(argument)
  if not svo.conf.autocheck and not ndb.manualcheck then return end
  if svo.conf.usehonors and not svo.bals.equilibrium then return end
  if not svo.conf.usehonors and argument then return end -- argument is passed if this comes from a balance,
                                                         -- which is for usehonors only - with it off, autohonors will start many honors processes

  local name = next(ndb.honorslist or {})
  if not name then return end

  if svo.conf.usehonors then
    ndb.honors(name, "quiet")
  else
    --ndb.getinfo(name) -- Achaea disallowed use of website scraping
    return
  end

  ndb.honorslist[name] = nil
  local left = table.size(ndb.honorslist)

  local timeleft = {}
  if svo.conf.usehonors then
    -- honors takes 2s eq
    local leftseconds = left * 2

    local h,m,s = seconds2human(leftseconds)
    if h > 0 then
      timeleft[#timeleft+1] = h.."h"
    end
    if h > 0 and m > 0 then
      timeleft[#timeleft+1] = ", "
    end
    if m > 0 then
      timeleft[#timeleft+1] = m.."m"
    end
    if m > 0 and s > 0 then
      timeleft[#timeleft+1] = ", "
    end
    if s > 0 then
      timeleft[#timeleft+1] = s.."s"
    end
  end

  ndb.showhonorswindow(string.format("Checking %s, %s name%s%s left to check...\n", name, left, (left == 1 and '' or 's'), (next(timeleft) and '('..table.concat(timeleft)..')' or '')))
end
signals["svo got balance"]:connect(ndb.honors_next)
signals["namedb finished honors"] = luanotify.signal.new()
signals["namedb finished honors"]:connect(ndb.honors_next)

-- sk.togglehonors = function()
--   if svo.conf.usehonors then
--     signals["namedb finished honors"]:block(ndb.honors_next)

-- end
-- signals["svo config changed"]:connect(sk.togglehonors)
-- Svof (c) 2011-2015 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see <http://creativecommons.org/licenses/by-nc-sa/4.0/>.


signals.systemstart:emit()
tempTimer(0, function() systemloaded = true; raiseEvent("svo system loaded") end)

return _M;
